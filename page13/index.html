<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>倾旋的博客</title>
  <meta name="description" content="这个博客主要用来记录自己技术生涯中短小的收获和知识的备忘，还有就是一些做安全服务工作中的感受。方向可能会在不断改变：渗透测试、CTF、高效生活、应急响应、安全建设、读后感、代码审计、漏洞复现、运维杂项等等…
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/page13/">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="home">
  <a class="rss-link" href="/feed.xml">RSS Feed</a>
  <h1 class="page-heading">Articles</h1>

  <ul class="post-list">
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2018-18-31/">2018 - 挥手告别</a>
        </h2>
        
        <div class="post-meta">Dec 31, 2018</div>

        <div class="post-excerpt">
          <!--<h1 id="2017-与创业这条路挥手告别">2017 与创业这条路挥手告别</h1>

<p>2017是我蜕变最大的一年，工作辞了、准备创业、创业失败，最终写了一篇文章，与创业这条路挥手告别。</p>

<p>文章部分内容如下：</p>

<p>《关于一叶知安团队，我有些事情要对读者交代》</p>

<p>朋友们，好久不见，这么久没有跟大家谈心了，我就说一说你们心里存在的疑问。</p>

<p>从2017年年初我就加入了一叶知安，负责线上的一些运营、代表作的开发（漏洞演练平台）以及担任Web安全扫盲公开课的讲师。</p>

<p>一开始是从知乎专栏做起来的，经常做一些安全研究，并且把自己的收获分享出去，第一部分是针对市面上一些软WAF的ByPass合集。</p>

<p>那段日子还是很充实的，虽说待业在家，但是一直在团队里面跟（云杰、Snake、GodKiller、……）都有约定，就是在今年的暑假成立一个公司，算是开始创业吧。</p>

<p>我们在一起产生了许多想法，包括如何打开市场，预估团队的价值和发展方向，还有如何提升关注热度。</p>

<p>我自主研发了Web漏洞演练平台，初衷是想给许多刚加入信安行业而选择Web安全领域的伙伴提供漏洞学习的方便，经过了一个月的Coding……最终做成了第一个版本，当然也存在诸多可以优化的地方和接口方面的扩展，睡觉之前都在思考如何做的更好。</p>

<p>开发期间是我一个人住在家里，一天不开口几次，很少和朋友出去聚一聚，每天的不规律作息，导致生病，自己去医院检查，拍了CT（颈椎变形了、问题不大，就是有时候下雨腰会疼，应该是某种关节炎吧），我以为这会是对病魔抵抗的战争提前吹响了号角，幸运的是只是一个可以用OTC解决的病，放下心后，花了几天调整身体。</p>

<p>于此同时也在学习技术，在小密圈和知乎专栏发布文章，和朋友们交流网络运营方面的技巧。</p>

<p>接着认识了很多目前经常联系的朋友，微信的联系人数从20多直线上升到目前的700多人，后来读者群的人数越来越多，需要把控广告、吹水、斗图的现象了，而我也每天都在群里与大家交流我的想法，把他们的反馈和建议写到我的备忘录中，以方便进行下一步的计划。</p>

<p>渐渐的快到了6月份，我开始感觉到一个人生活变得乏味，想多出去接触新鲜的面孔，更多的也是充满了对创业中收获的渴望。</p>

<p>我们团队的成员如愿以偿的见面了，首要任务是要解决一个注册公司的问题，还有办公场地，人员住宿等，这些问题夹杂在一起确实有点考验我们的耐心，时间一天一天的流逝，我们的计划也渐渐成熟，但是也将我们变得焦灼……</p>

<p>以上这些问题因为一些不可抗力的因素导致拖长，最终不得而散。</p>

<p>小密圈开始停更、知乎专栏开始停更、直至我退出了那个陪伴我不知道多少个日夜的读者群。</p>

<p>最终我还是没有离开那个地方，因为当时我不想就此停歇，我需要伙伴来与我并肩作战，怕就怕身后空无一人，但是时间太久了，我的积蓄也花的差不多达到我预期的数额了，然后我就决定开始做培训，将之前的个人开销赚回来。</p>

<p>培训是以一叶知安的名义做的，定下这个决定之前我有考虑过这么做的意义。</p>

<p>首先，如果以团队的名义去做，那就要一直对团队以及读者们负责，就要一直发展下去，将热度一直保持，反之，是徒劳的，一个团队在网络中，必须要持之以恒的坚持，保持最优秀的状态，最后。我们决定在以后还是会发展一叶知安，那么，在这里我给大家道个歉，一人之力难以帮助大家太久太久，我会把我自己掌握的、以及收获的都慢慢告诉大家。</p>

<p>写这篇文章的原因就是我今天打开了我们的专栏，看到我发布公告、技术文章的日期，发现时间过得真快，一晃而过，我已经在一家企业上班了，每天规律的作息、处理着工作中一些繁杂琐事，平凡的过着每一天。偶尔我也会写一写自己的心得和技术方面的进步收获。</p>

<p>目前团队原来的成员都很少联系（可能是因为尴尬），我们有过共同的目标，以此我感到荣幸和幸运，以往我是不在圈内活跃的，为了团队发展而展露自己的能力，这或许是安全圈内团队成长起来的必经之路。</p>

<p>感谢那些安全媒体在我们发布文章之后来询问是否授权转载，虽然我现在说话已经没有力度了，但是专栏是一直存在的，每一篇文章以及截图我们都有证明我们的努力，我们的每一个脚步。</p>

<p>目前我的培训已经完成三分之一了，在最后我还是会将视频发布给大家（当然要征得学员的统一意见），供大家学习，由于是第一次开培训，可能有些讲的不好，其中继承了不少之前讲Web扫盲公开课的方式（独创），这些技巧都是我从网上大把教程中总结出来的弊端，然后优化成自己的授课方式讲出来，在讲课中我锻炼了自己的表达能力，有时候会口吃，还好有朋友们指正，还记得讲SQL注入的时候，那堂分享课讲了大概两个小时四十分钟左右。</p>

<p>在以后的日子里，我会慢慢学习，低调发展，尽量把自己掌握的技术形成一个标准，录制成一套完整的安全教学视频，不为什么，只是想把一件事情做到最好。</p>

<p><strong>刨除技术层面，算是一种广义的黑客精神吧</strong></p>

<p>不知道大家现在过得怎么样了，我衷心祝福大家能每天开开心心的，乐观生活。感谢有你们的陪伴，成就了现在的我。</p>

<p>上次参加 DEFCON 0571 （杭州）沙龙，见了很多想见的朋友，渐渐的这是我第二次参加沙龙了，熟悉了这种技术氛围，认识了不少有想法的朋友，当然也有很多大佬~ 他们都很谦虚的，我们的交流方式除了线上，可能就是传统的面基了，哈哈，前两天还基了一个朋友，年纪不大，也在创业，仿佛他所想的都能与我产生某种共鸣，就好像某一天你看到一个人跟你一样在过去做过同样的事情。</p>

<p>这个公众号就当做我和大家交流的方式吧，并不想太目的的去写一些东西，感性趣就来看看。（若有错别字，将就看吧……）</p>

<p>2017/08/26
倾旋</p>

<p><a href="https://mp.weixin.qq.com/s/IzCJk69RYL_IrTFVaP2n1A">&gt;&gt;原文</a></p>

<p>现在公众号已经废除、一叶知安已经解散，不会再去创作了，这篇文章意味着我接受了失败的结果，吸取教训，慢慢成长。</p>

<p>写上面这篇文章的时候是从南京落魄的逃离至杭州刚刚安定下来的时候，在此谢谢霖的照顾。</p>

<p>后续找了一份比较清闲的安全服务乙方工作，待遇还可以，但是团队是刚组建起来，需要很大精力投入建设，正是因为闲，我又把C/C++这类学习成本比较高的语言拾起来……至今我觉得我的选择是对的。</p>

<p>同时也给我的“前渗透框架”项目奠定了基础，锻炼了我的能力，使我在安全领域拥有了更多的方向。</p>

<p>参加沙龙的时候，有幸结识了我的前辈 - <strong>GUO</strong>，在聊到职业现状时，他建议我去更大的平台（奇虎/360企业安全集团），我非常认同前辈的说法——“人不能一直活在舒适区”。</p>

<p>当时只是简单聊聊，内心是对自己很不满意的，认为360是一个具有品牌力量的公司，能进入的绝非平庸之辈，我这样的可能面试都过不了，学历不高、能力不强，极度不自信。</p>

<p>正是这种极度不自信催促了我学习上进的心，然后开始将渗透做深，与ShadowTeam里的师傅们交流。</p>

<p>在2017年最后一次与GUO对话的时候，我说了一句：“我一定会自信的走进去（360）”</p>

<h1 id="2018">2018</h1>

<p>过完年，杭州的天气依旧有些冷，决定做几个漂亮的渗透案例，到时候给自己的简历加分……</p>

<p>花了一个月的时间，产出了两篇文章：</p>

<ul>
  <li><a href="https://payloads.online/archivers/2017-12-28/1">针对国内一大厂的后渗透 - 持续</a></li>
  <li><a href="https://payloads.online/archivers/2018-01-30/1">针对某跨国企业的一次渗透测试-持续</a></li>
</ul>

<p>分别都拿到域控作为结束，我将文章脱敏后发出来，跨国企业的安全部负责人在安全圈看到了这个文章，通过邮箱取得联系，最后我决定删除文章，当时圈里都传遍了，<strong>朋友圈现在还有聊天记录</strong>。</p>

<p>的确这种做法是不对的，厂商也差点报警处理，还好没有太大影响，并且我也给了修复建议，碰到了好人，运气好。</p>

<p>三四月份，天气开始热起来了，我已经写好简历，按照流程面试完后，准备奔赴上海找房……</p>

<h2 id="四月向魔都宣告---我来了">四月向魔都宣告 - 我来了</h2>

<p>完成了一个梦想，真好，转眼间逝去的两年，我不断成长，感受人情冷暖、接纳新鲜事物，至今已学会如何照顾自己，让生活更具有色彩，人生更加无憾。</p>

<p>谢谢我的朋友们给我的支持！</p>

<p><a href="https://payloads.online/archivers/2018-04-20/1">&gt;&gt;原文</a></p>

<p>于是在八月份写了一篇总结：</p>

<h3 id="入职">入职</h3>

<p>在炎热的四月底，我背着双肩包，顶着一头乱发来到上海，傍晚下了高铁，想到公司附近转转，赶上了团队的技术分享，晚上喝了很多酒，印象最深的还是那烧烤、啤酒、热情的人。</p>

<h3 id="工作">工作</h3>

<p>慢慢的接触到了很多大牛，都很低调，从开始的渗透测试转向新型安全服务，偏向产品的路线，在接触产品的过程中也学到了不少；</p>

<p>有应急响应、代码审计、流量分析、渗透测试等，技术的广度提升了很多，也看到了技术变现有更多的可能，唯一就是我要不断的创新、发散自己的思维。</p>

<h3 id="近况">近况</h3>

<p>最近没有规划近期目标，让我觉得有点小焦虑，很多东西都可以一步一步来的，准备养成一个写日记的习惯。</p>

<h3 id="收获">收获</h3>

<p>在日常和同事聊起安服的时候，都能感受到一个好的安全服务工程师应该有的素养，首先就是要符合企业价值观，稳步成长。</p>

<p>在和客户接触的时候，不管是售前阶段、售后阶段，都要具备良好的表达沟通能力，大企、小司你要清楚各种客户他最根本的需要，接触的多了你的解决方案才会更容易落地、更容易被认可。</p>

<p>“引导客户需求” 每个人都有短处，将自己的长处发挥到极致是最好的状态，这块谈的不是销售技巧，而是个人营销的技巧，在现场、电话中，要清楚的知道自己的定位，“我是一个安全服务工程师，我的职责就是给予客户的问题技术层面的解决方案。”</p>

<p><a href="https://payloads.online/archivers/2018-08-03/2">&gt;&gt;原文</a></p>

<h1 id="现在">现在</h1>

<p>回首这两年，我是一个新人，对于技术有时太过于执着，会做一些没有意义的研究，会讲一些自己讲过好几次讲过的东西，我都不会耐烦，因为在吸收它们的时候，我花费的心力是我讲出来花费的心力的好几倍。</p>

<p>目前在这边负责安全服务相关的技术支撑，磨练了我很多的能力，也包括我的成长，今年完成了不知道多少东西，但是隐约记得一些：</p>

<ul>
  <li>掌握C/C++能够开发简单项目</li>
  <li>后渗透能力提升</li>
  <li>开发FlaskWhatweb（Python）</li>
  <li>开发nse_vuln（Lua &amp; Nmap）</li>
  <li>开发scanDnsToDB(C++)</li>
  <li>完成N个项目渗透测试</li>
  <li>掌握应急响应处理流程</li>
  <li>5月份内部分享-Fuzz Bypass WAF</li>
  <li><a href="https://payloads.online/archivers/2018-11-30/1">11月份内部分享-彻底理解Windows认证</a></li>
  <li><a href="https://payloads.online/archivers/2018-12-22/1">10月份内部分享-DLL Hijacking &amp; COM Hijacking ByPass UAC</a></li>
  <li>读了大约10多本书（技术偏多）</li>
  <li>旅游了一次</li>
  <li>写书-半途而废</li>
  <li>换了MAC Pro 2018 ;( 心疼并快乐着</li>
</ul>

<p>最近在研究邮件相关的安全，也学习到了不少东西，准备放入下一次议题中。</p>

<h1 id="最后">最后</h1>

<p>我接受我感情的失败、创业的失败和自己的缺点，准备勇敢的步入2019……</p>

<p>说实话，在敲出2019的时候，既感觉陌生又感觉在期待着什么，今天是用来告别的，可能不适合立下多么难以完成的Flag。</p>

<p>事事不忘初心，坚持自己，变得更强大就好，我依然是个孩子。</p>

-->
          年底了，就抽两个小时写写自己的收获吧。
          <p>
            <a class="post-link" href="/archivers/2018-18-31/">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2018-12-22/1">DLL Hijacking &amp; COM Hijacking ByPass UAC - 议题解读</a>
        </h2>
        
        <div class="post-meta">Dec 22, 2018</div>

        <div class="post-excerpt">
          使用COM组件
      <li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8Ecom%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB--clsid-key" id="markdown-toc-应用程序与com注册表的关系--clsid-key">应用程序与COM注册表的关系 – CLSID Key</a></li>
    
  
  <li><a href="#0x08-com%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" id="markdown-toc-0x08-com组件的加载过程">0x08 COM组件的加载过程</a></li>
  <li><a href="#0x09-com%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86" id="markdown-toc-0x09-com组件的劫持原理">0x09 COM组件的劫持原理</a></li>
  <li>
<a href="#0x10-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcom%E7%BB%84%E4%BB%B6%E5%8A%AB%E6%8C%81" id="markdown-toc-0x10-实现一个com组件劫持">0x10 实现一个COM组件劫持</a>    <ul>
      <li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcom%E7%BB%84%E4%BB%B6%E5%8A%AB%E6%8C%81--%E5%88%86%E6%9E%90" id="markdown-toc-实现一个com组件劫持--分析">实现一个COM组件劫持 – 分析</a></li>
    </ul>
  </li>
  <li><a href="#0x11-uac%E7%AE%80%E4%BB%8B" id="markdown-toc-0x11-uac简介">0x11 UAC简介</a></li>
  <li><a href="#0x12-bypass-uac%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" id="markdown-toc-0x12-bypass-uac的几种方式">0x12 ByPass UAC的几种方式</a></li>
  <li><a href="#0x13-bypass-uac%E7%9A%84%E5%8E%9F%E7%90%86---%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87autoelevate" id="markdown-toc-0x13-bypass-uac的原理---自动提升autoelevate">0x13 ByPass UAC的原理 - 自动提升（autoElevate）</a></li>
  <li>
<a href="#0x14-bypass-uac%E6%BC%94%E7%A4%BA---fodhelperexe" id="markdown-toc-0x14-bypass-uac演示---fodhelperexe">0x14 Bypass UAC演示 - fodhelper.exe</a>    <ul>
      <li><a href="#bypass-uac%E6%BC%94%E7%A4%BA---fodhelperexe%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90" id="markdown-toc-bypass-uac演示---fodhelperexe自动化分析">ByPass UAC演示 - fodhelper.exe（自动化分析）</a></li>
    </ul>
  </li>
  <li>
<a href="#0x15-%E6%8C%96%E6%8E%98bypass-uac%E7%9A%84%E6%96%B9%E6%B3%95" id="markdown-toc-0x15-挖掘bypass-uac的方法">0x15 挖掘ByPass UAC的方法</a>    <ul>
      <li><a href="#%E5%AF%BB%E6%89%BE%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F--sigcheckexe" id="markdown-toc-寻找自动提升权限的应用程序--sigcheckexe">寻找自动提升权限的应用程序 – Sigcheck.exe</a></li>
      <li><a href="#%E5%AF%BB%E6%89%BE%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-stringsexe" id="markdown-toc-寻找自动提升权限的应用程序-stringsexe">寻找自动提升权限的应用程序 Strings.exe</a></li>
      <li><a href="#%E5%AF%BB%E6%89%BE%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-sigcheckexe" id="markdown-toc-寻找自动提升权限的应用程序-sigcheckexe">寻找自动提升权限的应用程序 Sigcheck.exe</a></li>
    </ul>
  </li>
  <li><a href="#0x16-%E5%8F%82%E8%80%83" id="markdown-toc-0x16-参考">0x16 参考</a></li>
  <li><a href="#0x17-%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%88%90%E9%95%BF%E5%8F%A3%E8%A2%8B" id="markdown-toc-0x17-关于我的安全成长口袋">0x17 关于“我的安全成长口袋”</a></li>


<h2 id="0x00-前言">0x00 前言</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x00.png" alt=""></p>

<p>本文章只是方便阅读PPT，对于深入的去理解没有太大帮助，只是做个知识索引。</p>

<p>目录如下：</p>

<ul>
  <li>何为劫持</li>
  <li>DLL是什么</li>
  <li>DLL加载的过程</li>
  <li>DLL劫持的原理</li>
  <li>实现一个DLL劫持 - DLL Main</li>
  <li>什么是COM</li>
  <li>应用程序与COM注册表的关系</li>
  <li>COM组件加载的过程</li>
  <li>COM组件劫持的原理</li>
  <li>实现一个COM组件劫持</li>
  <li>UAC简介</li>
  <li>ByPASS UAC的几种方式</li>
  <li>ByPASS UAC原理</li>
  <li>ByPASS UAC演示</li>
  <li>挖掘ByPASS UAC的方法</li>
</ul>

<p><strong>PPT共享在文末的小密圈中了</strong></p>

<h2 id="0x01-何为劫持">0x01 何为劫持</h2>

<p>即：“在正常事物发生之前进行一个旁路操作”</p>

<h2 id="0x02-dll是什么">0x02 DLL是什么</h2>

<p>DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。 在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x01.png" alt=""></p>

<p>在Windows平台下，我们使用的应用程序中的功能其实大多都很相似，窗口调用窗口的模块，分配内存调用内存管理的模块，文件操作调用IO模块，这些模块在Windows里的具体表现就是DLL文件。</p>

<h2 id="0x03-dll的加载过程">0X03 DLL的加载过程</h2>

<ul>
  <li>1.程序所在目录</li>
  <li>2.程序加载目录（SetCurrentDirectory）</li>
  <li>3.系统目录即 SYSTEM32 目录</li>
  <li>4.16位系统目录即 SYSTEM 目录</li>
  <li>5.Windows目录</li>
  <li>6.PATH环境变量中列出的目录</li>
</ul>

<p>PS：Windows操作系统通过“DLL路径搜索目录顺序”和“Know DLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p>

<p>注册表路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x02.png" alt=""></p>

<h3 id="dll的加载过程--know-dlls注册表项">DLL的加载过程 – Know DLLs注册表项</h3>

<p>Know DLLs注册表项里的DLL列表在应用程序运行后就已经加入到了内核空间中，多个进程公用这些模块，必须具有非常高的权限才能修改。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x03.png" alt=""></p>

<h3 id="dll的加载过程--process-monitor">DLL的加载过程 – Process Monitor</h3>

<p>Process Monitor是Windows的高级监视工具，可显示实时文件系统，注册表和进程/线程活动。</p>

<p>它结合了两个传统Sysinternals实用程序Filemon和Regmon的功能，并添加了大量增强功能，包括丰富和非破坏性过滤，全面的事件属性，如会话ID和用户名，可靠的流程信息，带有集成符号支持的完整线程堆栈 对于每个操作，同时记录到文件等等。 其独特的强大功能将使Process Monitor成为系统故障排除和恶意软件搜索工具包的核心实用程序。</p>

<p>下载地址： https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-utilities</p>

<h3 id="dll的加载过程--process-monitor-filter">DLL的加载过程 – Process Monitor Filter</h3>

<p>Process Monitor Filter是用于过滤应用程序输出的一部分功能，可以使得进程事件结果成为你想要的内容。</p>

<p>常用过滤条件：Process Name，Path，Result</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x04.png" alt=""></p>

<h2 id="0x04-dll劫持的原理">0x04 DLL劫持的原理</h2>

<p>DLL寻找过程：</p>

<ul>
  <li>1.程序所在目录</li>
  <li>2.系统目录即 SYSTEM32 目录</li>
  <li>3.16位系统目录即 SYSTEM 目录</li>
  <li>4.Windows目录</li>
  <li>5.加载 DLL 时所在的当前目录</li>
  <li>6.PATH环境变量中列出的目录</li>
</ul>

<p><strong>如果在应用程序寻找成功之前，将我们自己创造的DLL文件放入寻找目录中，那么应用程序就会加载我们自己的DLL？</strong></p>

<h2 id="0x05-实现一个dll劫持--dll-main">0x05 实现一个DLL劫持 – DLL Main</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span> 
<span class="c1">// 指向自身的句柄</span>
 <span class="n">_In_</span> <span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> 
<span class="c1">// 调用原因</span>
 <span class="n">_In_</span> <span class="n">DWORD</span>     <span class="n">fdwReason</span><span class="p">,</span>
<span class="c1">// 加载方式（隐式、显式）</span>
  <span class="n">_In_</span> <span class="n">LPVOID</span>    <span class="n">lpvReserved</span>
<span class="p">);</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>载入状态</th>
      <th>值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DLL_PROCESS_ATTACH</td>
      <td>1</td>
      <td>被进程装载时</td>
    </tr>
    <tr>
      <td>DLL_PROCESS_DETACH</td>
      <td>0</td>
      <td>被进程卸载时</td>
    </tr>
    <tr>
      <td>DLL_THREAD_ATTACH</td>
      <td>2</td>
      <td>被线程装载时</td>
    </tr>
    <tr>
      <td>DLL_THREAD_DETACH</td>
      <td>3</td>
      <td>被线程卸载时</td>
    </tr>
  </tbody>
</table>

<h3 id="实现一个dll劫持--dll-main">实现一个DLL劫持 – DLL Main</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">APIENTRY</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hModule.%p lpReserved.%p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">lpReserved</span><span class="p">);</span><span class="err">  </span> <span class="k">switch</span> <span class="p">(</span><span class="n">ul_reason_for_call</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Process attach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Process detach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Thread attach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Thread detach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Q：如果应用程序调用的DLL没有DLLMain函数呢？</p>

<p>A：这需要实现指定导出函数，然后等待导出函数执行完毕再Load真实DLL。</p>

<h3 id="案例">案例</h3>

<p>参考：</p>

<ul>
  <li>http://payloads.online/archivers/2018-06-09/1</li>
  <li>http://payloads.online/archivers/2018-08-15/1</li>
  <li>https://docs.microsoft.com/en-us/windows/desktop/dlls/dllmain</li>
  <li>https://baike.baidu.com/item/dll%E5%8A%AB%E6%8C%81/223198</li>
</ul>

<h3 id="自动化测试">自动化测试</h3>

<p>Rattler：https://github.com/sensepost/rattler</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x05.png" alt=""></p>

<p>Robber：https://github.com/MojtabaTajik/Robber</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x06.png" alt=""></p>

<h2 id="0x06-什么是com">0x06 什么是COM</h2>

<p>COM是Component Object Model （组件对象模型）的缩写。
COM是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。</p>

<h2 id="0x07-应用程序与com注册表的关系">0x07 应用程序与COM注册表的关系</h2>

<p>首先需要介绍一下注册表，注册表可以理解为一个树状结构的数据库，它具有一些特殊的<a href="https://docs.microsoft.com/en-us/windows/desktop/sysinfo/registry-value-types">数据类型</a>用来存储一些数据满足应用程序的需要。</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/sysinfo/about-the-registry</p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HKEY_CLASSES_ROOT</td>
      <td>用于存储一些文档类型、类、类的关联属性。</td>
    </tr>
    <tr>
      <td>HKEY_CURRENT_CONFIG</td>
      <td>用户存储有关本地计算机系统的当前硬件配置文件信息。</td>
    </tr>
    <tr>
      <td>HKEY_CURRENT_USER</td>
      <td>用于存储当前用户配置项。</td>
    </tr>
    <tr>
      <td>HKEY_CURRENT_USER_LOCAL_SETTINGS</td>
      <td>用于存储当前用户对计算机的配置项。</td>
    </tr>
    <tr>
      <td>HKEY_LOCAL_MACHINE</td>
      <td>用于存储当前用户物理状态。</td>
    </tr>
    <tr>
      <td>HKEY_USERS</td>
      <td>用于存储新用户的默认配置项。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.microsoft.com/en-us/windows/desktop/sysinfo/hkey-classes-root-key">HKEY_CLASSES_ROOT</a> = HKEY_LOCAL_MACHINE + HKEY_CURRENT_USER</p>

<h3 id="应用程序与com注册表的关系---clsid">应用程序与COM注册表的关系 - CLSID</h3>

<p>首先需要介绍一下CLSID(Class Identifier)，中文翻译为：“全局唯一标识符”。</p>

<p>CLSID是指Windows系统对于不同的应用程序，文件类型，OLE对象，特殊文件夹以及各种系统组件分配的一个唯一表示它的ID代码，用于对其身份的标识和与其他对象进行区分。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x07.png" alt=""></p>

<h3 id="应用程序与com注册表的关系---使用com组件">应用程序与COM注册表的关系 - 使用COM组件</h3>

<p>按下Ctrl+R打开运行窗口，键入 
::{20D04FE0-3AEA-1069-A2D8-08002B30309D} 即可打开“我的电脑”</p>

<p>::{645FF040-5081-101B-9F08-00AA002F954E} 回收站</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">CLSID</span><span class="err">结构体：</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GUID</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Data1</span><span class="p">;</span> <span class="c1">// 随机数</span>
    <span class="n">WORD</span> <span class="n">Data2</span><span class="p">;</span> <span class="c1">// 和时间相关</span>
    <span class="n">WORD</span> <span class="n">Data3</span><span class="p">;</span> <span class="c1">// 和时间相关</span>
    <span class="n">BYTE</span> <span class="n">Data4</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// 和网卡MAC相关</span>
    <span class="p">}</span> <span class="n">GUID</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">GUID</span> <span class="n">CLSID</span><span class="p">;</span> <span class="err"> </span><span class="c1">// 组件ID</span>
    <span class="k">typedef</span> <span class="n">GUID</span> <span class="n">IID</span><span class="p">;</span> <span class="err"> </span> <span class="err"> </span><span class="c1">// 接口ID</span>
</code></pre></div></div>

<h3 id="应用程序与com注册表的关系--clsid-key">应用程序与COM注册表的关系 – CLSID Key</h3>

<table>
  <thead>
    <tr>
      <th>Key Name</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>InprocHandler32</td>
      <td>指定应用程序使用的自定义处理程序</td>
    </tr>
    <tr>
      <td>InprocServer32</td>
      <td>注册32位进程所需要的模块、线程属性配置</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID   
 	{CLSID}       
	InprocServer32          (Default) = path          
	ThreadingModel 	    = value
</code></pre></div></div>

<p>常见CLSID Key：</p>

<p>More： https://docs.microsoft.com/zh-cn/windows/desktop/com/clsid-key-hklm</p>

<h2 id="0x08-com组件的加载过程">0x08 COM组件的加载过程</h2>

<ul>
  <li>1.HKCU\Software\Classes\CLSID</li>
  <li>2.HKCR\CLSID</li>
  <li>3.HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Objects\</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x08.png" alt=""></p>

<h2 id="0x09-com组件的劫持原理">0x09 COM组件的劫持原理</h2>

<p>当进程寻找COM组件时，首先会寻找：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKCU\Software\Classes\CLSID
</code></pre></div></div>

<p>我们直接在CLSID下新建一个对象ID，就能够劫持某个进程或多个进程。</p>

<p>与DLL劫持原理相近，但是COM组件的劫持可以拓展很多东西，劫持的目标不一定是一个进程，劫持所需的文件不一定是一个DLL，它可以是一个.com文件、二进制PE文件、DLL文件，劫持的目标也可以是一个Windows API。</p>

<h2 id="0x10-实现一个com组件劫持">0x10 实现一个COM组件劫持</h2>

<p>MSF:/opt/metasploit-framework/embedded/framework/modules/exploits/windows/local/bypassuac_comhijack.rb</p>

<video src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/com_hijacking.mp4" controls="controls" width="500px">
哎呀~ 换个浏览器试试吧！
</video>

<h3 id="实现一个com组件劫持--分析">实现一个COM组件劫持 – 分析</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x09.png" alt=""></p>

<p>bypassuac_comhijack模块有两个方法：</p>

<ul>
  <li>Event Viewer</li>
  <li>Computer Managment</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x10.png" alt=""></p>

<p>经过分析，该模块是通过更改注册表，然后创建进程实现的bypassUAC。</p>

<h2 id="0x11-uac简介">0x11 UAC简介</h2>

<p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x11.png" alt=""></p>

<p>UAC需要授权的动作包括：</p>

<ul>
  <li>1.配置Windows Update</li>
  <li>2.增加或删除用户账户</li>
  <li>3.改变用户的账户类型</li>
  <li>4.改变UAC设置</li>
  <li>6.安装ActiveX</li>
  <li>6.安装或移除程序</li>
  <li>7.安装设备驱动程序</li>
  <li>8.设置家长控制</li>
  <li>9.将文件移动或复制到Program Files或Windows目录</li>
  <li>10.查看其他用户文件夹</li>
</ul>

<h2 id="0x12-bypass-uac的几种方式">0x12 ByPass UAC的几种方式</h2>

<ul>
  <li>1.白名单提权机制 - autoElevate</li>
  <li>2.DLL 劫持</li>
  <li>3.Windows 自身漏洞提权</li>
  <li>4.远程注入</li>
  <li>5.COM 接口技术</li>
</ul>

<h2 id="0x13-bypass-uac的原理---自动提升autoelevate">0x13 ByPass UAC的原理 - 自动提升（autoElevate）</h2>

<p>具有autoElevate属性True的应用程序会在启动时自动提升权限，而这些应用程序往往都具备微软的签名，微软认为它是可信的。故此，在该程序启动时，将会以管理员身份启动，假设我们通过COM技术或者DLL劫持该应用程序，也能够获得管理员权限，但是，上述两种技术比较苛刻：</p>

<ul>
  <li>1、可能需要高权限才能够完成</li>
  <li>2、分析成本较高</li>
</ul>

<h2 id="0x14-bypass-uac演示---fodhelperexe">0x14 Bypass UAC演示 - fodhelper.exe</h2>

<p>Path：C:\Windows\system32\fodhelper.exe</p>

<p>REG：HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x12.png" alt=""></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command /d C:\Windows\System32\cmd.exe /f
reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_DWORD /d 00000000 /f
</code></pre></div></div>

<video src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/bypass_uac.mp4" controls="controls" width="500px">
哎呀~ 换个浏览器试试吧！
</video>

<h3 id="bypass-uac演示---fodhelperexe自动化分析">ByPass UAC演示 - fodhelper.exe（自动化分析）</h3>

<ul>
  <li>fodhelper.exe</li>
  <li>eventvwr.exe</li>
</ul>

<p>配置项：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x14.png" alt=""></p>

<p>调用进程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x15.png" alt=""></p>

<p>利用过程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x16.png" alt=""></p>

<h2 id="0x15-挖掘bypass-uac的方法">0x15 挖掘ByPass UAC的方法</h2>

<h3 id="寻找自动提升权限的应用程序--sigcheckexe">寻找自动提升权限的应用程序 – Sigcheck.exe</h3>

<p>Strings与Sigcheck，这两款工具目前均由微软官方提供，主要用于查看文件相关信息。</p>

<p>下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/</p>

<ul>
  <li>[1]：strings.exe -s *.exe | findstr /i autoelevate</li>
  <li>[2]：sigcheck.exe -m C:\Windows\System32\cmd.exe</li>
</ul>

<h3 id="寻找自动提升权限的应用程序-stringsexe">寻找自动提升权限的应用程序 Strings.exe</h3>

<p>最好将string.exe放入C:\Windows\System32</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x17.png" alt=""></p>

<h3 id="寻找自动提升权限的应用程序-sigcheckexe">寻找自动提升权限的应用程序 Sigcheck.exe</h3>

<p>使用Python脚本调用：</p>

<p>https://gist.githubusercontent.com/riyazwalikar/cd31948f247b96d472b97be2a36030b4/raw/a7379c4f5c015e46d65703ee73e674b1c4315810/findelevate.py</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x18.png" alt=""></p>

<h2 id="0x16-参考">0x16 参考</h2>

<ul>
  <li>https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence</li>
  <li>https://docs.microsoft.com/zh-cn/windows/desktop/com/clsid-key-hklm</li>
  <li>https://offsec.provadys.com/UAC-bypass-dotnet.html?utm_source=tuicool&utm_medium=referral</li>
  <li>https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC</li>
  <li>https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-bypass-UAC/</li>
  <li>https://enigma0x3.net/2016/05/25/userland-persistence-with-scheduled-tasks-and-com-handler-hijacking/</li>
  <li>https://www.cyberbit.com/blog/endpoint-security/com-hijacking-windows-overlooked-security-vulnerability/</li>
  <li>https://technet.microsoft.com/zh-cn/library/2009.07.uac.aspx</li>
  <li>https://gist.githubusercontent.com/riyazwalikar/cd31948f247b96d472b97be2a36030b4/raw/a7379c4f5c015e46d65703ee73e674b1c4315810/findelevate.py</li>
  <li>https://github.com/rootm0s/WinPwnage/blob/master/functions/uac_fodhelper.py</li>
  <li>https://github.com/hfiref0x/UACME/tree/master/Source</li>
  <li>https://github.com/juliourena/plaintext/blob/master/CSharp%20Tools/UAC%20Bypass/uac_bypass_fodhelper.cs</li>
  <li>https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings</li>
  <li>https://docs.microsoft.com/zh-cn/sysinternals/downloads/sigcheck</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x19.png" alt=""></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x20.png" alt=""></p>

<h2 id="0x17-关于我的安全成长口袋">0x17 关于“我的安全成长口袋”</h2>

<p>本圈主要用来记录自己技术生涯中短小的收获和知识的备忘，还有就是一些做安全服务工作中的感受。</p>

<p>方向可能会在不断改变：渗透测试、CTF、高效生活、应急响应、安全建设、读后感、代码审计、漏洞复现、运维杂项等等… 我暂时关闭了发帖权限、分享权限； 因为我有一个小的朋友圈，经常讨论一些技术，会在这里用评论交流。</p>

<p>关闭发帖权限是因为不指望加入的朋友分享，我发表的都是我的收获，不想因为别人影响自己的东西，妨碍搜索和温习。</p>

<p>扫码可免费加入：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-10-08/0x24.png" alt=""></p>

--&gt;
          将之前都学习到的知识进行汇总，顺便把分享转化成文章
          <p>
            <a class="post-link" href="/archivers/2018-12-22/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2018-12-21/1">Windows - 内存管理</a>
        </h2>
        
        <div class="post-meta">Dec 21, 2018</div>

        <div class="post-excerpt">
          空间
  <li>HeapDestory // 销毁堆句柄</li>


<h2 id="0x02-heapcreate-example">0x02 HeapCreate Example</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ConsoleApplication2.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">// 堆管理</span>
<span class="cp">#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
</span>
<span class="n">VOID</span> <span class="nf">P</span><span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wprintf</span><span class="p">(</span><span class="n">contents</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">()</span>
<span class="p">{</span>

	<span class="c1">// 堆管理</span>
	<span class="cm">/*
	# 创建堆
	HANDLE HeapCreate(
	  DWORD  flOptions,
	  SIZE_T dwInitialSize,
	  SIZE_T dwMaximumSize
	);
	
	flOptions: 1.HEAP_CREATE_ENABLE_EXECUTE 代码允许执行
			   2.HEAP_GENERATE_EXCEPTIONS 如果分配内存失败，会产生异常
			   3.HEAP_NO_SERIALIZE 不进行连续存取
	dwInitialSize: 堆的初始化大小，如果为0，则系统会自动分配一个大小。
	dwMaximumSize: 堆的最大值，如果为0，将是一个可增长的堆，可以达到系统能够分配的最大值。
	*/</span>
	<span class="n">HANDLE</span> <span class="n">hHeap</span> <span class="o">=</span> <span class="n">HeapCreate</span><span class="p">(</span><span class="n">HEAP_CREATE_ENABLE_EXECUTE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hHeap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">P</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Error HeapCreate() ...</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="cm">/*
	# 获取堆句柄
	HANDLE GetProcessHeap();
	函数返回堆句柄，如果返回值为NULL，获取堆失败
	*/</span>
	<span class="n">HANDLE</span> <span class="n">hHeapRand</span> <span class="o">=</span> <span class="n">GetProcessHeap</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hHeapRand</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">P</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"GetProcessHeap() : No Heap ...</span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="cm">/*
	# 获取堆句柄
	DWORD GetProcessHeaps(
	  DWORD   NumberOfHeaps, // 输入参数，要获取的句柄数量
	  PHANDLE ProcessHeaps   // 输出参数，句柄数组，用于保存多个句柄
	);
	函数返回堆句柄，如果返回值为NULL，获取堆失败
	*/</span>
	<span class="n">CONST</span> <span class="n">DWORD</span> <span class="n">dwHeapMax</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hHeapsNum</span><span class="p">[</span><span class="n">dwHeapMax</span><span class="p">];</span>
	<span class="n">DWORD</span> <span class="n">dwHeapNum</span> <span class="o">=</span> <span class="n">GetProcessHeaps</span><span class="p">(</span><span class="n">dwHeapMax</span><span class="p">,</span> <span class="n">hHeapsNum</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">"Heap number : "</span> <span class="o">&lt;&lt;</span> <span class="n">dwHeapNum</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

	<span class="cm">/*
	# 为堆分配内存
	DECLSPEC_ALLOCATOR LPVOID HeapAlloc(
		HANDLE hHeap,  // 堆句柄
		DWORD  dwFlags,// 内存分配标志
		SIZE_T dwBytes // 分配大小（字节为单位）
	);
	dwFlags: 
		HEAP_GENERATE_EXCEPTIONS -&gt; 抛出异常
		HEAP_NO_SERIALIZE -&gt; 不连续存储
		HEAP_ZERO_MEMORY -&gt; 将内存块全部清零
	*/</span>
	
	<span class="n">LPTSTR</span> <span class="n">tAlloc</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">HeapAlloc</span><span class="p">(</span><span class="n">hHeapRand</span><span class="p">,</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>
	<span class="cm">/*
	# 在已分配的基础上继续分配
	DECLSPEC_ALLOCATOR LPVOID HeapReAlloc(
	  HANDLE                 hHeap, // 堆句柄
	  DWORD                  dwFlags, // 内存分配标志
	  _Frees_ptr_opt_ LPVOID lpMem, // 分配内存后的位置
	  SIZE_T                 dwBytes // 分配大小（字节为单位）
	);
	*/</span>
	
	<span class="n">HeapReAlloc</span><span class="p">(</span><span class="n">hHeapRand</span><span class="p">,</span> <span class="n">HEAP_ZERO_MEMORY</span><span class="o">|</span> <span class="n">HEAP_REALLOC_IN_PLACE_ONLY</span><span class="p">,</span> <span class="p">(</span><span class="n">LPVOID</span><span class="p">)</span><span class="n">tAlloc</span><span class="p">,</span><span class="mi">24</span><span class="p">);</span>
	<span class="n">lstrcpy</span><span class="p">((</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">tAlloc</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"HEllo"</span><span class="p">));</span>
	<span class="n">DWORD</span> <span class="n">dwHeapSize</span> <span class="o">=</span> <span class="n">HeapSize</span><span class="p">(</span><span class="n">hHeapRand</span><span class="p">,</span> <span class="n">HEAP_NO_SERIALIZE</span><span class="p">,</span> <span class="n">tAlloc</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">"HeapSize : "</span> <span class="o">&lt;&lt;</span> <span class="n">dwHeapSize</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="n">HeapFree</span><span class="p">(</span><span class="n">hHeapRand</span><span class="p">,</span> <span class="n">HEAP_NO_SERIALIZE</span><span class="p">,</span> <span class="n">tAlloc</span><span class="p">);</span>
	<span class="n">HeapDestroy</span><span class="p">(</span><span class="n">hHeapRand</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Success ... </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="0x03-虚拟内存页管理">0x03 虚拟内存页管理</h2>

<h3 id="申请虚拟内存页">申请虚拟内存页</h3>

<p><strong>VirtualAlloc</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LPVOID</span> <span class="n">WINAPI</span> <span class="nf">VirtualAlloc</span><span class="p">(</span>
  <span class="n">_In_opt_</span> <span class="n">LPVOID</span> <span class="n">lpAddress</span><span class="p">,</span> <span class="err">分配内存页面的起始位置</span>
  <span class="n">_In_</span>     <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span>    <span class="err">内存区域大小（</span><span class="n">Byte</span><span class="err">）</span>
  <span class="n">_In_</span>     <span class="n">DWORD</span>  <span class="n">flAllocationType</span><span class="p">,</span> <span class="err">分配类型（</span><span class="n">MEM_COMMIT</span><span class="o">|</span><span class="n">MEM_RESERVED</span><span class="o">|</span><span class="n">MEM_RESET</span><span class="o">|</span><span class="n">MEM_RESET_UNDO</span><span class="err">）</span>
  <span class="n">_In_</span>     <span class="n">DWORD</span>  <span class="n">flProtect</span> <span class="err">内存的保护属性</span> <span class="p">(</span><span class="n">PAGE_NOACCESS</span><span class="o">|</span><span class="n">PAGE_GUARD</span><span class="o">|</span><span class="n">PAGE_NOCACHE</span><span class="o">|</span><span class="n">PAGE_WRITECOMBINE</span><span class="p">)</span>
<span class="p">);</span>
</code></pre></div></div>
<p>进程的虚拟内存页面存在三种状态：</p>

<ul>
  <li>Free（空闲）</li>
  <li>Reserved（保留）</li>
  <li>Committed（提交）</li>
</ul>

<p>Free：进程不能访问这种页面，因为这个页面还没有被分配。任何属于这个页面的虚拟内存地址进行访问都将引用异常。</p>

<p>Reserved：页面被保留以备将来使用，这些页面已被分配，但是没使用，物理地址空间中的内存不存在与其对应的物理内存分页。处于被保留的内存分页也不能被访问。</p>

<p>Committed：内存已经被分配，并且已经被使用，具有与之对应的物理地址空间中的内存分页。</p>

<p>VirtualAlloc可用于指定分配的内存是什么状态，如果当前内存的状态是Committed，则可以直接访问。</p>

<p>VirtualAlloc能够将内存页面的状态从Free、Reserved改为Committed，也可以将Free-&gt;Reserved，Reserved-&gt;Committed。</p>

<h3 id="return-value">Return value</h3>

<p>如果函数成功，则返回值是分配的页面区域的基址。</p>

<p>如果函数失败，则返回值为NULL。</p>

<h3 id="内存的保护属性">内存的保护属性</h3>

<ul>
  <li>PAGE_NOACCESS</li>
  <li>PAGE_GUARD</li>
  <li>PAGE_NOCACHE</li>
  <li>PAGE_WRITECOMBINE</li>
</ul>

<p><strong>&gt;&gt; <a href="https://docs.microsoft.com/zh-cn/windows/desktop/Memory/memory-protection-constants">内存保护常量</a></strong></p>

<h3 id="virtualalloc-example">VirtualAlloc Example</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ConsoleApplication2.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">// 虚拟内存页管理</span>
<span class="cp">#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
</span>
<span class="n">VOID</span> <span class="nf">P</span><span class="p">(</span><span class="kt">wchar_t</span> <span class="o">*</span> <span class="n">contents</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wprintf</span><span class="p">(</span><span class="n">contents</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
	<span class="n">exit</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">()</span>
<span class="p">{</span>

	
	<span class="n">std</span><span class="o">::</span><span class="n">wprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Success ... </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>

	<span class="cm">/*
	LPVOID WINAPI VirtualAlloc(
	  _In_opt_ LPVOID lpAddress, 分配内存页面的起始位置
	  _In_     SIZE_T dwSize,    内存区域大小（Byte）
	  _In_     DWORD  flAllocationType, 分配类型（MEM_COMMIT|MEM_RESERVED|MEM_RESET|MEM_RESET_UNDO）
	  _In_     DWORD  flProtect 内存的保护属性 (PAGE_NOACCESS|PAGE_GUARD|PAGE_NOCACHE|PAGE_WRITECOMBINE)
	);
	*/</span>
	<span class="n">LPTSTR</span> <span class="n">lpVirMem</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">virtualMemSize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="n">MEMORY_BASIC_INFORMATION</span> <span class="n">mbi</span><span class="p">;</span>
	<span class="n">lpVirMem</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPTSTR</span><span class="p">)</span><span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">virtualMemSize</span><span class="p">,</span> <span class="n">MEM_COMMIT</span><span class="p">,</span> <span class="n">PAGE_READWRITE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lpVirMem</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">P</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Alloc Error ! </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">VirtualQuery</span><span class="p">(</span><span class="n">lpVirMem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mbi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mbi</span><span class="p">));</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">"Virtual BaseAddress :"</span> <span class="o">&lt;&lt;</span> <span class="n">mbi</span><span class="p">.</span><span class="n">BaseAddress</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span>
		<span class="s">"AllocationBase :"</span> <span class="o">&lt;&lt;</span> <span class="n">mbi</span><span class="p">.</span><span class="n">AllocationBase</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span> <span class="o">&lt;&lt;</span>
		<span class="s">"AllocationProtect :"</span> <span class="o">&lt;&lt;</span> <span class="n">mbi</span><span class="p">.</span><span class="n">AllocationProtect</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">lpVirMem</span><span class="p">,</span> <span class="n">virtualMemSize</span><span class="p">);</span>
	<span class="n">CopyMemory</span><span class="p">(</span><span class="n">lpVirMem</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Hello World !!!"</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Hello World !!!"</span><span class="p">)));</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">lpVirMem</span> <span class="o">&lt;&lt;</span> <span class="s">" | "</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lpVirMem</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="c1">// ********************************************************************</span>
	<span class="n">VirtualFree</span><span class="p">(</span><span class="n">lpVirMem</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">MEM_RELEASE</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*
Out:
Success ...
Virtual BaseAddress :00310000
AllocationBase :00310000
AllocationProtect :4
Hello World !!! | 4
*/</span>
</code></pre></div></div>

<h2 id="0x04-各种内存分配方式的关系">0x04 各种内存分配方式的关系</h2>

<blockquote>
  <p>内容来源：https://www.cnblogs.com/arsense/p/6505690.html</p>
</blockquote>

<h3 id="各自的定义和理解">各自的定义和理解</h3>

<ul>
  <li>GlobalAlloc()</li>
</ul>

<p>GlobalAlloc()主要用于Win32应用程序实现从全局堆中分配出内存供2017-03-05程序使用，是16位WINDOWS程序使用的API，对应于系统的全局栈，返回一个内存句柄，在实际需要使用时，用GlobalLock()来实际得到内存 区。但32位WINDOWS系统中全局栈和局部堆的区别已经不存在了，因此不推荐在Win32中使用该函数，应使用新的内存分配函数HeapAlloc()以得到更好的支持，GlobalAlloc()还可以用，主要是为了 兼容。</p>

<p>一般情况下我们在编程的时候，给应用程序分配的内存都是可以移动的或者是可以丢弃的，这样能使有限的内存资源充分利用，所以，在某一个时候我们分配的那块 内存的地址是不确定的，因为他是可以移动的，所以得先锁定那块内存块，这儿应用程序需要调用API函数GlobalLock函数来锁定句柄。如下： lpMem=GlobalLock(hMem); 这样应用程序才能存取这块内存。所以我们在使用GlobalAllock时，通常搭配使用GlobalLock，当然在不使用内存时，一定记得使用 GlobalUnlock，否则被锁定的内存块一直不能被其他变量使用。</p>

<p>GlobalAlloc对应的释放空间的函数为GlobalFree。</p>

<ul>
  <li>HeapAlloc()</li>
</ul>

<p>HeapALloc是从堆上分配一块内存，且分配的内存是不可移动的（即如果没有连续的空间能满足分配的大小，程序不能将其他零散的 空间利用起来，从而导致分配失败），该分配方法是从一指定地址开始分配，而不像GloabalAlloc是从全局堆上分配，这个有可能是全局，也有可能是局部。</p>

<ul>
  <li>malloc()</li>
</ul>

<p>是C运行库中的动态内存分配函数，主要用于ANSI C程序中，是标准库函数。WINDOWS程序基本不再使用这种方法进行内存操作，因为它比WINDOWS内存分配函数少了一些特性，如：整理内存。</p>

<ul>
  <li>new</li>
</ul>

<p>标准C++一般使用new语句分配动态的内存空间，需要申请数组时，可以直接使用new int[3]这样的方式，释放该方法申请的内存空间使用对应的delete语句，需要释放的内存空间为一个数组，则使用delete [] ary;这样的方式。</p>

<p>要访问new所开辟的结构体空间,无法直接通过变量名进行,只能通过赋值的指针进行访问.</p>

<p>new在内部调用malloc来分配内存，delete在内部调用free来释放内存。</p>

<ul>
  <li>VirtualAlloc</li>
</ul>

<p>下面是网友的解释 但我个人的理解这个才是内存申请的鼻祖，所有的内存的申请都感觉默认调用了它。</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">PVOID</span> <span class="n">VirtualAlloc</span><span class="p">(</span>
    <span class="n">PVOID</span> <span class="n">pvAddress</span><span class="p">,</span> 
    <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span> 
    <span class="n">DWORD</span> <span class="n">fdwAllocationType</span><span class="p">,</span> 
    <span class="n">DWORD</span> <span class="n">fdwProtect</span><span class="p">)</span>
</code></pre></div></div>

<p>VirtualAlloc是Windows提供的API，通常用来分配大块的内存。例如如果想在进程A和进程B之间通过共享内存的方式实现通信，可以使用该函数（这也是较常用的情况）。不要用该函数实现通常情况的内存分配。该函数的一个重要特性是可以预定指定地址和大小的虚拟内存空间。例如，希望在进程的地址空间中第50MB的地方分配内存，那么将参数 50*1024*`1024 = 52428800 传递给pvAddress，将需要的内存大小传递给dwSize。如果系统有足够大的闲置区域能满足请求，则系统会将该块区域预订下来并返回预订内存的基地址，否则返回NULL。</p>

<p>使用VirtualAlloc分配的内存需要使用VirtualFree来释放。</p>

<h3 id="区别与联系">区别与联系</h3>

<p>它们之间的区别主要有以下几点：</p>

<p>1、GlobalAlloc()函数在程序的堆中分配一定的内存，是Win16的函数，对应于系统的全局栈，而在Win32中全局栈和局部堆的区别已经不存在了，因此不推荐在Win32中使用该函数。</p>

<p>2、malloc()是标准库函数，而new则是运算符，它们都可以用于申请动态内存。</p>

<p>3、new()实际上调用的是malloc()函数。</p>

<p>4、new运算符除了分配内存，还可以调用构造函数，但是malloc()函数只负责分配内存。</p>

<p>5、对于非内部数据类型的对象而言，只使用malloc()函数将无法满足动态对象的要求，因为malloc()函数不能完成执行构造函数的任务。</p>

<p>6、malloc(); 和 HeapAlloc(); 都是从堆中分配相应的内存，不同的是一个是c run time的函数，一个是windows系统的函数， 对于windows程序来说，使用HeapAlloc();会比malloc();效率稍稍高一些。</p>

<h3 id="关于内存的初始化和使用">关于内存的初始化和使用</h3>

<p><strong>内存分配方式</strong></p>

<p>内存分配方式有三种：</p>

<p>1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。例如全局变量，static变量。</p>

<p>（2）在栈上创建。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存</p>

<p>储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p>

<p>（3） 从堆上分配，亦称动态内存分配。程序在运行的时候用malloc或new申请任意多少的内存，程序员自己负责在何时用free或delete释放内存。动态内存的生存期由我们决定，使用非常灵活，但问题也最多。</p>

<p><strong>内存使用错误</strong></p>

<p>发生内存错误是件非常麻烦的事情。编译器不能自动发现这些错误，通常是在程序运行时才能捕捉到。</p>

<p>而这些错误大多没有明显的症状，时隐时现，增加了改错的难度。有时用户怒气冲冲地把你找来，程序却没有</p>

<p>发生任何问题，你一走，错误又发作了。 常见的内存错误及其对策如下：</p>

<ul>
  <li>内存分配未成功，却使用了它。</li>
</ul>

<p>　　编程新手常犯这种错误，因为他们没有意识到内存分配会不成功。常用解决办法是，在使用内存之前检查指针是否为NULL。如果是用malloc或new来申请内存，应该用if(p==NULL) 或if(p!=NULL)进行防错处理。</p>

<ul>
  <li>内存分配虽然成功，但是尚未初始化就引用它。</li>
</ul>

<p>　　犯这种错误主要有两个起因：一是没有初始化的观念；二是误以为内存的缺省初值全为零，导致引用初值</p>

<p>错误（例如数组）。 内存的缺省初值究竟是什么并没有统一的标准，尽管有些时候为零值，我们宁可信其无不</p>

<p>可信其有。所以无论用何种方式创建数组，都别忘了赋初值，即便是赋零值也不可省略，不要嫌麻烦。</p>

<ul>
  <li>内存分配成功并且已经初始化，但操作越过了内存的边界。</li>
</ul>

<p>　　例如在使用数组时经常发生下标“多1”或者“少1”的操作。特别是在for循环语句中，循环次数很容易搞</p>

<p>错，导致数组操作越界。</p>

<ul>
  <li>忘记了释放内存，造成内存泄露。</li>
</ul>

<p>　　含有这种错误的函数每被调用一次就丢失一块内存。刚开始时系统的内存充足，你看不到错误。终有一次程序突然死掉，系统出现提示：内存耗尽。</p>

<p>　　动态内存的申请与释放必须配对，程序中malloc与free的使用次数一定要相同，否则肯定有错误</p>

<p>（new/delete同理）。</p>

<ul>
  <li>释放了内存却继续使用它。</li>
</ul>

<p>　
有三种情况：</p>

<p>　　（1）程序中的对象调用关系过于复杂，实在难以搞清楚某个对象究竟是否已经释放了内存，此时应该重新</p>

<p>设计数据结构，从根本上解决对象管理的混乱局面。</p>

<p>　　（2）函数的return语句写错了，注意不要返回指向“栈内存”的“指针”或者“引用”，因为该内存在函</p>

<p>数体结束时被自动销毁。</p>

<p>　　（3）使用free或delete释放了内存后，没有将指针设置为NULL。导致产生“野指针”。</p>

<hr>

<p>　　【规则1】用malloc或new申请内存之后，应该立即检查指针值是否为NULL。防止使用指针值为NULL的内存</p>

<p>　　【规则2】不要忘记为数组和动态内存赋初值。防止将未被初始化的内存作为右值使用。</p>

<p>　　【规则3】避免数组或指针的下标越界，特别要当心发生“多1”或者“少1”操作。</p>

<p>　　【规则4】动态内存的申请与释放必须配对，防止内存泄漏。</p>

<p>　　【规则5】用free或delete释放了内存之后，立即将指针设置为NULL，防止产生“野指针”。</p>

--&gt;
          Windows - Heap、Virtual
          <p>
            <a class="post-link" href="/archivers/2018-12-21/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2018-12-20/1">最近学习Windows编程总结</a>
        </h2>
        
        <div class="post-meta">Dec 20, 2018</div>

        <div class="post-excerpt">
          TEXT”宏与PTSTR类型的字符串指针。

<h2 id="0x01-windows进程创建">0x01 Windows进程创建</h2>

<p>进程是一个程序正在运行的一个实例，它由一个内核对象和一个地址空间组成。</p>

<p>内核对象与地址空间都在4GB的虚拟内存中，内核占2GB高地址，低地址的2GB给程序的堆栈使用。</p>

<p>在Windows中，系统通过句柄管理进程中的资源，句柄存储在内核空间中的一个全局句柄表中，而每个进程也都有一个句柄表，这个句柄表是私有的。</p>

<p><strong>PID</strong> 是指的是全局句柄表的值。</p>

<h3 id="进程执行的加载过程">进程执行的加载过程</h3>

<ul>
  <li>1.映射EXE</li>
  <li>2.创建内核对象EPROCESS</li>
  <li>3.映射系统DLL（ntdll.dll）</li>
  <li>4.创建线程内核对象ETHREAD</li>
  <li>5.系统启动线程、映射DLL（ntdll.LdrInitalizeThunk）、线程开始执行</li>
</ul>

<h3 id="创建进程">创建进程</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">CreateProcess</span>
<span class="p">(</span>
<span class="n">LPCTSTR</span> <span class="n">lpApplicationName</span><span class="p">,</span>
<span class="n">LPTSTR</span> <span class="n">lpCommandLine</span><span class="p">,</span>
<span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpProcessAttributes</span><span class="p">,</span>
<span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpThreadAttributes</span><span class="p">,</span>
<span class="n">BOOL</span> <span class="n">bInheritHandles</span><span class="p">,</span>
<span class="n">DWORD</span> <span class="n">dwCreationFlags</span><span class="p">,</span>
<span class="n">LPVOID</span> <span class="n">lpEnvironment</span><span class="p">,</span>
<span class="n">LPCTSTR</span> <span class="n">lpCurrentDirectory</span><span class="p">,</span>
<span class="n">LPSTARTUPINFO</span> <span class="n">lpStartupInfo</span><span class="p">,</span>
<span class="n">LPPROCESS_INFORMATIONlpProcessInformation</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="线程与进程的关系">线程与进程的关系</h3>

<p>进程是一个程序正在运行的一个实例，它提供了一块存储代码的空间，在进程被创建时，系统也会给进程创建一个主线程（primary thread），主线程负责执行代码，一个进程没有线程是无法运行的。</p>

<p>一个进程可以拥有多个线程，但是永远是先拥有主线程，通过主线程创建其他线程。</p>

<p>每个进程都至少有一个线程负责运行代码，否则进程将进入睡眠状态，或被系统销毁。</p>

<p>当主线程运行完毕，进程也将会被销毁。</p>

<p>句柄表：由操作系统内核维护的一个二维表格。</p>

<p>使用句柄值（HANDLE）对应内核对象，每个进程内的句柄都是不一样的，但都存在于全局句柄表。</p>

<p>全局句柄表中的句柄ID就是操作系统的进程列表中的PID。</p>

<p>一个进程在运行后，通过线程执行，一个进程必须拥有一个线程</p>

<h3 id="线程操作函数">线程操作函数</h3>

<ul>
  <li>暂停线程：SuspendThread(hThread)</li>
  <li>恢复线程：ResumeThread(hThread)</li>
</ul>

<p><strong>ResumeThread函数</strong></p>

<p>在暂停状态中创建一个线程，就能够在线程有机会执行任何代码之前改变线程的运行环境（如优先级）。</p>

<p>一旦改变了线程的环境，必须使线程成为可调度线程。要进行这项操作，可以调用ResumeThread，将调用CreateThread函数时返回的线程句柄传递给它（或者是将传递给CreateProcess的ppiProcInfo参数指向的线程句柄传递给它）：如果ResumeThread函数运行成功，它将返回线程的前一个暂停计数，否则返回0xFFFFFFFF。</p>

<p>单个线程可以暂停若干次。如果一个线程暂停了3次，它必须恢复3次，然后它才可以被分配给一个CPU。</p>

<p><strong>SuspendThread函数</strong></p>

<p>当创建线程时，除了使用 CRETE_SUSPENDED也可以调用SuspendThread函数来暂停线程的运行：任何线程都可以调用该函数来暂停另一个线程的运行（只要拥有线程的句柄）。线程可以自行暂停运行，但是不能自行恢复运行。</p>

<p>与ResumeThread一样SuspendThread返回的是线程的前一个暂停计数。线程暂停的最多次数可以是MAXIMUM_SUSPEND_COUNT次（在WinNT. h中定义为127）。</p>

<p>注意，SuspendThread与内核方式的执行是异步进行的，但是在线程恢复运行之前，不会发生用户方式的执行。</p>

<p>在实际环境中，调用SuspendThread时必须小心，因为不知道暂停线程运行时它在进行什么操作。如果线程试图从堆栈中分配内存，那么该线程将在该堆栈上设置一个锁。当其他线程试图访问该堆栈时，这些线程的访问就被停止，直到第一个线程恢复运行。</p>

<h2 id="0x02-windows-文件操作">0x02 Windows 文件操作</h2>

<ul>
  <li>ZeroMemory(des,size)</li>
  <li>GetLogicalDriveStringA(length,buffer)</li>
  <li>FindFirstVolumeA(buffer,length) =&gt; return hVolume</li>
  <li>FindNextVolumeA(hVolume,buffer,length)</li>
  <li>FindVolumeClose(hVolume)</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">//</span>

<span class="cp">#include "stdafx.h"
#include &lt;Windows.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">CHAR</span> <span class="n">drives</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">devLen</span> <span class="o">=</span> <span class="n">GetLogicalDriveStringsA</span><span class="p">(</span><span class="mi">254</span><span class="p">,</span> <span class="n">drives</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drives</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">TCHAR</span> <span class="n">s</span> <span class="o">=</span> <span class="n">drives</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drives</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
	<span class="n">HANDLE</span> <span class="n">hVolume</span> <span class="o">=</span> <span class="n">FindFirstVolumeA</span><span class="p">(</span><span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hVolume</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">FindNextVolumeA</span><span class="p">(</span><span class="n">hVolume</span><span class="p">,</span> <span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Volume : %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">drives</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">FindVolumeClose</span><span class="p">(</span><span class="n">hVolume</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// ss</span>

<span class="p">}</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">UINT</span> <span class="nf">GetDriveTypeA</span><span class="p">(</span>
  <span class="n">LPCSTR</span> <span class="n">lpRootPathName</span>
<span class="p">);</span>
</code></pre></div></div>

<p>lpRootPathName : 驱动器的根目录。</p>

<p>需要一个尾随反斜杠。如果此参数为NULL，则该函数使用当前目录的根。
Return Value :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>DRIVE_UNKNOWN -&gt; 0 无法确定驱动器类型。
DRIVE_NO_ROOT_DIR -&gt;1 根路径无效; 例如，指定路径上没有安装卷。
DRIVE_REMOVABLE -&gt; 2 驱动器有可移动介质; 例如，软盘驱动器，拇指驱动器或闪存卡读卡器。
DRIVE_FIXED -&gt; 3 驱动器有固定的媒体; 例如，硬盘驱动器或闪存驱动器。
DRIVE_REMOTE -&gt; 4 该驱动器是远程（网络）驱动器。
DRIVE_CDROM -&gt; 5 该驱动器是CD-ROM驱动器。
DRIVE_RAMDISK -&gt; 6 驱动器是RAM磁盘。
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">GetVolumeInformation</span><span class="p">(</span>
  <span class="n">lpRootPathName</span><span class="o">:</span> <span class="n">PChar</span><span class="p">;</span>               <span class="p">{</span><span class="err">磁盘驱动器代码字符串</span><span class="p">}</span>
  <span class="n">lpVolumeNameBuffer</span><span class="o">:</span> <span class="n">PChar</span><span class="p">;</span>           <span class="p">{</span><span class="err">磁盘驱动器卷标名称</span><span class="p">}</span>
  <span class="n">nVolumeNameSize</span><span class="o">:</span> <span class="n">DWORD</span><span class="p">;</span>              <span class="p">{</span><span class="err">磁盘驱动器卷标名称长度</span><span class="p">}</span>
  <span class="n">lpVolumeSerialNumber</span><span class="o">:</span> <span class="n">PDWORD</span><span class="p">;</span>        <span class="p">{</span><span class="err">磁盘驱动器卷标序列号</span><span class="p">}</span>
  <span class="n">var</span> <span class="n">lpMaximumComponentLength</span><span class="o">:</span> <span class="n">DWORD</span><span class="p">;</span> <span class="p">{</span><span class="err">系统允许的最大文件名长度</span><span class="p">}</span>
  <span class="n">var</span> <span class="n">lpFileSystemFlags</span><span class="o">:</span> <span class="n">DWORD</span><span class="p">;</span>        <span class="p">{</span><span class="err">文件系统标识</span><span class="p">}</span>
  <span class="n">lpFileSystemNameBuffer</span><span class="o">:</span> <span class="n">PChar</span><span class="p">;</span>       <span class="p">{</span><span class="err">文件操作系统名称</span><span class="p">}</span>
  <span class="n">nFileSystemNameSize</span><span class="o">:</span> <span class="n">DWORD</span>           <span class="p">{</span><span class="err">文件操作系统名称长度</span><span class="p">}</span>
<span class="p">)</span><span class="o">:</span> <span class="n">BOOL</span><span class="p">;</span>

<span class="c1">// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">//</span>

<span class="cp">#include "stdafx.h"
#include &lt;Windows.h&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">CHAR</span> <span class="n">drives</span><span class="p">[</span><span class="mi">255</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
	<span class="n">DWORD</span> <span class="n">devLen</span> <span class="o">=</span> <span class="n">GetLogicalDriveStringsA</span><span class="p">(</span><span class="mi">254</span><span class="p">,</span> <span class="n">drives</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">drives</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">TCHAR</span> <span class="n">s</span> <span class="o">=</span> <span class="n">drives</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="sc">'\0'</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%c</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">drives</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
	<span class="n">HANDLE</span> <span class="n">hVolume</span> <span class="o">=</span> <span class="n">FindFirstVolumeA</span><span class="p">(</span><span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">INVALID_HANDLE_VALUE</span> <span class="o">==</span> <span class="n">hVolume</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">FindNextVolumeA</span><span class="p">(</span><span class="n">hVolume</span><span class="p">,</span> <span class="n">drives</span><span class="p">,</span> <span class="mi">255</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"Volume : %s </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">drives</span><span class="p">);</span>
		<span class="n">DWORD</span> <span class="n">dwVolumeSerNumber</span><span class="p">;</span>
		<span class="n">CHAR</span> <span class="n">lpRootPathName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
		<span class="n">CHAR</span> <span class="n">lpVolumName</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
		<span class="n">CHAR</span> <span class="n">szFileSystemNameBuffer</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
		<span class="n">DWORD</span> <span class="n">dwMaxLength</span><span class="p">;</span>
		<span class="n">DWORD</span> <span class="n">dwFileSystemFlags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GetVolumeInformationA</span><span class="p">(</span>
			<span class="n">drives</span><span class="p">,</span>
			<span class="n">lpVolumName</span><span class="p">,</span>
			<span class="n">MAX_PATH</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">dwVolumeSerNumber</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">dwMaxLength</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">dwFileSystemFlags</span><span class="p">,</span>
			<span class="n">szFileSystemNameBuffer</span><span class="p">,</span>
			<span class="n">MAX_PATH</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">lpVolumName</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">FindVolumeClose</span><span class="p">(</span><span class="n">hVolume</span><span class="p">);</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


</code></pre></div></div>

<h3 id="读写文件">读写文件</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateFile</span><span class="p">(</span>
<span class="n">_In_</span> <span class="n">LPCTSTR</span> <span class="n">lpFileName</span><span class="p">,</span>
<span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwDesiredAccess</span><span class="p">,</span>
<span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwShareMode</span><span class="p">,</span>
<span class="n">_In_opt_</span> <span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpSecurityAttributes</span><span class="p">,</span>
<span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwCreationDisposition</span><span class="p">,</span>
<span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwFlagsAndAttributes</span><span class="p">,</span>
<span class="n">_In_opt_</span> <span class="n">HANDLE</span> <span class="n">hTemplateFile</span>
<span class="p">);</span>
</code></pre></div></div>

<h3 id="函数声明">函数声明</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="nf">CreateFile</span><span class="p">(</span><span class="n">LPCTSTR</span> <span class="n">lpFileName</span><span class="p">,</span> <span class="c1">//普通文件名或者设备文件名</span>
<span class="n">DWORD</span> <span class="n">dwDesiredAccess</span><span class="p">,</span> <span class="c1">//访问模式（写/读）</span>
<span class="n">DWORD</span> <span class="n">dwShareMode</span><span class="p">,</span> <span class="c1">//共享模式</span>
<span class="n">LPSECURITY_ATTRIBUTES</span> <span class="n">lpSecurityAttributes</span><span class="p">,</span> <span class="c1">//指向安全属性的指针</span>
<span class="n">DWORD</span> <span class="n">dwCreationDisposition</span><span class="p">,</span> <span class="c1">//如何创建</span>
<span class="n">DWORD</span> <span class="n">dwFlagsAndAttributes</span><span class="p">,</span> <span class="c1">//文件属性</span>
<span class="n">HANDLE</span> <span class="n">hTemplateFile</span> <span class="c1">//用于复制文件句柄</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ConsoleApplication1.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">//</span>

<span class="cp">#include "stdafx.h"
#include &lt;Windows.h&gt;
#include &lt;iostream&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">LPTSTR</span> <span class="n">FileName</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"c:</span><span class="se">\\</span><span class="s">Temp</span><span class="se">\\</span><span class="s">1.txt"</span><span class="p">);</span>
	<span class="cm">/*
	
	if (DeleteFile(FileName)) {
		MessageBox(0, L"删除成功！", L"INFO", MB_OK);
	}
	else {
		DWORD err = GetLastError();
		MessageBox(0, L"Error", L"INFO", MB_HELP);
	}
	*/</span>
	<span class="cm">/*
	if (CopyFile(FileName, TEXT("C:\\Temp\\2.txt"),TRUE)) {
		MessageBox(0, L"COPY成功！", L"INFO", MB_OK);
	}
	if (MoveFile(FileName, TEXT("C:\\Temp\\3.txt"))) {
		MessageBox(0, L"MOVE成功！", L"INFO", MB_OK);
	}
	*/</span>
	<span class="n">HANDLE</span> <span class="n">hFile</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Temp</span><span class="se">\\</span><span class="s">1.txt"</span><span class="p">),</span><span class="n">GENERIC_READ</span><span class="o">|</span><span class="n">GENERIC_WRITE</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">OPEN_ALWAYS</span><span class="p">,</span><span class="n">FILE_ATTRIBUTE_NORMAL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">hFile</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">MessageBox</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">L"Error"</span><span class="p">,</span> <span class="s">L"INFO"</span><span class="p">,</span> <span class="n">MB_HELP</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">CHAR</span> <span class="n">Text</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span>
		<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">Text</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">);</span>
		<span class="n">DWORD</span> <span class="n">ReadLen</span><span class="p">;</span>
		<span class="n">ReadFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="n">Text</span><span class="p">,</span> <span class="n">MAX_PATH</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ReadLen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Length : "</span> <span class="o">&lt;&lt;</span> <span class="n">ReadLen</span> <span class="o">&lt;&lt;</span> <span class="s">" Content :"</span> <span class="o">&lt;&lt;</span> <span class="n">Text</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

		<span class="n">DWORD</span> <span class="n">WriteLen</span><span class="p">;</span>
		<span class="n">CHAR</span> <span class="n">content</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Hello world !!!"</span><span class="p">;</span>
		<span class="n">WriteFile</span><span class="p">(</span><span class="n">hFile</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">content</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">WriteLen</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hFile</span><span class="p">);</span>
	
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="0x03-windows-线程">0x03 Windows 线程</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">WINAPI</span> <span class="nf">CreateThread</span><span class="p">(</span>
      <span class="n">_In_opt_</span>  <span class="n">LPSECURITY_ATTRIBUTES</span>  <span class="n">lpThreadAttributes</span><span class="p">,</span>   
      <span class="n">_In_</span>      <span class="n">SIZE_T</span>                 <span class="n">dwStackSize</span><span class="p">,</span>
      <span class="n">_In_</span>      <span class="n">LPTHREAD_START_ROUTINE</span> <span class="n">lpStartAddress</span><span class="p">,</span>
      <span class="n">_In_opt_</span>  <span class="n">LPVOID</span>                 <span class="n">lpParameter</span><span class="p">,</span>
      <span class="n">_In_</span>      <span class="n">DWORD</span>                  <span class="n">dwCreationFlags</span><span class="p">,</span>
      <span class="n">_Out_opt_</span> <span class="n">LPDWORD</span>                <span class="n">lpThreadId</span>
    <span class="p">);</span>
</code></pre></div></div>

<p>第一个参数 lpThreadAttributes 表示线程内核对象的安全属性，一般传入NULL表示使用默认设置。</p>

<p>第二个参数 dwStackSize 表示线程栈空间大小。传入0表示使用默认大小（1MB）。</p>

<p>第三个参数 lpStartAddress 表示新线程所执行的线程函数地址，多个线程可以使用同一个函数地址。</p>

<p>第四个参数 lpParameter 是传给线程函数的参数。</p>

<p>第五个参数 dwCreationFlags 指定额外的标志来控制线程的创建，为0表示线程创建之后立即就可以进行调度，如果为CREATE_SUSPENDED则表示线程创建后暂停运行，这样它就无法调度，直到调用ResumeThread()。</p>

<p>第六个参数 lpThreadId 将返回线程的ID号，传入NULL表示不需要返回该线程ID号。</p>

<ul>
  <li>SuspendThread(HANDLE Thread); // 阻塞线程</li>
  <li>ResumeThread(HANDLE Thread); // 启动线程</li>
</ul>

<p>线程可多次阻塞</p>

<h3 id="等待线程执行完毕">等待线程执行完毕</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WaitForSingleObject</span><span class="p">(</span>
    <span class="n">_In_</span> <span class="n">HANDLE</span> <span class="n">hHandle</span><span class="p">,</span>
    <span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwMilliseconds</span> <span class="c1">//等待时间 如果为INFINITE 则一直等待</span>
    <span class="p">);</span>
</code></pre></div></div>

<h3 id="等待多个线程执行完毕">等待多个线程执行完毕</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WaitForMultipleObjects</span><span class="p">(</span>
    <span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">nCount</span><span class="p">,</span>
    <span class="n">_In_reads_</span><span class="p">(</span><span class="n">nCount</span><span class="p">)</span> <span class="n">CONST</span> <span class="n">HANDLE</span> <span class="o">*</span><span class="n">lpHandles</span><span class="p">,</span>
    <span class="n">_In_</span> <span class="n">BOOL</span> <span class="n">bWaitAll</span><span class="p">,</span>
    <span class="n">_In_</span> <span class="n">DWORD</span> <span class="n">dwMilliseconds</span>
    <span class="p">);</span>
<span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>
<span class="n">GetExitCodeThread</span><span class="p">(</span>
    <span class="n">_In_</span> <span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">,</span>
    <span class="n">_Out_</span> <span class="n">LPDWORD</span> <span class="n">lpExitCode</span>
    <span class="p">);</span>
<span class="n">GetExitCodeThread</span><span class="p">(</span><span class="n">hThread</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">ExitThreadCode</span><span class="p">);</span>
</code></pre></div></div>
--&gt;
          <!---->
          总结一下最近学习Windows编程的知识点。
          <p>
            <a class="post-link" href="/archivers/2018-12-20/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2018-12-20/Windows-CriticalSection">Windows - 线程同步</a>
        </h2>
        
        <div class="post-meta">Dec 20, 2018</div>

        <div class="post-excerpt">
          多线程执行时，可以互不干扰的运行，但是全局变量保存在全局区，当多个线程读写全局变量时，由于读写操作不是原子的，会发生程序错乱。

<h3 id="为什么不是原子">为什么不是原子？</h3>

<p>当自增、自减时，需要两行汇编指令，而CPU线程调度的最小单位是一行汇编指令，所以当某个值自增时，操作就不是原子的。</p>

<p>为了保证多线程读写全局变量达到同步，可以使用临界区技术，Windows正是实现了这个技术，提供了对应的API。</p>

<h2 id="0x01-令牌线程同步">0x01 令牌线程同步</h2>

<p>代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ConsoleApplication2.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">//</span>
<span class="cp">#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
</span>
<span class="n">DWORD</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="n">CRITICAL_SECTION</span> <span class="n">cs</span><span class="p">;</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">ThreadPro1</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread num :"</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="s">" Thread ID :"</span> <span class="o">&lt;&lt;</span> <span class="n">GetCurrentThreadId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="n">num</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="n">WINAPI</span> <span class="nf">ThreadPro2</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">EnterCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">"Thread num :"</span> <span class="o">&lt;&lt;</span> <span class="n">num</span> <span class="o">&lt;&lt;</span> <span class="s">" Thread ID :"</span> <span class="o">&lt;&lt;</span> <span class="n">GetCurrentThreadId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="n">num</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">LeaveCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">InitializeCriticalSection</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cs</span><span class="p">);</span>
	<span class="n">hThread</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span> <span class="n">ThreadPro1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">hThread</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">PTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">ThreadPro2</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">WaitForMultipleObjects</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">hThread</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">,</span><span class="n">INFINITE</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Success ... </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>

<h2 id="0x02-令牌api">0x02 令牌API</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CRITICAL_SECTION cs; // 创建临界区变量
InitializeCriticalSection(CRITICAL_SECTION *); // 初始化临界区变量
EnterCriticalSection(CRITICAL_SECTION *);//获取临界区变量
LeaveCriticalSection(CRITICAL_SECTION *);//离开临界区
</code></pre></div></div>

<h2 id="0x03-互斥体">0x03 互斥体</h2>

<p>CRITICAL_SECTION是在进程的虚拟内存空间的一种锁，互斥体（Mutex）是用于内核级资源（内核空间）的线程同步锁，如：跨进程间的读写内核级资源。</p>

<h3 id="创建互斥体">创建互斥体</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="n">hMutex</span> <span class="o">=</span> <span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
<span class="cm">/*
	if (GetLastError() == ERROR_ALREADY_EXISTS) {
		std::wcout &lt;&lt; "Allready exists Mutex ..." &lt;&lt; std::endl;
		system("pause");
		return 0;
	}
*/</span>    
</code></pre></div></div>
<p>函数原型：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HANDLE WINAPI CreateMutex(
  _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,
  _In_     BOOL                  bInitialOwner,
  _In_opt_ LPCTSTR               lpName
);
</code></pre></div></div>
<ul>
  <li>lpMutexAttributes 安全描述符</li>
  <li>bInitialOwner 如果为TRUE则只对当前进程的内存空间有效，如果为FALSE，则对内核空间有效（系统全局）。</li>
  <li>lpName 内核对象名称</li>
</ul>

<p><strong>多个进程要使用同一个互斥体时，内核对象的名称必须相同。</strong></p>

<p>当互斥体已经被创建时，在其他进程中或在当前进程中调用<code class="language-plaintext highlighter-rouge">CreateMutex</code>，使用<code class="language-plaintext highlighter-rouge">GetLastError</code>可以捕获到<code class="language-plaintext highlighter-rouge">ERROR_ALREADY_EXISTS</code>常量。通过判断<code class="language-plaintext highlighter-rouge">ERROR_ALREADY_EXISTS</code>就可以知道当前进程有没有另外一个相同的进程了。</p>

<p>源代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// ConsoleApplication2.cpp : 定义控制台应用程序的入口点。</span>
<span class="c1">//</span>
<span class="cp">#include "stdafx.h"
#include &lt;iostream&gt;
#include &lt;Windows.h&gt;
</span>
<span class="kt">int</span> <span class="nf">_tmain</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">HANDLE</span> <span class="n">hMutex</span> <span class="o">=</span> <span class="n">CreateMutex</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"hello"</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GetLastError</span><span class="p">()</span> <span class="o">==</span> <span class="n">ERROR_ALREADY_EXISTS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="s">"Allready exists Mutex ..."</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
		<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hMutex</span><span class="p">,</span> <span class="n">INFINITE</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">INT</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">Sleep</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">GetCurrentProcessId</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">":"</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ReleaseMutex</span><span class="p">(</span><span class="n">hMutex</span><span class="p">);</span>
	<span class="n">std</span><span class="o">::</span><span class="n">wprintf</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Success ... </span><span class="se">\n</span><span class="s">"</span><span class="p">));</span>
	<span class="n">system</span><span class="p">(</span><span class="s">"pause"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
--&gt;
          使用临界区保证多个线程读写全局变量进行同步。
          <p>
            <a class="post-link" href="/archivers/2018-12-20/Windows-CriticalSection">Read More »</a>
          </p>
        </div>
      </li>
    
  </ul>
  
  <!-- Pagination links -->
<div class="pagination">
  
    <a href="/page12" class="previous">PREV</a>
  
  <span class="page_number ">13 of 34</span>
  
    <a href="/page14" class="next">NEXT</a>
  
</div>

</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
