<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Linux透明代理在红队渗透中的应用 « 倾旋的博客</title>
  <meta name="description" content="0x00 前言决定写这篇文章是我解决了所有问题以后决定记录一下这个过程所写的，因此可能会忽略很多细节上的东西。  问题一：打点的时候经常会被WAF封禁IP怎么办？  问题二：内网的时候只想代理部分目的地址怎么办？我想大部分人解决问题一的方案就是不断切换出口IP，使得出口地址一直改变，避免被封，而解决问题二的方案可...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/archivers/2020-11-13/1">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">Linux透明代理在红队渗透中的应用</h1>
    <p class="post-meta">Nov 13, 2020</p>
  </header>

  <article class="post-content">
    <h2 id="0x00-前言">0x00 前言</h2>

<p>决定写这篇文章是我解决了所有问题以后决定记录一下这个过程所写的，因此可能会忽略很多细节上的东西。</p>

<ul>
  <li>问题一：打点的时候经常会被WAF封禁IP怎么办？</li>
  <li>问题二：内网的时候只想代理部分目的地址怎么办？</li>
</ul>

<p>我想大部分人解决问题一的方案就是不断切换出口IP，使得出口地址一直改变，避免被封，而解决问题二的方案可能就是<a href="https://www.proxifier.com/download/">Proxifier</a>或者<a href="https://www.proxycap.com/">Proxycap</a>。</p>

<blockquote>
  <p>Proxifier是一款能够实现系统全局代理的软件，它支持的代理类型有：Http、Https、Socks4a、Socks5.</p>
</blockquote>

<p>在使用Windows渗透的过程中，我经常使用Proxifier来实现进程单位的代理进行内网渗透，利用好rules就能避免系统全局流量被导入代理，流量流入内网从而暴露自己的一些信息。</p>

<p>以上两个问题在Windows下不是问题，我之前经常使用<a href="https://www.kali.org/">Kali Linux</a>来进行渗透，自从更新版本以后，它设置系统代理需要自己写PAC文件，这一点增加了一点点学习门槛，并且好像不是那么好用。最近我使用<a href="https://www.archlinux.org/">Arch Linux</a>已经有段时间了，并且把它安装在了我的工作机、家庭电脑上，我非常喜欢这个操作系统和这个操作系统的生态。</p>

<p>因此我不得不开始完全适应更多在Linux上渗透的场景，这也让我收获颇多，这篇文章就记录一下我如何学习自己搭建透明代理实现愉快的工作环境。</p>

<h2 id="0x01-透明代理">0x01 透明代理</h2>

<h3 id="什么是透明代理">什么是透明代理？</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b47f98ee37958f15c0c025ae09ec14b7.png" alt="2020-11-13-20-03-20"></p>

<p>透明代理的意思是客户端根本不需要知道有代理服务器的存在，它改变你的request fields（报文），并会传送真实IP，多用于路由器的NAT转发中。</p>

<h3 id="为什么要用到透明代理">为什么要用到透明代理？</h3>

<p>因为这样能够让我的机器“身处”在内网中，也能让我的机器在“世界上的任何角落里”。</p>

<p>大家都知道，在Linux下常规的内网渗透需要使用一些如：<a href="https://github.com/haad/proxychains">proxychains</a>的工具实现指定的进程访问内网的资源，相当于给程序套了一层代理。</p>

<p>它的实现原理如下：</p>

<blockquote>
  <p>ProxyChains is a UNIX program, that hooks network-related libc functions in dynamically linked programs via a preloaded DLL and redirects the connections through SOCKS4a/5 or HTTP proxies.</p>
</blockquote>

<p>关于<code class="language-plaintext highlighter-rouge">LD_PRELOAD</code>之前有写过相关文章：<a href="https://payloads.online/archivers/2020-01-01/1">Linux权限维持之LD_PRELOAD</a></p>

<p>它的缺点却是每个命令必须要在前面加上<code class="language-plaintext highlighter-rouge">proxychains</code>，这样<code class="language-plaintext highlighter-rouge">Bash shell</code>有时候可能不会正常工作给我们进行参数提示。</p>

<p>我要做的就是使用<code class="language-plaintext highlighter-rouge">iptables</code>实现透明代理，让我的机器所有与目标地址相关的流量都导入<code class="language-plaintext highlighter-rouge">socks5</code>代理端口。</p>

<p>题外话一，关闭<code class="language-plaintext highlighter-rouge">proxychains</code>的输出信息可以将<code class="language-plaintext highlighter-rouge">/etc/proxychains.conf</code>文件中的<code class="language-plaintext highlighter-rouge">quiet_mode</code>前面的<code class="language-plaintext highlighter-rouge">#</code>去除。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/14871af8d889d4dd6172761753afcec0.png" alt="2020-11-13-20-18-48"></p>

<p>题外话二，设置metasploit全局代理的方法：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b2f402411be57170fde276b589266991.png" alt="2020-11-13-22-15-29"></p>

<p>可以将metasploit全局变量<code class="language-plaintext highlighter-rouge">proxies</code>的值进行设置来使得后续所有的流量都经过代理发出，这样能够达到内网穿透的效果。</p>

<blockquote>
  <p>图中演示了2层代理的设置</p>
</blockquote>

<h2 id="0x02-linux下的iptables防火墙">0x02 Linux下的iptables防火墙</h2>

<p><code class="language-plaintext highlighter-rouge">iptables</code>是一个用户空间实用程序，它允许系统管理员配置Linux内核防火墙的IP数据包过滤器规则，这些规则实现为不同的<code class="language-plaintext highlighter-rouge">Netfilter</code>模块。筛选器组织在不同的表中，这些表包含有关如何处理网络流量数据包的规则链。当前，不同的内核模块和程序用于不同的协议。<code class="language-plaintext highlighter-rouge">iptables</code>适用于IPv4，<code class="language-plaintext highlighter-rouge">ip6tables</code>适用于IPv6，<code class="language-plaintext highlighter-rouge">arptables</code>适用于ARP，而<code class="language-plaintext highlighter-rouge">ebtables</code>适用于以太网帧。</p>

<p>学习<code class="language-plaintext highlighter-rouge">iptables</code>有一点门槛，需要对表、规则链、动作等关系有一定的了解，这里不继续铺垫，可以自行搜索关于<code class="language-plaintext highlighter-rouge">iptables</code>的文章。</p>

<h3 id="流量导入socks代理">流量导入Socks代理</h3>

<p>通过将规则插入到<code class="language-plaintext highlighter-rouge">NAT</code>表的<code class="language-plaintext highlighter-rouge">PREROUTING</code>链中，可以轻松地重定向传入流量。</p>

<p>例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -A PREROUTING -i eth0 -p tcp --dport 80 -j REDIRECT --to-port 8080
</code></pre></div></div>

<blockquote>
  <p>所有访问eth0网卡80端口的流量，都会被重定向到8080端口。</p>
</blockquote>

<p>它不同于端口转发，<code class="language-plaintext highlighter-rouge">REDIRECT</code>的<code class="language-plaintext highlighter-rouge">--dport</code>端口并不会被<code class="language-plaintext highlighter-rouge">iptables</code>进行监听。</p>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a7469746c652069707461626c6573e79a84e6b581e9878fe59ca8e8a784e58899e993bee4b8ade79a84e8b5b0e59091e59bbe0a0a505245524f5554494e47202d3e20494e5055540a494e505554202d3e20504f5354524f5554494e470a504f5354524f5554494e47202d3e204f55545055540a40656e64756d6c"></p>

<h2 id="0x03-实现简单的透明代理">0x03 实现简单的透明代理</h2>

<p><a href="https://github.com/darkk/redsocks">redsocks</a>是一个能够重定向socks代理的一款开源软件，它允许我们在系统上监听一个端口，与远程socks端口进行转换，并且支持socks5认证，这一点非常赞。后来发现还有新的redsocks一些还在维护，但旧版已经足够满足我的需要了，就没有下载。</p>

<h3 id="redsocks安装">redsocks安装</h3>

<p>安装必备库：</p>

<ul>
  <li>ArchLinux ： <code class="language-plaintext highlighter-rouge">yaourt -S --noconfirm redsocks-git</code>
</li>
  <li>Debian : <code class="language-plaintext highlighter-rouge">apt install gcc libevent-dev</code>
</li>
  <li>CentOS : <code class="language-plaintext highlighter-rouge">yum install libevent-devel git gcc</code>
</li>
</ul>

<p>编译代码：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>git clone https://github.com/darkk/redsocks
cd redsocks
make
</code></pre></div></div>

<ol>
  <li>
    <p>安装完毕后，当前目录会生成<code class="language-plaintext highlighter-rouge">redsocks</code>二进制可执行文件，把它拷贝到环境变量目录下即可，例如：<code class="language-plaintext highlighter-rouge">/usr/bin/redsocks</code></p>
  </li>
  <li>
    <p>将配置文件<code class="language-plaintext highlighter-rouge">redsocks.conf</code>拷贝至<code class="language-plaintext highlighter-rouge">/etc/redsocks.conf</code></p>
  </li>
</ol>

<h3 id="配置redsocks代理服务器">配置redsocks代理服务器</h3>

<p>在<code class="language-plaintext highlighter-rouge">/etc/redsocks.conf</code>第61行-62行是设置Socks5服务器IP和端口的：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// `ip' and `port' are IP and tcp-port of proxy-server
// You can also use hostname instead of IP, only one (random)
// address of multihomed host will be used.
ip=***;
port=***;
</code></pre></div></div>

<h3 id="配置redsocks启动身份">配置redsocks启动身份</h3>

<p><img class="plantuml" src="http://www.plantuml.com/plantuml/svg/~h407374617274756d6c0a7469746c6520e695b0e68daee59b9ee78eaf0a0ae6b58fe8a788e599a8202d3e20505245524f5554494e470a505245524f5554494e47202d3e20526564736f636b730a526564736f636b73202d3e20505245524f5554494e470a505245524f5554494e47202d3e20526564736f636b730a2e2e2e0a2e2e2e0a40656e64756d6c"></p>

<p>为了避免启用端口流量重定向后数据发生回环问题，需要用iptables根据UID进行过滤<code class="language-plaintext highlighter-rouge">redsocks</code>的出口流量。</p>

<p>添加<code class="language-plaintext highlighter-rouge">redsocks</code>组与<code class="language-plaintext highlighter-rouge">redsocks</code>用户：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>groupadd redsocks
useradd <span class="nt">-g</span> redsocks redsocks
</code></pre></div></div>
<p>将<code class="language-plaintext highlighter-rouge">/etc/redsocks.conf</code>的启动用户名和用户组进行更改：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>user = redsocks;
group = redsocks;
</code></pre></div></div>

<p>对应的防火墙规则：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables <span class="nt">-t</span> nat <span class="nt">-A</span> OUTPUT <span class="nt">-p</span> tcp <span class="nt">-m</span> owner <span class="o">!</span> <span class="nt">--uid-owner</span> redsocks  <span class="nt">-j</span> REDSOCKS
</code></pre></div></div>

<blockquote>
  <p>这么做是为了把除了redsocks用户产生的流量全部经过REDSOCKS链。</p>
</blockquote>

<h2 id="0x04-打点模式-配置代理链">0x04 打点模式-配置代理链</h2>

<h3 id="创建自定义规则链">创建自定义规则链</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -N REDSOCKS 
# 建立REDSOCKS链
iptables -t nat -A PREROUTING -p tcp -j REDSOCKS 
# 将所有的TCP流量经过REDSOCKS链
iptables -t nat -A REDSOCKS -d &lt;SOCKS_API_SERVER&gt; -j RETURN 
# 放行获取Socks代理的API服务器
iptables -t nat -A REDSOCKS -d 10.0.0.0/8 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 127.0.0.0/8 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 169.254.0.0/16 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 172.16.0.0/12 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -d 192.168.0.0/16 -j RETURN 
# 放行内网地址
iptables -t nat -A REDSOCKS -p tcp -j REDIRECT --to-port 31338 
# 将所有的TCP流量在经过REDSOCKS链后，全部重定向到31338端口。
iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner redsocks  -j REDSOCKS
# 将准备流出的流量除了redsocks产生的以外，全部经过REDSOCKS链
</code></pre></div></div>

<p>建立一个独立的链是为了方便的清空和新建，并且还不会污染内置链的规则。</p>

<blockquote>
  <p>31338是redsocks的默认端口。</p>
</blockquote>

<h3 id="启动redsocks">启动redsocks</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo /usr/bin/redsocks -c /etc/redsocks.conf
</code></pre></div></div>

<blockquote>
  <p>启动redsocks后，进程的所属者会被自动更改为redsocks。</p>
</blockquote>

<p>这时访问公网查看出口IP，会变成Socks5代理服务器的出口IP，实现打点模式的透明代理。</p>

<h2 id="0x05-内网模式-配置代理链">0x05 内网模式-配置代理链</h2>

<p>内网与打点模式不同，主要是实现指定IP地址范围的代理，打点是“放哪些”，内网是“要哪些”。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -N REDSOCKS
iptables -t nat -F REDSOCKS # 清空

iptables -t nat -A PREROUTING -p tcp -j REDSOCKS
iptables -t nat -A REDSOCKS -p tcp -d 10.0.0.0/8 -j REDIRECT --to-port 31338
iptables -t nat -A REDSOCKS -p tcp -d 172.0.0.0/8 -j REDIRECT --to-port 31338
iptables -t nat -A REDSOCKS -p tcp -d 192.168.0.0/16 -j REDIRECT --to-port 31338
iptables -t nat -A OUTPUT -p tcp -m owner ! --uid-owner $redsocks_user  -j REDSOCKS
</code></pre></div></div>

<p>以上防火墙规则是将以下目的地址的流量全部导入redsoks：</p>

<ul>
  <li>10.0.0.0/8</li>
  <li>172.0.0.0/8</li>
  <li>192.168.0.0/16</li>
</ul>

<p>如果要添加专网的地址，可以手动添加：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>iptables -t nat -A REDSOCKS -p tcp -d XXX.XXX.XX.XX/XX -j REDIRECT --to-port 31338
</code></pre></div></div>

<p>启用以上防火墙规则后，我可以不需要使用proxychains，直接可以用nmap探测端口，自定义的工具也能够像在内网一样工作，本机开的虚拟机切换到NAT模式也能够“身处”内网。</p>

<h2 id="0x06-自动化实现">0x06 自动化实现</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nv">redsocks_bin_path</span><span class="o">=</span><span class="s2">"/usr/bin/redsocks"</span>
<span class="nv">redsocks_config_file_path</span><span class="o">=</span><span class="s2">"/etc/redsocks.conf"</span>
<span class="nv">socks_api_url</span><span class="o">=</span><span class="s1">'*****'</span>
<span class="nv">shell_log_path</span><span class="o">=</span><span class="s2">"/tmp/socks-switch.log"</span>
<span class="c"># ssh port</span>
<span class="nv">ssh_port</span><span class="o">=</span><span class="s2">"22"</span>
<span class="nv">redsocks_user</span><span class="o">=</span><span class="s2">"redsocks"</span>

socks_loging<span class="o">(){</span>
    <span class="nv">current_time</span><span class="o">=</span><span class="si">$(</span><span class="nb">date</span> +<span class="s2">"%Y-%m-%d %H:%M:%S"</span><span class="si">)</span><span class="p">;</span>
    <span class="nb">echo</span> <span class="s2">"[*] "</span><span class="nv">$current_time</span> <span class="s2">": "</span> <span class="nv">$1</span> <span class="o">&gt;&gt;</span> <span class="nv">$shell_log_path</span>
    <span class="nb">echo</span> <span class="s2">"[*] "</span><span class="nv">$current_time</span> <span class="s2">": "</span> <span class="nv">$1</span>
<span class="o">}</span>


change_socks<span class="o">(){</span>
    <span class="nb">local </span><span class="nv">socks_ip</span><span class="o">=</span><span class="nv">$1</span><span class="p">;</span>
    <span class="nb">local </span><span class="nv">socks_port</span><span class="o">=</span><span class="nv">$2</span><span class="p">;</span>
    socks_loging <span class="s2">"Change Socks: </span><span class="nv">$1</span><span class="s2">, Port: </span><span class="nv">$2</span><span class="s2">"</span><span class="p">;</span>
    <span class="c"># 61行是Socks IP</span>
    <span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'61d'</span> <span class="nv">$redsocks_config_file_path</span>
    <span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"61i</span><span class="se">\ </span><span class="s2">       ip=</span><span class="nv">$socks_ip</span><span class="s2">;"</span>  <span class="nv">$redsocks_config_file_path</span>

    <span class="c"># 62行是Socks Port</span>
    <span class="nb">sed</span> <span class="nt">-i</span> <span class="s1">'62d'</span> <span class="nv">$redsocks_config_file_path</span>
    <span class="nb">sed</span> <span class="nt">-i</span> <span class="s2">"62i</span><span class="se">\ </span><span class="s2">       port=</span><span class="nv">$socks_port</span><span class="s2">;"</span>  <span class="nv">$redsocks_config_file_path</span>
    pkill redsocks
    socks_loging <span class="s2">"Run redsocks...."</span>
    <span class="nv">$redsocks_bin_path</span> <span class="nt">-c</span> <span class="nv">$redsocks_config_file_path</span>
<span class="o">}</span>

start_pentest<span class="o">(){</span>
    uninstall_iptables
    iptables <span class="nt">-t</span> nat <span class="nt">-N</span> REDSOCKS
    iptables <span class="nt">-t</span> nat <span class="nt">-F</span> REDSOCKS <span class="c"># 清空</span>
    
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> PREROUTING <span class="nt">-p</span> tcp <span class="nt">-j</span> REDSOCKS
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-p</span> tcp <span class="nt">-d</span> 10.0.0.0/8 <span class="nt">-j</span> REDIRECT <span class="nt">--to-port</span> 31338
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-p</span> tcp <span class="nt">-d</span> 172.0.0.0/8 <span class="nt">-j</span> REDIRECT <span class="nt">--to-port</span> 31338
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-p</span> tcp <span class="nt">-d</span> 192.168.0.0/16 <span class="nt">-j</span> REDIRECT <span class="nt">--to-port</span> 31338
    
    unset_iptables
    set_iptables
    <span class="nb">local </span><span class="nv">socks_ip</span><span class="o">=</span><span class="nv">$1</span><span class="p">;</span>
    <span class="nb">local </span><span class="nv">socks_port</span><span class="o">=</span><span class="nv">$2</span><span class="p">;</span>
    change_socks <span class="nv">$socks_ip</span> <span class="nv">$socks_port</span>
    socks_loging <span class="s2">"Change Socks: </span><span class="nv">$1</span><span class="s2">, Port: </span><span class="nv">$2</span><span class="s2">"</span><span class="p">;</span>

<span class="o">}</span>

install_iptables<span class="o">(){</span>
    iptables <span class="nt">-t</span> nat <span class="nt">-F</span> OUTPUT
    iptables <span class="nt">-t</span> nat <span class="nt">-F</span> PREROUTING
    <span class="c"># 如果没有就新建一个</span>
    <span class="nb">local </span><span class="nv">is_redsocks</span><span class="o">=</span><span class="sb">`</span>iptables <span class="nt">-t</span> nat <span class="nt">-nL</span> <span class="nt">--line-number</span> |grep REDSOCKS<span class="sb">`</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$is_redsocks</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span>iptables <span class="nt">-t</span> nat <span class="nt">-N</span> REDSOCKS
    <span class="k">fi
    </span>iptables <span class="nt">-t</span> nat <span class="nt">-F</span> REDSOCKS <span class="c"># 清空</span>
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> PREROUTING <span class="nt">-p</span> tcp <span class="nt">-j</span> REDSOCKS
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-p</span> tcp <span class="nt">--dport</span> <span class="nv">$ssh_port</span> <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-d</span> &lt;SOCKS API Server&gt; <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-d</span> 10.0.0.0/8 <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-d</span> 127.0.0.0/8 <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-d</span> 169.254.0.0/16 <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-d</span> 172.16.0.0/12 <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-d</span> 192.168.0.0/16 <span class="nt">-j</span> RETURN
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> REDSOCKS <span class="nt">-p</span> tcp <span class="nt">-j</span> REDIRECT <span class="nt">--to-port</span> 31338
    socks_loging <span class="s2">"Install Success!"</span>
<span class="o">}</span>


uninstall_iptables<span class="o">(){</span>
    iptables <span class="nt">-t</span> nat <span class="nt">-F</span> OUTPUT
    iptables <span class="nt">-t</span> nat <span class="nt">-F</span> PREROUTING
    socks_loging <span class="s2">"Uninstall iptables  ..."</span>
    <span class="nv">is_redsocks</span><span class="o">=</span><span class="sb">`</span>iptables <span class="nt">-t</span> nat <span class="nt">-nvL</span> REDSOCKS |wc <span class="nt">-l</span><span class="sb">`</span>
    <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$is_redsocks</span><span class="s2">"</span><span class="o">!=</span><span class="s2">"0"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span>iptables <span class="nt">-t</span> nat <span class="nt">-F</span> REDSOCKS
            iptables <span class="nt">-t</span> nat <span class="nt">-X</span> REDSOCKS
    <span class="k">fi</span>
<span class="o">}</span>


set_iptables<span class="o">(){</span>
    iptables <span class="nt">-t</span> nat <span class="nt">-A</span> OUTPUT <span class="nt">-p</span> tcp <span class="nt">-m</span> owner <span class="o">!</span> <span class="nt">--uid-owner</span> <span class="nv">$redsocks_user</span>  <span class="nt">-j</span> REDSOCKS
<span class="o">}</span>

unset_iptables<span class="o">(){</span>
    <span class="nv">ids</span><span class="o">=</span><span class="sb">`</span>iptables <span class="nt">-t</span> nat <span class="nt">-nL</span> OUTPUT <span class="nt">--line-number</span> | <span class="nb">grep </span>REDSOCKS | <span class="nb">awk</span> <span class="s1">'{print $1}'</span><span class="sb">`</span>
    <span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$ids</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
        </span>socks_loging <span class="s2">"No Set Iptables ..."</span>
        <span class="k">return
    fi
    </span><span class="nv">id_array</span><span class="o">=(</span><span class="k">${</span><span class="nv">ids</span><span class="p">//\n/ </span><span class="k">}</span><span class="o">)</span>
    socks_loging <span class="s2">"REDSOCKS OUTPUT Chian ID : </span><span class="nv">$id_array</span><span class="s2">"</span>
    <span class="k">for </span><span class="nb">id </span><span class="k">in</span> <span class="k">${</span><span class="nv">id_array</span><span class="p">[@]</span><span class="k">}</span>
    <span class="k">do
        </span><span class="nb">id</span><span class="o">=</span><span class="sb">`</span><span class="nb">echo</span> <span class="nv">$id</span>|egrep <span class="nt">-o</span> <span class="s2">"[0-9]{1,4}"</span><span class="sb">`</span>
        <span class="k">if</span> <span class="o">[</span> <span class="nv">$id</span><span class="o">!=</span><span class="s2">""</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
            </span>iptables <span class="nt">-t</span> nat <span class="nt">-D</span> OUTPUT <span class="nv">$id</span>
        <span class="k">fi
    done</span>
<span class="o">}</span>




<span class="k">if</span> <span class="o">[</span> <span class="nt">-z</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span><span class="nb">echo</span> <span class="s2">"[*] Usage : </span><span class="nv">$0</span><span class="s2"> &lt;start | stop | clean | install | uninstall | change IP PORT | pentest IP PORT&gt;
        </span><span class="nv">$0</span><span class="s2"> start : 启动redsocks，自动设置iptables
        </span><span class="nv">$0</span><span class="s2"> stop : 停止redsocks，自动清空iptables
        </span><span class="nv">$0</span><span class="s2"> clean : 清空iptables所有规则
        </span><span class="nv">$0</span><span class="s2"> install : 安装iptables规则
        </span><span class="nv">$0</span><span class="s2"> uninstall : 卸载iptables规则
        </span><span class="nv">$0</span><span class="s2"> change : 改变Socks的IP和端口
        </span><span class="nv">$0</span><span class="s2"> pentest : 开始内网渗透，传入Socks的IP和端口
    "</span>
    <span class="nb">exit </span>0
<span class="k">fi



if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"install"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span>install_iptables
    <span class="nb">exit </span>0
<span class="k">fi

if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="o">=</span> <span class="s2">"pentest"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then
    </span>start_pentest <span class="nv">$2</span> <span class="nv">$3</span>
    <span class="nb">exit </span>0
</code></pre></div></div>

<p>使用方式：</p>

<ul>
  <li>打点模式简单使用（每执行一次，向API拉取新的代理）：</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/3f7fbf0e76f8be710f42eae1d7208f03.png" alt="2020-11-13-22-04-21"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./socks-switch.sh <span class="nb">install
sudo</span> ./socks-switch.sh start
</code></pre></div></div>

<ul>
  <li>切换至内网模式使用：</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/43e402f8721263614c54e93ae936caca.png" alt="2020-11-13-22-00-56"></p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./socks-switch.sh uninstall
<span class="nb">sudo</span> ./socks-switch.sh pentest &lt;Socks IP&gt; &lt;Socks Port&gt;
</code></pre></div></div>

<ul>
  <li>手动指定Socks的IP和端口（打点模式与内网模式兼容）：</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo</span> ./socks-switch.sh change &lt;Socks IP&gt; &lt;Socks Port&gt;
</code></pre></div></div>

<h2 id="0x06-树莓派实现6小时切换一次出口的wifi">0x06 树莓派实现6小时切换一次出口的WiFi</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/178bdc368b3cdd9cbe492cb9e033d19c.png" alt="2020-11-13-21-36-29"></p>

<p>这个是我在熟悉透明代理后产生的想法，适合“团队作战”，尤其是Web渗透这块最消耗IP了，实验室的小伙伴大多也都是笔记本，因此想出了用树莓派实现6小时切换一次出口的WiFi，当然了，也能把穿透内网的Socks变成一个WiFi :)</p>

<h3 id="更改redsocks监听地址">更改redsocks监听地址</h3>

<p>如果是多网卡需要把redsocks配置文件<code class="language-plaintext highlighter-rouge">/etc/redsocks.conf</code>的监听IP地址改为：0.0.0.0，不然在<code class="language-plaintext highlighter-rouge">wlan0</code>的流量转向<code class="language-plaintext highlighter-rouge">eth0</code>的时候，会找不到31338端口。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>local_ip = 0.0.0.0;
local_port = 31338;
</code></pre></div></div>

<h3 id="安装创建ap的工具">安装创建AP的工具</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sudo apt-get install util-linux procps hostapd iproute2 iw haveged dnsmasq
sudo git clone https://github.com/oblique/create_ap
cd create_ap
sudo make install
</code></pre></div></div>

<p>创建WiFi：<code class="language-plaintext highlighter-rouge">/usr/bin/create_ap -w 2 wlan0 eth0 &lt;WiFi Name&gt; &lt;WiFi Pass&gt;</code></p>

<blockquote>
  <p>-w 为启用WPA2</p>
</blockquote>

<h3 id="编写ap服务脚本">编写AP服务脚本</h3>

<p>在 <code class="language-plaintext highlighter-rouge">/usr/lib/systemd/system/</code>创建<code class="language-plaintext highlighter-rouge">wifi.service</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[Unit]
Description=Create AP Service
After=network.target

[Service]
Type=simple
ExecStart=/usr/bin/create_ap -w 2 wlan0 eth0 &lt;WiFi Name&gt; &lt;WiFi Pass&gt; 
KillSignal=SIGINT
Restart=on-failure
RestartSec=5

[Install]
WantedBy=multi-user.target
</code></pre></div></div>

<h3 id="编写计划任务脚本">编写计划任务脚本</h3>

<p>random-wifi.sh:</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/bash</span>
<span class="nb">cd</span> /home/pi/socks-switch
systemctl stop wifi <span class="c"># 先停止WiFi</span>
./socks-switch.sh clean <span class="c"># 清空规则</span>
./socks-switch.sh <span class="nb">install</span> <span class="c"># 安装规则</span>
./socks-switch.sh start <span class="c"># 启用规则</span>
systemctl start wifi <span class="c"># 创建WiFi</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">sudo crontab -e</code>进入root用户的计划任务编写：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* */6 * * * /home/pi/socks-switch/random-wifi.sh # 每隔六小时重置一次，并获取新的出口代理
</code></pre></div></div>

<h3 id="待完善的缺点">待完善的缺点</h3>

<p>比如在切换新的出口时，WiFi是关闭的，现在的客户端一般都是会自动寻找下一个WiFi自动连接的，如果工具正在扫描会导致真实出口IP被发现。</p>

<p>思路：在切换WiFi前，将<code class="language-plaintext highlighter-rouge">wlan0</code>网卡的流量全部<code class="language-plaintext highlighter-rouge">DROP</code>，这样WiFi也不需要重启。</p>

<p>放两张喜爱的桌面：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1cc07d325b3c9001629ed2d81c8492f0.png" alt="2020-11-13-21-55-15"></p>

<h2 id="0x07-总结">0x07 总结</h2>

<p>通过动手实践，解决了工作痛点，让技术的价值发挥出来更能收获成就感。</p>

<p>期间还实现了科学上网的透明代理，但是与工作无关，网络上已经大把帖子了，收获颇多，关于渗透还需要研究更多，看问题的角度也要多变，就如上一篇<a href="https://payloads.online/archivers/2020-11-01/1">Web正向代理的思考</a>
，虽说不是一个通用技术，但是能够解决一些场景的问题，提升效率。</p>

  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
