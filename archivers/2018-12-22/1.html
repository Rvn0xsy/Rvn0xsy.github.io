<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>DLL Hijacking &amp; COM Hijacking ByPass UAC - 议题解读 « 倾旋的博客</title>
  <meta name="description" content="  在线地址：https://www.bilibili.com/video/av51718274/   0x00 前言  0x01 何为劫持  0x02 DLL是什么  0X03 DLL的加载过程          DLL的加载过程 – Know DLLs注册表项      DLL的加载过程 – Process ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/archivers/2018-12-22/1">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">DLL Hijacking &amp; COM Hijacking ByPass UAC - 议题解读</h1>
    <p class="post-meta">Dec 22, 2018</p>
  </header>

  <article class="post-content">
    <blockquote>
  <p>在线地址：<a href="https://www.bilibili.com/video/av51718274/">https://www.bilibili.com/video/av51718274/</a></p>
</blockquote>

<iframe src="//player.bilibili.com/player.html?aid=51718274&page=1&cid" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="95%" height="450"> </iframe>

<ul id="markdown-toc">
  <li><a href="#0x00-%E5%89%8D%E8%A8%80" id="markdown-toc-0x00-前言">0x00 前言</a></li>
  <li><a href="#0x01-%E4%BD%95%E4%B8%BA%E5%8A%AB%E6%8C%81" id="markdown-toc-0x01-何为劫持">0x01 何为劫持</a></li>
  <li><a href="#0x02-dll%E6%98%AF%E4%BB%80%E4%B9%88" id="markdown-toc-0x02-dll是什么">0x02 DLL是什么</a></li>
  <li>
<a href="#0x03-dll%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" id="markdown-toc-0x03-dll的加载过程">0X03 DLL的加载过程</a>    <ul>
      <li><a href="#dll%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B--know-dlls%E6%B3%A8%E5%86%8C%E8%A1%A8%E9%A1%B9" id="markdown-toc-dll的加载过程--know-dlls注册表项">DLL的加载过程 – Know DLLs注册表项</a></li>
      <li><a href="#dll%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B--process-monitor" id="markdown-toc-dll的加载过程--process-monitor">DLL的加载过程 – Process Monitor</a></li>
      <li><a href="#dll%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B--process-monitor-filter" id="markdown-toc-dll的加载过程--process-monitor-filter">DLL的加载过程 – Process Monitor Filter</a></li>
    </ul>
  </li>
  <li><a href="#0x04-dll%E5%8A%AB%E6%8C%81%E7%9A%84%E5%8E%9F%E7%90%86" id="markdown-toc-0x04-dll劫持的原理">0x04 DLL劫持的原理</a></li>
  <li>
<a href="#0x05-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdll%E5%8A%AB%E6%8C%81--dll-main" id="markdown-toc-0x05-实现一个dll劫持--dll-main">0x05 实现一个DLL劫持 – DLL Main</a>    <ul>
      <li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAdll%E5%8A%AB%E6%8C%81--dll-main" id="markdown-toc-实现一个dll劫持--dll-main">实现一个DLL劫持 – DLL Main</a></li>
      <li><a href="#%E6%A1%88%E4%BE%8B" id="markdown-toc-案例">案例</a></li>
      <li><a href="#%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95" id="markdown-toc-自动化测试">自动化测试</a></li>
    </ul>
  </li>
  <li><a href="#0x06-%E4%BB%80%E4%B9%88%E6%98%AFcom" id="markdown-toc-0x06-什么是com">0x06 什么是COM</a></li>
  <li>
<a href="#0x07-%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8Ecom%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB" id="markdown-toc-0x07-应用程序与com注册表的关系">0x07 应用程序与COM注册表的关系</a>    <ul>
      <li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8Ecom%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB---clsid" id="markdown-toc-应用程序与com注册表的关系---clsid">应用程序与COM注册表的关系 - CLSID</a></li>
      <li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8Ecom%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB---%E4%BD%BF%E7%94%A8com%E7%BB%84%E4%BB%B6" id="markdown-toc-应用程序与com注册表的关系---使用com组件">应用程序与COM注册表的关系 - 使用COM组件</a></li>
      <li><a href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E4%B8%8Ecom%E6%B3%A8%E5%86%8C%E8%A1%A8%E7%9A%84%E5%85%B3%E7%B3%BB--clsid-key" id="markdown-toc-应用程序与com注册表的关系--clsid-key">应用程序与COM注册表的关系 – CLSID Key</a></li>
    </ul>
  </li>
  <li><a href="#0x08-com%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B" id="markdown-toc-0x08-com组件的加载过程">0x08 COM组件的加载过程</a></li>
  <li><a href="#0x09-com%E7%BB%84%E4%BB%B6%E7%9A%84%E5%8A%AB%E6%8C%81%E5%8E%9F%E7%90%86" id="markdown-toc-0x09-com组件的劫持原理">0x09 COM组件的劫持原理</a></li>
  <li>
<a href="#0x10-%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcom%E7%BB%84%E4%BB%B6%E5%8A%AB%E6%8C%81" id="markdown-toc-0x10-实现一个com组件劫持">0x10 实现一个COM组件劫持</a>    <ul>
      <li><a href="#%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAcom%E7%BB%84%E4%BB%B6%E5%8A%AB%E6%8C%81--%E5%88%86%E6%9E%90" id="markdown-toc-实现一个com组件劫持--分析">实现一个COM组件劫持 – 分析</a></li>
    </ul>
  </li>
  <li><a href="#0x11-uac%E7%AE%80%E4%BB%8B" id="markdown-toc-0x11-uac简介">0x11 UAC简介</a></li>
  <li><a href="#0x12-bypass-uac%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F" id="markdown-toc-0x12-bypass-uac的几种方式">0x12 ByPass UAC的几种方式</a></li>
  <li><a href="#0x13-bypass-uac%E7%9A%84%E5%8E%9F%E7%90%86---%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87autoelevate" id="markdown-toc-0x13-bypass-uac的原理---自动提升autoelevate">0x13 ByPass UAC的原理 - 自动提升（autoElevate）</a></li>
  <li>
<a href="#0x14-bypass-uac%E6%BC%94%E7%A4%BA---fodhelperexe" id="markdown-toc-0x14-bypass-uac演示---fodhelperexe">0x14 Bypass UAC演示 - fodhelper.exe</a>    <ul>
      <li><a href="#bypass-uac%E6%BC%94%E7%A4%BA---fodhelperexe%E8%87%AA%E5%8A%A8%E5%8C%96%E5%88%86%E6%9E%90" id="markdown-toc-bypass-uac演示---fodhelperexe自动化分析">ByPass UAC演示 - fodhelper.exe（自动化分析）</a></li>
    </ul>
  </li>
  <li>
<a href="#0x15-%E6%8C%96%E6%8E%98bypass-uac%E7%9A%84%E6%96%B9%E6%B3%95" id="markdown-toc-0x15-挖掘bypass-uac的方法">0x15 挖掘ByPass UAC的方法</a>    <ul>
      <li><a href="#%E5%AF%BB%E6%89%BE%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F--sigcheckexe" id="markdown-toc-寻找自动提升权限的应用程序--sigcheckexe">寻找自动提升权限的应用程序 – Sigcheck.exe</a></li>
      <li><a href="#%E5%AF%BB%E6%89%BE%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-stringsexe" id="markdown-toc-寻找自动提升权限的应用程序-stringsexe">寻找自动提升权限的应用程序 Strings.exe</a></li>
      <li><a href="#%E5%AF%BB%E6%89%BE%E8%87%AA%E5%8A%A8%E6%8F%90%E5%8D%87%E6%9D%83%E9%99%90%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F-sigcheckexe" id="markdown-toc-寻找自动提升权限的应用程序-sigcheckexe">寻找自动提升权限的应用程序 Sigcheck.exe</a></li>
    </ul>
  </li>
  <li><a href="#0x16-%E5%8F%82%E8%80%83" id="markdown-toc-0x16-参考">0x16 参考</a></li>
  <li><a href="#0x17-%E5%85%B3%E4%BA%8E%E6%88%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%88%90%E9%95%BF%E5%8F%A3%E8%A2%8B" id="markdown-toc-0x17-关于我的安全成长口袋">0x17 关于“我的安全成长口袋”</a></li>
</ul>

<h2 id="0x00-前言">0x00 前言</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x00.png" alt=""></p>

<p>本文章只是方便阅读PPT，对于深入的去理解没有太大帮助，只是做个知识索引。</p>

<p>目录如下：</p>

<ul>
  <li>何为劫持</li>
  <li>DLL是什么</li>
  <li>DLL加载的过程</li>
  <li>DLL劫持的原理</li>
  <li>实现一个DLL劫持 - DLL Main</li>
  <li>什么是COM</li>
  <li>应用程序与COM注册表的关系</li>
  <li>COM组件加载的过程</li>
  <li>COM组件劫持的原理</li>
  <li>实现一个COM组件劫持</li>
  <li>UAC简介</li>
  <li>ByPASS UAC的几种方式</li>
  <li>ByPASS UAC原理</li>
  <li>ByPASS UAC演示</li>
  <li>挖掘ByPASS UAC的方法</li>
</ul>

<p><strong>PPT共享在文末的小密圈中了</strong></p>

<h2 id="0x01-何为劫持">0x01 何为劫持</h2>

<p>即：“在正常事物发生之前进行一个旁路操作”</p>

<h2 id="0x02-dll是什么">0x02 DLL是什么</h2>

<p>DLL(Dynamic Link Library)文件为动态链接库文件，又称“应用程序拓展”，是软件文件类型。 在Windows中，许多应用程序并不是一个完整的可执行文件，它们被分割成一些相对独立的动态链接库，即DLL文件，放置于系统中。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x01.png" alt=""></p>

<p>在Windows平台下，我们使用的应用程序中的功能其实大多都很相似，窗口调用窗口的模块，分配内存调用内存管理的模块，文件操作调用IO模块，这些模块在Windows里的具体表现就是DLL文件。</p>

<h2 id="0x03-dll的加载过程">0X03 DLL的加载过程</h2>

<ul>
  <li>1.程序所在目录</li>
  <li>2.程序加载目录（SetCurrentDirectory）</li>
  <li>3.系统目录即 SYSTEM32 目录</li>
  <li>4.16位系统目录即 SYSTEM 目录</li>
  <li>5.Windows目录</li>
  <li>6.PATH环境变量中列出的目录</li>
</ul>

<p>PS：Windows操作系统通过“DLL路径搜索目录顺序”和“Know DLLs注册表项”的机制来确定应用程序所要调用的DLL的路径，之后，应用程序就将DLL载入了自己的内存空间，执行相应的函数功能。</p>

<p>注册表路径：HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\KnownDLLs</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x02.png" alt=""></p>

<h3 id="dll的加载过程--know-dlls注册表项">DLL的加载过程 – Know DLLs注册表项</h3>

<p>Know DLLs注册表项里的DLL列表在应用程序运行后就已经加入到了内核空间中，多个进程公用这些模块，必须具有非常高的权限才能修改。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x03.png" alt=""></p>

<h3 id="dll的加载过程--process-monitor">DLL的加载过程 – Process Monitor</h3>

<p>Process Monitor是Windows的高级监视工具，可显示实时文件系统，注册表和进程/线程活动。</p>

<p>它结合了两个传统Sysinternals实用程序Filemon和Regmon的功能，并添加了大量增强功能，包括丰富和非破坏性过滤，全面的事件属性，如会话ID和用户名，可靠的流程信息，带有集成符号支持的完整线程堆栈 对于每个操作，同时记录到文件等等。 其独特的强大功能将使Process Monitor成为系统故障排除和恶意软件搜索工具包的核心实用程序。</p>

<p>下载地址： https://docs.microsoft.com/zh-cn/sysinternals/downloads/process-utilities</p>

<h3 id="dll的加载过程--process-monitor-filter">DLL的加载过程 – Process Monitor Filter</h3>

<p>Process Monitor Filter是用于过滤应用程序输出的一部分功能，可以使得进程事件结果成为你想要的内容。</p>

<p>常用过滤条件：Process Name，Path，Result</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x04.png" alt=""></p>

<h2 id="0x04-dll劫持的原理">0x04 DLL劫持的原理</h2>

<p>DLL寻找过程：</p>

<ul>
  <li>1.程序所在目录</li>
  <li>2.系统目录即 SYSTEM32 目录</li>
  <li>3.16位系统目录即 SYSTEM 目录</li>
  <li>4.Windows目录</li>
  <li>5.加载 DLL 时所在的当前目录</li>
  <li>6.PATH环境变量中列出的目录</li>
</ul>

<p><strong>如果在应用程序寻找成功之前，将我们自己创造的DLL文件放入寻找目录中，那么应用程序就会加载我们自己的DLL？</strong></p>

<h2 id="0x05-实现一个dll劫持--dll-main">0x05 实现一个DLL劫持 – DLL Main</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span> 
<span class="c1">// 指向自身的句柄</span>
 <span class="n">_In_</span> <span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> 
<span class="c1">// 调用原因</span>
 <span class="n">_In_</span> <span class="n">DWORD</span>     <span class="n">fdwReason</span><span class="p">,</span>
<span class="c1">// 加载方式（隐式、显式）</span>
  <span class="n">_In_</span> <span class="n">LPVOID</span>    <span class="n">lpvReserved</span>
<span class="p">);</span>
</code></pre></div></div>

<table>
  <thead>
    <tr>
      <th>载入状态</th>
      <th>值</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>DLL_PROCESS_ATTACH</td>
      <td>1</td>
      <td>被进程装载时</td>
    </tr>
    <tr>
      <td>DLL_PROCESS_DETACH</td>
      <td>0</td>
      <td>被进程卸载时</td>
    </tr>
    <tr>
      <td>DLL_THREAD_ATTACH</td>
      <td>2</td>
      <td>被线程装载时</td>
    </tr>
    <tr>
      <td>DLL_THREAD_DETACH</td>
      <td>3</td>
      <td>被线程卸载时</td>
    </tr>
  </tbody>
</table>

<h3 id="实现一个dll劫持--dll-main">实现一个DLL劫持 – DLL Main</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">APIENTRY</span> <span class="nf">DllMain</span><span class="p">(</span><span class="n">HANDLE</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">){</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"hModule.%p lpReserved.%p </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">lpReserved</span><span class="p">);</span><span class="err">  </span> <span class="k">switch</span> <span class="p">(</span><span class="n">ul_reason_for_call</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Process attach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Process detach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Thread attach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Thread detach. </span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">return</span> <span class="p">(</span><span class="n">TRUE</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Q：如果应用程序调用的DLL没有DLLMain函数呢？</p>

<p>A：这需要实现指定导出函数，然后等待导出函数执行完毕再Load真实DLL。</p>

<h3 id="案例">案例</h3>

<p>参考：</p>

<ul>
  <li>http://payloads.online/archivers/2018-06-09/1</li>
  <li>http://payloads.online/archivers/2018-08-15/1</li>
  <li>https://docs.microsoft.com/en-us/windows/desktop/dlls/dllmain</li>
  <li>https://baike.baidu.com/item/dll%E5%8A%AB%E6%8C%81/223198</li>
</ul>

<h3 id="自动化测试">自动化测试</h3>

<p>Rattler：https://github.com/sensepost/rattler</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x05.png" alt=""></p>

<p>Robber：https://github.com/MojtabaTajik/Robber</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x06.png" alt=""></p>

<h2 id="0x06-什么是com">0x06 什么是COM</h2>

<p>COM是Component Object Model （组件对象模型）的缩写。
COM是微软公司为了计算机工业的软件生产更加符合人类的行为方式开发的一种新的软件开发技术。在COM构架下，人们可以开发出各种各样的功能专一的组件，然后将它们按照需要组合起来，构成复杂的应用系统。</p>

<h2 id="0x07-应用程序与com注册表的关系">0x07 应用程序与COM注册表的关系</h2>

<p>首先需要介绍一下注册表，注册表可以理解为一个树状结构的数据库，它具有一些特殊的<a href="https://docs.microsoft.com/en-us/windows/desktop/sysinfo/registry-value-types">数据类型</a>用来存储一些数据满足应用程序的需要。</p>

<p>https://docs.microsoft.com/en-us/windows/desktop/sysinfo/about-the-registry</p>

<table>
  <thead>
    <tr>
      <th>名称</th>
      <th>作用</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>HKEY_CLASSES_ROOT</td>
      <td>用于存储一些文档类型、类、类的关联属性。</td>
    </tr>
    <tr>
      <td>HKEY_CURRENT_CONFIG</td>
      <td>用户存储有关本地计算机系统的当前硬件配置文件信息。</td>
    </tr>
    <tr>
      <td>HKEY_CURRENT_USER</td>
      <td>用于存储当前用户配置项。</td>
    </tr>
    <tr>
      <td>HKEY_CURRENT_USER_LOCAL_SETTINGS</td>
      <td>用于存储当前用户对计算机的配置项。</td>
    </tr>
    <tr>
      <td>HKEY_LOCAL_MACHINE</td>
      <td>用于存储当前用户物理状态。</td>
    </tr>
    <tr>
      <td>HKEY_USERS</td>
      <td>用于存储新用户的默认配置项。</td>
    </tr>
  </tbody>
</table>

<p><a href="https://docs.microsoft.com/en-us/windows/desktop/sysinfo/hkey-classes-root-key">HKEY_CLASSES_ROOT</a> = HKEY_LOCAL_MACHINE + HKEY_CURRENT_USER</p>

<h3 id="应用程序与com注册表的关系---clsid">应用程序与COM注册表的关系 - CLSID</h3>

<p>首先需要介绍一下CLSID(Class Identifier)，中文翻译为：“全局唯一标识符”。</p>

<p>CLSID是指Windows系统对于不同的应用程序，文件类型，OLE对象，特殊文件夹以及各种系统组件分配的一个唯一表示它的ID代码，用于对其身份的标识和与其他对象进行区分。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x07.png" alt=""></p>

<h3 id="应用程序与com注册表的关系---使用com组件">应用程序与COM注册表的关系 - 使用COM组件</h3>

<p>按下Ctrl+R打开运行窗口，键入 
::{20D04FE0-3AEA-1069-A2D8-08002B30309D} 即可打开“我的电脑”</p>

<p>::{645FF040-5081-101B-9F08-00AA002F954E} 回收站</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="n">CLSID</span><span class="err">结构体：</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">_GUID</span> <span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">Data1</span><span class="p">;</span> <span class="c1">// 随机数</span>
    <span class="n">WORD</span> <span class="n">Data2</span><span class="p">;</span> <span class="c1">// 和时间相关</span>
    <span class="n">WORD</span> <span class="n">Data3</span><span class="p">;</span> <span class="c1">// 和时间相关</span>
    <span class="n">BYTE</span> <span class="n">Data4</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="c1">// 和网卡MAC相关</span>
    <span class="p">}</span> <span class="n">GUID</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">GUID</span> <span class="n">CLSID</span><span class="p">;</span> <span class="err"> </span><span class="c1">// 组件ID</span>
    <span class="k">typedef</span> <span class="n">GUID</span> <span class="n">IID</span><span class="p">;</span> <span class="err"> </span> <span class="err"> </span><span class="c1">// 接口ID</span>
</code></pre></div></div>

<h3 id="应用程序与com注册表的关系--clsid-key">应用程序与COM注册表的关系 – CLSID Key</h3>

<table>
  <thead>
    <tr>
      <th>Key Name</th>
      <th>说明</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>InprocHandler32</td>
      <td>指定应用程序使用的自定义处理程序</td>
    </tr>
    <tr>
      <td>InprocServer32</td>
      <td>注册32位进程所需要的模块、线程属性配置</td>
    </tr>
  </tbody>
</table>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKEY_LOCAL_MACHINE\SOFTWARE\Classes\CLSID   
 	{CLSID}       
	InprocServer32          (Default) = path          
	ThreadingModel 	    = value
</code></pre></div></div>

<p>常见CLSID Key：</p>

<p>More： https://docs.microsoft.com/zh-cn/windows/desktop/com/clsid-key-hklm</p>

<h2 id="0x08-com组件的加载过程">0x08 COM组件的加载过程</h2>

<ul>
  <li>1.HKCU\Software\Classes\CLSID</li>
  <li>2.HKCR\CLSID</li>
  <li>3.HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\ShellCompatibility\Objects\</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x08.png" alt=""></p>

<h2 id="0x09-com组件的劫持原理">0x09 COM组件的劫持原理</h2>

<p>当进程寻找COM组件时，首先会寻找：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>HKCU\Software\Classes\CLSID
</code></pre></div></div>

<p>我们直接在CLSID下新建一个对象ID，就能够劫持某个进程或多个进程。</p>

<p>与DLL劫持原理相近，但是COM组件的劫持可以拓展很多东西，劫持的目标不一定是一个进程，劫持所需的文件不一定是一个DLL，它可以是一个.com文件、二进制PE文件、DLL文件，劫持的目标也可以是一个Windows API。</p>

<h2 id="0x10-实现一个com组件劫持">0x10 实现一个COM组件劫持</h2>

<p>MSF:/opt/metasploit-framework/embedded/framework/modules/exploits/windows/local/bypassuac_comhijack.rb</p>

<video src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/com_hijacking.mp4" controls="controls" width="500px">
哎呀~ 换个浏览器试试吧！
</video>

<h3 id="实现一个com组件劫持--分析">实现一个COM组件劫持 – 分析</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x09.png" alt=""></p>

<p>bypassuac_comhijack模块有两个方法：</p>

<ul>
  <li>Event Viewer</li>
  <li>Computer Managment</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x10.png" alt=""></p>

<p>经过分析，该模块是通过更改注册表，然后创建进程实现的bypassUAC。</p>

<h2 id="0x11-uac简介">0x11 UAC简介</h2>

<p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x11.png" alt=""></p>

<p>UAC需要授权的动作包括：</p>

<ul>
  <li>1.配置Windows Update</li>
  <li>2.增加或删除用户账户</li>
  <li>3.改变用户的账户类型</li>
  <li>4.改变UAC设置</li>
  <li>6.安装ActiveX</li>
  <li>6.安装或移除程序</li>
  <li>7.安装设备驱动程序</li>
  <li>8.设置家长控制</li>
  <li>9.将文件移动或复制到Program Files或Windows目录</li>
  <li>10.查看其他用户文件夹</li>
</ul>

<h2 id="0x12-bypass-uac的几种方式">0x12 ByPass UAC的几种方式</h2>

<ul>
  <li>1.白名单提权机制 - autoElevate</li>
  <li>2.DLL 劫持</li>
  <li>3.Windows 自身漏洞提权</li>
  <li>4.远程注入</li>
  <li>5.COM 接口技术</li>
</ul>

<h2 id="0x13-bypass-uac的原理---自动提升autoelevate">0x13 ByPass UAC的原理 - 自动提升（autoElevate）</h2>

<p>具有autoElevate属性True的应用程序会在启动时自动提升权限，而这些应用程序往往都具备微软的签名，微软认为它是可信的。故此，在该程序启动时，将会以管理员身份启动，假设我们通过COM技术或者DLL劫持该应用程序，也能够获得管理员权限，但是，上述两种技术比较苛刻：</p>

<ul>
  <li>1、可能需要高权限才能够完成</li>
  <li>2、分析成本较高</li>
</ul>

<h2 id="0x14-bypass-uac演示---fodhelperexe">0x14 Bypass UAC演示 - fodhelper.exe</h2>

<p>Path：C:\Windows\system32\fodhelper.exe</p>

<p>REG：HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x12.png" alt=""></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command /d C:\Windows\System32\cmd.exe /f
reg add HKEY_CURRENT_USER\Software\Classes\ms-settings\shell\open\command /v DelegateExecute /t REG_DWORD /d 00000000 /f
</code></pre></div></div>

<video src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/bypass_uac.mp4" controls="controls" width="500px">
哎呀~ 换个浏览器试试吧！
</video>

<h3 id="bypass-uac演示---fodhelperexe自动化分析">ByPass UAC演示 - fodhelper.exe（自动化分析）</h3>

<ul>
  <li>fodhelper.exe</li>
  <li>eventvwr.exe</li>
</ul>

<p>配置项：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x14.png" alt=""></p>

<p>调用进程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x15.png" alt=""></p>

<p>利用过程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x16.png" alt=""></p>

<h2 id="0x15-挖掘bypass-uac的方法">0x15 挖掘ByPass UAC的方法</h2>

<h3 id="寻找自动提升权限的应用程序--sigcheckexe">寻找自动提升权限的应用程序 – Sigcheck.exe</h3>

<p>Strings与Sigcheck，这两款工具目前均由微软官方提供，主要用于查看文件相关信息。</p>

<p>下载地址：https://docs.microsoft.com/zh-cn/sysinternals/downloads/</p>

<ul>
  <li>[1]：strings.exe -s *.exe | findstr /i autoelevate</li>
  <li>[2]：sigcheck.exe -m C:\Windows\System32\cmd.exe</li>
</ul>

<h3 id="寻找自动提升权限的应用程序-stringsexe">寻找自动提升权限的应用程序 Strings.exe</h3>

<p>最好将string.exe放入C:\Windows\System32</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x17.png" alt=""></p>

<h3 id="寻找自动提升权限的应用程序-sigcheckexe">寻找自动提升权限的应用程序 Sigcheck.exe</h3>

<p>使用Python脚本调用：</p>

<p>https://gist.githubusercontent.com/riyazwalikar/cd31948f247b96d472b97be2a36030b4/raw/a7379c4f5c015e46d65703ee73e674b1c4315810/findelevate.py</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x18.png" alt=""></p>

<h2 id="0x16-参考">0x16 参考</h2>

<ul>
  <li>https://www.gdatasoftware.com/blog/2014/10/23941-com-object-hijacking-the-discreet-way-of-persistence</li>
  <li>https://docs.microsoft.com/zh-cn/windows/desktop/com/clsid-key-hklm</li>
  <li>https://offsec.provadys.com/UAC-bypass-dotnet.html?utm_source=tuicool&utm_medium=referral</li>
  <li>https://github.com/FuzzySecurity/PowerShell-Suite/tree/master/Bypass-UAC</li>
  <li>https://3gstudent.github.io/3gstudent.github.io/Use-CLR-to-bypass-UAC/</li>
  <li>https://enigma0x3.net/2016/05/25/userland-persistence-with-scheduled-tasks-and-com-handler-hijacking/</li>
  <li>https://www.cyberbit.com/blog/endpoint-security/com-hijacking-windows-overlooked-security-vulnerability/</li>
  <li>https://technet.microsoft.com/zh-cn/library/2009.07.uac.aspx</li>
  <li>https://gist.githubusercontent.com/riyazwalikar/cd31948f247b96d472b97be2a36030b4/raw/a7379c4f5c015e46d65703ee73e674b1c4315810/findelevate.py</li>
  <li>https://github.com/rootm0s/WinPwnage/blob/master/functions/uac_fodhelper.py</li>
  <li>https://github.com/hfiref0x/UACME/tree/master/Source</li>
  <li>https://github.com/juliourena/plaintext/blob/master/CSharp%20Tools/UAC%20Bypass/uac_bypass_fodhelper.cs</li>
  <li>https://docs.microsoft.com/zh-cn/sysinternals/downloads/strings</li>
  <li>https://docs.microsoft.com/zh-cn/sysinternals/downloads/sigcheck</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x19.png" alt=""></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-12-22/0x20.png" alt=""></p>

<h2 id="0x17-关于我的安全成长口袋">0x17 关于“我的安全成长口袋”</h2>

<p>本圈主要用来记录自己技术生涯中短小的收获和知识的备忘，还有就是一些做安全服务工作中的感受。</p>

<p>方向可能会在不断改变：渗透测试、CTF、高效生活、应急响应、安全建设、读后感、代码审计、漏洞复现、运维杂项等等… 我暂时关闭了发帖权限、分享权限； 因为我有一个小的朋友圈，经常讨论一些技术，会在这里用评论交流。</p>

<p>关闭发帖权限是因为不指望加入的朋友分享，我发表的都是我的收获，不想因为别人影响自己的东西，妨碍搜索和温习。</p>

<p>扫码可免费加入：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2018-10-08/0x24.png" alt=""></p>


  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
